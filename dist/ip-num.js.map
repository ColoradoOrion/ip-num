{"version":3,"sources":["webpack://ipnum/webpack/bootstrap","webpack://ipnum/./src/BinaryUtils.ts","webpack://ipnum/./node_modules/big-integer/BigInteger.js","webpack://ipnum/./src/Validator.ts","webpack://ipnum/./src/HexadecimalUtils.ts","webpack://ipnum/./src/IPNumType.ts","webpack://ipnum/./src/IPv6.ts","webpack://ipnum/./src/IPv4.ts","webpack://ipnum/./src/Hexadecatet.ts","webpack://ipnum/./src/IPv6Utils.ts","webpack://ipnum/./src/AbstractIPNum.ts","webpack://ipnum/./src/SubnetMask.ts","webpack://ipnum/./src/Prefix.ts","webpack://ipnum/./src/Octet.ts","webpack://ipnum/./src/AbstractIpRange.ts","webpack://ipnum/./src/IPv6CidrRange.ts","webpack://ipnum/./src/IPv4CidrRange.ts","webpack://ipnum/./src/Asn.ts","webpack://ipnum/(webpack)/buildin/module.js","webpack://ipnum/./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","bigInt","IPNumType_1","decimalNumberToBinaryString","num","Number","toString","bigIntegerNumberToBinaryString","decimalNumberToOctetString","binaryString","length","Error","leftPadWithZeroBit","parseBinaryStringToBigInteger","dottedDecimalNotationToBinaryString","dottedDecimal","split","reduce","binaryAsString","octet","concat","parseInt","finalStringLength","repeat","cidrPrefixToSubnetMaskBinaryString","cidrPrefix","ipType","cidrUpperValue","IPNumType","IPv4","__WEBPACK_AMD_DEFINE_RESULT__","undefined","BASE","LOG_BASE","MAX_INT","MAX_INT_ARR","smallToArray","LOG_MAX_INT","Math","log","Integer","v","radix","parseValue","parseBase","BigInteger","sign","this","isSmall","SmallInteger","isPrecise","floor","arrayToSmall","arr","trim","compareAbs","createArray","x","Array","truncate","ceil","add","a","b","sum","l_a","l_b","carry","base","push","addAny","addSmall","subtract","difference","a_l","b_l","borrow","subtractSmall","multiplyLong","product","a_i","j","multiplySmall","shiftLeft","multiplySmallAndArray","square","divModSmall","lambda","q","remainder","divisor","quotient","divModAny","self","negate","abs","comparison","quotientDigit","shift","result","divisorMostSignificantDigit","divMod1","guess","xlen","highx","highy","check","part","unshift","reverse","divMod2","qSign","mod","mSign","isBasicPrime","isUnit","equals","isEven","isDivisibleBy","lesser","plus","subtractAny","minus","small","multiply","l1","l2","useKaratsuba","multiplyKaratsuba","y","max","slice","ac","bd","times","_multiplyBySmall","divmod","divide","over","pow","modPow","exp","isZero","isPositive","isOdd","compare","Infinity","compareTo","eq","notEquals","neq","greater","gt","lt","greaterOrEquals","geq","lesserOrEquals","leq","isNegative","isPrime","nPrev","prev","isProbablePrime","iterations","randBetween","modInv","lastT","lastR","zero","newT","one","newR","next","powersOfTwo","powers2Length","highestPower2","shift_isSmall","bitwise","fn","xSign","ySign","xRem","not","yRem","xDigit","yDigit","xDivMod","yDivMod","toJSNumber","String","shiftRight","remQuo","and","or","xor","LOBMASK_I","LOBMASK_BI","roughLOB","min","gcd","text","absBase","toLowerCase","test","charCodeAt","isNaN","digits","charCode","start","parseBaseFromArray","val","stringify","digit","charAt","toBase","apply","map","valueOf","neg","out","left","toBaseString","join","parseStringValue","decimalPlace","indexOf","parseNumberValue","toArray","str","toJSON","minusOne","lcm","isInstance","low","range","random","restricted","top","fromArray","BinaryUtils_1","BinaryUtils_2","IPv6Utils_1","HexadecimalUtils_1","HexadecimalUtils_2","Validator","isWithinRange","ipNumber","lowerBound","upperBound","isValidAsnNumber","asnNumber","isValid","THIRTY_TWO_BIT_SIZE","invalidAsnRangeMessage","isValid16BitAsnNumber","SIXTEEN_BIT_SIZE","invalid16BitAsnRangeMessage","isValidIPv4Number","ipv4Number","invalidIPv4NumberMessage","isValidIPv6Number","ipv6Number","ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE","invalidIPv6NumberMessage","isValidIPv4Octet","octetNumber","withinRange","EIGHT_BIT_SIZE","invalidOctetRangeMessage","isValidIPv6Hexadecatet","hexadecatetNum","invalidHexadecatetMessage","isValidIPv4String","ipv4String","rawOctets","includes","invalidOctetCountMessage","every","isNumeric","isValidIPv6String","ipv6String","hexadecimals","expandIPv6Number","invalidHexadecatetCountMessage","hexadecimal","isHexadecatet","error","isValidPrefixValue","prefixValue","ipNumType","invalidPrefixValueMessage","IPv6","invalidInetNumType","isValidIPv4SubnetMask","ipv4SubnetMaskString","ipv4InBinary","IPV4_SUBNET_MASK_BIT_PATTERN","invalidSubnetMaskMessage","isValidIPv6SubnetMask","ipv6SubnetMaskString","ipv6InBinary","hexadectetNotationToBinaryString","IPV6_SUBNET_MASK_BIT_PATTERN","isValidIPv4CidrNotation","ipv4RangeAsCidrString","cidrComponents","invalidIPv4CidrNotationMessage","ip","_a","__read","validIpv4","invalidIpv4Message","_b","validPrefix","invalidPrefixMessage","invalidMessage","isValidIPv4CidrRange","ipv4CidrNotation","isValidCidrRange","isValidIPv6CidrRange","ipv6CidrNotation","isValidIPv6CidrNotation","colonHexadecimalNotationToBinaryString","rangeString","cidrNotationValidator","toBinaryStringConverter","prefixFactory","validationResult","subnetMask","InvalidIPCidrRangeMessage","isValidIPv4RangeString","ipv4RangeString","isValidRange","firstIP","lastIP","isValidIPv6RangeString","ipv6RangeString","validator","firstLastValidator","rangeComponents","component","invalidRangeNotationMessage","validFirstIP","invalidFirstIPMessage","validLastIP","invalidLastIPMessage","invalidRangeFirstNotGreaterThanLastMessage","ipv6RangeAsCidrString","IPV6_RANGE_PATTERN","invalidIPv6CidrNotationString","isValidBinaryString","invalidBinaryStringErrorMessage","IPV4_PATTERN","RegExp","IPV4_RANGE_PATTERN","takeOutOfRangeSizeMessage","cannotSplitSingleRangeErrorMessage","bigIntegerNumberToHexadecimalString","hexadecimalStringToBinaryString","hexadecimalString","hexadecimalStringToHexadecatetString","hexidecimal","binaryStringToHexadecimalString","hexadectetString","hexadecimalAsString","hexavalue","Hexadecatet_1","Validator_1","AbstractIPNum_1","IPv4_1","BinaryUtils_3","_super","ipValue","_this","bitSize","maximumBitSize","type","hexadecatet","separator","expandedIPv6","constructFromHexadecimalDottedString","constructFromBigIntegerValue","__extends","fromBigInteger","bigIntValue","fromHexadecimalString","ipString","fromBinaryString","ipBinaryString","paddedBinaryString","fromIPv4","ipv4","toIPv4MappedIPv6","fromIPv4DotDecimalString","ip4DotDecimalString","getHexadecatet","nextIPNumber","getValue","previousIPNumber","message","filter","msg","binaryStringToHexadecatets","stringHexadecatet","Hexadecatet","fromString","match","AbstractIPNum","Octet_1","BinaryUtils_4","IPv6_1","octets","constructFromDecimalDottedString","fromDecimalDottedString","getOctets","binary","toBinaryString","rawOctet","Octet","binaryStringToDecimalOctets","ipv4BinaryString","givenValue","hexadecatetValue","rawValue","fromNumber","expandWithZero","hexadecimalArray","leftPortion","rightPortion","leftPortionSplit","rightPortionSplit","doublePortion","gapCount","pads","count","expandDoubleColon","leftString","rightString","collapseIPv6Number","contracted","withoutLeadingZero","replace","hasNext","hasPrevious","isEquals","anotherIPNum","isLessThan","isGreaterThan","isLessThanOrEquals","isGreaterThanOrEquals","IPv4SubnetMask","stringOctets","IPv6SubnetMask","stringHexadecimals","SubnetMask_1","SubnetMask_2","IPv4Prefix","toSubnetMask","onBits","offBits","toDecimalNotation","bits","substr","IPv6Prefix","toHexadecatetNotation","octetValue","AbstractIpRange","getSize","bitValue","inside","otherRange","thisFirst","getFirst","thisLast","getLast","otherFirst","otherLast","contains","isOverlapping","isConsecutive","hasNextRange","sizeOfCurrentRange","hasPreviousRange","Prefix_1","IPv6CidrRange","ipv6","internalCounterValue","fromCidr","rangeIncidrNotation","prefix","toCidrString","toRangeString","onMask","subnetMaskAsBigInteger","invertedSubnetMask","take","iPv6s","iteratingIPv6","counter","prefixToSplit","splitCidr","firstRange","nextRange","startOfNextRange","previousRange","startOfPreviousRange","returnValue","done","iterator","IPv4CidrRange","errorMessages","messages","subnetAsBigInteger","invertedSubnet","ipv4s","iteratingIPv4","errMessage","Asn","ASN","startWithASprefix","substring","parseFromDotNotation","valueAsBigInt","stringValue","AS_PREFIX","toASPlain","toASDot","toASDotPlus","high","is16Bit","is32Bit","word","values","webpackPolyfill","deprecate","paths","children","__export"],"mappings":"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","file":"./ip-num.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n","import * as bigInt from \"big-integer/BigInteger\";\nimport {IPNumType} from \"./IPNumType\";\n\n/**\n * Converts a decimal number to binary string\n *\n * @param num number to parse\n * @returns {string} the binary string representation of number\n */\n\nexport let decimalNumberToBinaryString = (num:number):string => {\n    return Number(num).toString(2);\n};\n\n/**\n * Converts a given BigInteger number to a binary string\n * @param num the BigInteger number\n * @returns {string} the binary string\n */\nexport let bigIntegerNumberToBinaryString = (num: bigInt.BigInteger): string => {\n    return num.toString(2);\n};\n\n\n/**\n * Converts a decimal number to binary octet (8 bit) string. If needed the octet will be padded with zeros\n * to make it up to 8 bits\n *\n * @param {number} num to convert to octet string\n * @returns {string} the octet string representation of given number\n */\nexport let decimalNumberToOctetString = (num:number): string => {\n    let binaryString = decimalNumberToBinaryString(num);\n    let length = binaryString.length;\n    if (length > 8) {\n        throw new Error(\"Given decimal in binary contains digits greater than an octet\")\n    }\n    return leftPadWithZeroBit(binaryString, 8);\n};\n\n/**\n * Parses number in binary to number in BigInteger\n *\n * @param num binary number in string to parse\n * @returns {number} binary number in BigInteger\n */\nexport let parseBinaryStringToBigInteger = (num:string): bigInt.BigInteger => {\n    return bigInt(num, 2);\n};\n\n/**\n * Given an IPv4 number in dot-decimal notated string, e.g 192.168.0.1 converts it to\n * binary string, e.g. '11000000101010000000000000000001'\n *\n * @param dottedDecimal IPv4 string in dot-decimal notation\n * @returns {string} the binary value of the given ipv4 number in string\n */\nexport let dottedDecimalNotationToBinaryString = (dottedDecimal: string): string => {\n    let stringOctets = dottedDecimal.split(\".\");\n    return stringOctets.reduce((binaryAsString, octet) => {\n        return binaryAsString.concat(decimalNumberToOctetString(parseInt(octet)));\n    }, '');\n};\n\n/**\n * Given a binary string, adds a number of zero to the left until string is as long as the given string length\n * @param {string} binaryString the string to pad\n * @param {number} finalStringLength the final length of string after padding\n * @returns {string}\n */\nexport let leftPadWithZeroBit = (binaryString: string, finalStringLength: number): string => {\n    if (binaryString.length > finalStringLength) {\n        throw new Error(`Given string is already longer than given final length after padding: ${finalStringLength}`);\n    }\n    return \"0\".repeat(finalStringLength - binaryString.length).concat(binaryString);\n};\n\n/**\n * Given the prefix portion of a cidr notation and the type of IP number, returns the subnet mask in binary string\n *\n * @param {number} cidrPrefix the prefix part of a cidr notation\n * @param {IPNumType.IPv4 | IPNumType.IPv6} ipType the type of the ip number in the range the cidr represents\n */\nexport let cidrPrefixToSubnetMaskBinaryString = (cidrPrefix: number, ipType: IPNumType.IPv4 | IPNumType.IPv6): string => {\n  let cidrUpperValue;\n  if (ipType == IPNumType.IPv4) {\n    cidrUpperValue = 32;\n  } else {\n    cidrUpperValue = 128\n  }\n  if (cidrPrefix > cidrUpperValue) throw Error(`Value is greater than ${cidrUpperValue}`);\n\n  let onBits = '1'.repeat(cidrPrefix);\n  let offBits = '0'.repeat(cidrUpperValue - cidrPrefix);\n  return `${onBits}${offBits}`;\n};\n","var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        LOG_MAX_INT = Math.log(MAX_INT);\r\n\r\n    function Integer(v, radix) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 ? parseValue(v) : parseBase(v, radix);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a,b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n            if (isPrecise(a.value * this.value)) {\r\n                return new SmallInteger(a.value * this.value);\r\n            }\r\n            return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n            if (a.value === 0) return Integer[0];\r\n            if (a.value === 1) return this;\r\n            if (a.value === -1) return this.negate();\r\n            return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    function square(a) {\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < l; j++) {\r\n                a_j = a[j];\r\n                product = a_i * a_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        var value = n.value;\r\n        if (value === 0) return false;\r\n        if (value === 1) return true;\r\n        if (value === 2) return this.isEven();\r\n        return this.mod(n).equals(Integer[0]);\r\n    };\r\n    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(25)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    BigInteger.prototype.isPrime = function () {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs(),\r\n            nPrev = n.prev();\r\n        var a = [2, 3, 5, 7, 11, 13, 17, 19],\r\n            b = nPrev,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2);\r\n        for (i = 0; i < a.length; i++) {\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;\r\n            for (t = true, d = b; t && d.lesser(nPrev) ; d = d.multiply(2)) {\r\n                x = x.square().mod(n);\r\n                if (x.equals(nPrev)) t = false;\r\n            }\r\n            if (t) return false;\r\n        }\r\n        return true;\r\n    };\r\n    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        // use the Fermat primality test\r\n        for (var i = 0; i < t; i++) {\r\n            var a = bigInt.randBetween(2, n.minus(2));\r\n            if (!a.modPow(n.prev(), n).isUnit()) return false; // definitely composite\r\n        }\r\n        return true; // large chance of being prime\r\n    };\r\n    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.equals(bigInt.zero)) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.equals(1)) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return ((typeof n === \"number\" || typeof n === \"string\") && +Math.abs(n) <= BASE) ||\r\n            (n instanceof BigInteger && n.value.length <= 1);\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (n) {\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (n) {\r\n        var remQuo;\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero()) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value, x = typeof v === \"number\" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = Math.min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(Math.random() * range));\r\n        var length = range.value.length - 1;\r\n        var result = [], restricted = true;\r\n        for (var i = length; i >= 0; i--) {\r\n            var top = restricted ? range.value[i] : BASE;\r\n            var digit = truncate(Math.random() * top);\r\n            result.unshift(digit);\r\n            if (digit < top) restricted = false;\r\n        }\r\n        result = arrayToSmall(result);\r\n        return low.add(typeof result === \"number\" ? new SmallInteger(result) : new BigInteger(result, false));\r\n    }\r\n    var parseBase = function (text, base) {\r\n        var length = text.length;\r\n\t\tvar i;\r\n\t\tvar absBase = Math.abs(base);\r\n\t\tfor(var i = 0; i < length; i++) {\r\n\t\t\tvar c = text[i].toLowerCase();\r\n\t\t\tif(c === \"-\") continue;\r\n\t\t\tif(/[a-z0-9]/.test(c)) {\r\n\t\t\t    if(/[0-9]/.test(c) && +c >= absBase) {\r\n\t\t\t\t\tif(c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n\t\t\t\t} else if(c.charCodeAt(0) - 87 >= absBase) {\r\n\t\t\t\t\tthrow new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n        if (2 <= base && base <= 36) {\r\n            if (length <= LOG_MAX_INT / Math.log(base)) {\r\n\t\t\t\tvar result = parseInt(text, base);\r\n\t\t\t\tif(isNaN(result)) {\r\n\t\t\t\t\tthrow new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n\t\t\t\t}\r\n                return new SmallInteger(parseInt(text, base));\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i].toLowerCase(),\r\n                charCode = c.charCodeAt(0);\r\n            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));\r\n            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\");\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit) {\r\n        if (digit <= 35) {\r\n            return \"0123456789abcdefghijklmnopqrstuvwxyz\".charAt(digit);\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return {value: [0], isNegative: false};\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return {value: [0], isNegative: false};\r\n            if (n.isNegative())\r\n              return {\r\n                value: [].concat.apply([], Array.apply(null, Array(-n))\r\n                            .map(Array.prototype.valueOf, [1, 0])\r\n                          ),\r\n                isNegative: false\r\n              };\r\n\r\n            var arr = Array.apply(null, Array(+n - 1))\r\n              .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n              value: [].concat.apply([], arr),\r\n              isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.equals(1)) {\r\n            if (n.isZero()) return {value: [0], isNegative: false};\r\n            \r\n            return {\r\n              value: Array.apply(null, Array(+n))\r\n                       .map(Number.prototype.valueOf, 1),\r\n              isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return {value: out.reverse(), isNegative: neg};\r\n    }\r\n\r\n    function toBaseString(n, base) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(stringify).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n      return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n      return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix);\r\n        return String(this.value);\r\n    };\r\n    BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n\r\n    function parseStringValue(v) {\r\n            if (isPrecise(+v)) {\r\n                var x = +v;\r\n                if (x === truncate(x))\r\n                    return new SmallInteger(x);\r\n                throw \"Invalid integer: \" + v;\r\n            }\r\n            var sign = v[0] === \"-\";\r\n            if (sign) v = v.slice(1);\r\n            var split = v.split(/e/i);\r\n            if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n            if (split.length === 2) {\r\n                var exp = split[1];\r\n                if (exp[0] === \"+\") exp = exp.slice(1);\r\n                exp = +exp;\r\n                if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n                var text = split[0];\r\n                var decimalPlace = text.indexOf(\".\");\r\n                if (decimalPlace >= 0) {\r\n                    exp -= text.length - decimalPlace - 1;\r\n                    text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n                }\r\n                if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n                text += (new Array(exp + 1)).join(\"0\");\r\n                v = text;\r\n            }\r\n            var isValid = /^([0-9][0-9]*)$/.test(v);\r\n            if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n            var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n            while (max > 0) {\r\n                r.push(+v.slice(min, max));\r\n                min -= l;\r\n                if (min < 0) min = 0;\r\n                max -= l;\r\n            }\r\n            trim(r);\r\n            return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = new SmallInteger(i);\r\n        if (i > 0) Integer[-i] = new SmallInteger(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif ( typeof define === \"function\" && define.amd ) {\r\n  define( \"big-integer\", [], function() {\r\n    return bigInt;\r\n  });\r\n}\r\n","'use strict';\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport {cidrPrefixToSubnetMaskBinaryString} from \"./BinaryUtils\";\nimport * as bigInt from \"big-integer\";\nimport {IPNumType} from \"./IPNumType\";\nimport {expandIPv6Number} from \"./IPv6Utils\";\nimport {colonHexadecimalNotationToBinaryString} from \"./HexadecimalUtils\";\nimport {hexadectetNotationToBinaryString} from \"./HexadecimalUtils\";\n\nexport class Validator {\n    static IPV4_PATTERN: RegExp = new RegExp(/^(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/);\n    static IPV4_RANGE_PATTERN: RegExp = new RegExp(/^(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\/)([1-9]|[1-2][0-9]|3[0-2])$/);\n    static IPV6_RANGE_PATTERN: RegExp = new RegExp(/^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8]))?$/);\n    static IPV4_SUBNET_MASK_BIT_PATTERN: RegExp = new RegExp(/^(1){0,32}(0){0,32}$/);\n    static IPV6_SUBNET_MASK_BIT_PATTERN: RegExp = new RegExp(/^(1){0,128}(0){0,128}$/);\n\n    static EIGHT_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(8), 2);\n    static SIXTEEN_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(16), 2);\n    static THIRTY_TWO_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(32), 2);\n    static ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(128), 2);\n\n    static invalidAsnRangeMessage = \"ASN number given less than zero or is greater than 32bit\";\n    static invalid16BitAsnRangeMessage = \"ASN number given less than zero or is greater than 16bit\";\n    static invalidIPv4NumberMessage = \"IPv4 number given less than zero or is greater than 32bit\";\n    static invalidIPv6NumberMessage = \"IPv6 number given less than zero or is greater than 128bit\";\n    static invalidOctetRangeMessage = \"Value given contains an invalid Octet; Value is less than zero or is greater than 8bit\";\n    static invalidHexadecatetMessage = \"The value given is less than zero or is greater than 16bit\";\n    static invalidOctetCountMessage = \"An IP4 number cannot have less or greater than 4 octets\";\n    static invalidHexadecatetCountMessage = \"An IP6 number must have exactly 8 hexadecatet\";\n    static invalidSubnetMaskMessage = \"The Subnet Mask is invalid\";\n    static invalidPrefixValueMessage = \"A Prefix value cannot be less than 0 or greater than 32\";\n    static invalidIPv4CidrNotationMessage = \"Cidr notation should be in the form [ip number]/[range]\";\n    static InvalidIPCidrRangeMessage = \"Given IP number portion must is not the start of the range\";\n    static invalidRangeNotationMessage = \"Range notation should be in the form [first ip]-[last ip]\";\n    static invalidRangeFirstNotGreaterThanLastMessage = \"First IP in [first ip]-[last ip] must be less than Last IP\";\n    static invalidIPv6CidrNotationString = \"A Cidr notation string should contain an IPv6 number and prefix\";\n    static takeOutOfRangeSizeMessage = \"$count is greater than $size, the size of the range\";\n    static cannotSplitSingleRangeErrorMessage = \"Cannot split an IP range with a single IP number\";\n    static invalidInetNumType = \"Given ipNumType must be either InetNumType.IPv4 or InetNumType.IPv6\";\n    static invalidBinaryStringErrorMessage = \"Binary string should contain only contiguous 1s and 0s\";\n\n    /**\n     * Checks if given ipNumber is in between the given lower and upper bound\n     *\n     * @param ipNumber ipNumber to check\n     * @param lowerBound lower bound\n     * @param upperBound upper bound\n     * @returns {boolean} true if ipNumber is between lower and upper bound\n     */\n    private static isWithinRange(ipNumber: bigInt.BigInteger, lowerBound: bigInt.BigInteger, upperBound: bigInt.BigInteger) : boolean {\n        return ipNumber.greaterOrEquals(lowerBound) && ipNumber.lesserOrEquals(upperBound);\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an ASN number\n     *\n     * @param asnNumber the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid ASN, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidAsnNumber(asnNumber: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = this.isWithinRange(asnNumber, bigInt.zero, this.THIRTY_TWO_BIT_SIZE);\n        return [isValid, isValid ? []: [Validator.invalidAsnRangeMessage]];\n    }\n\n    /**\n     * Checks if the given ASN number is a 16bit ASN number\n     *\n     * @param {bigInt.BigInteger} asnNumber to check if 16bit or not\n     * @returns {[boolean , string]} first value is true if valid 16bit ASN, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValid16BitAsnNumber(asnNumber: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = Validator.isWithinRange(asnNumber, bigInt.zero, Validator.SIXTEEN_BIT_SIZE);\n        return [isValid, isValid ? []: [Validator.invalid16BitAsnRangeMessage]];\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an IPv4 number\n     *\n     * @param ipv4Number the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid IPv4 number, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4Number(ipv4Number: bigInt.BigInteger): [boolean, string[]]  {\n        let isValid = this.isWithinRange(ipv4Number, bigInt.zero, this.THIRTY_TWO_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv4NumberMessage]];\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an IPv6 number\n     *\n     * @param ipv6Number the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid IPv6 number, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6Number(ipv6Number: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = this.isWithinRange(ipv6Number, bigInt.zero, this.ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv6NumberMessage]];\n    }\n\n    /**\n     * Checks if the number given is valid for an IPv4 octet\n     *\n     * @param octetNumber the octet value\n     * @returns {boolean} true if valid octet, false otherwise\n     */\n    static isValidIPv4Octet(octetNumber: bigInt.BigInteger): [boolean, string[]] {\n        let withinRange = this.isWithinRange(octetNumber, bigInt.zero, this.EIGHT_BIT_SIZE);\n        return [withinRange, withinRange ? []: [Validator.invalidOctetRangeMessage]];\n    }\n\n    /**\n     * Checks if the number given is valid for an IPv6 hexadecatet\n     *\n     * @param {bigInt.BigInteger} hexadecatetNum the hexadecatet value\n     * @returns {[boolean , string]} first value is true if valid hexadecatet, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6Hexadecatet(hexadecatetNum: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = this.isWithinRange(hexadecatetNum, bigInt.zero, this.SIXTEEN_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidHexadecatetMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv4 value.\n     *\n     * @param {string} ipv4String the IPv4 string to validate\n     * @returns {[boolean , string]} result of validation, first value represents if is valid IPv4, second value\n     * contains error message if invalid IPv4\n     */\n    static isValidIPv4String(ipv4String: string): [boolean, string[]] {\n        let rawOctets = ipv4String.split(\".\");\n\n        if (rawOctets.length != 4 || rawOctets.includes('')) {\n            return [false, [Validator.invalidOctetCountMessage]];\n        }\n\n        let isValid = rawOctets.every(octet => {\n            return Validator.isNumeric(octet) ? Validator.isValidIPv4Octet(bigInt(octet))[0] : false;\n        });\n\n        return [isValid, isValid ? []: [Validator.invalidOctetRangeMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv6 value.\n     *\n     * @param {string} ipv6String the IPv6 string to validate\n     * @returns {[boolean , string]} result of validation, first value represents if is valid IPv6, second value\n     * contains error message if invalid IPv6\n     */\n    static isValidIPv6String(ipv6String: string): [boolean, string[]] {\n        try {\n            let hexadecimals = expandIPv6Number(ipv6String).split(\":\");\n            if (hexadecimals.length != 8 ) {\n                return [false, [Validator.invalidHexadecatetCountMessage]]\n            }\n\n            let isValid = hexadecimals.every(hexadecimal => {\n                return Validator.isHexadecatet(hexadecimal) ?\n                    Validator.isValidIPv6Hexadecatet(bigInt(parseInt(hexadecimal, 16)))[0] : false;\n            });\n\n            return [isValid, isValid? []: [Validator.invalidHexadecatetMessage]];\n        } catch (error) {\n            return [false, [error]]\n        }\n    }\n\n    /**\n     * Checks if given value is a valid prefix value\n     *\n     * @param prefixValue value to check\n     * @param ipNumType The type of IP number\n     * @returns {(boolean|string)[]} a tuple representing if valid or not and corresponding message\n     */\n    static isValidPrefixValue(prefixValue: number, ipNumType: IPNumType): [boolean, string[]] {\n        if (IPNumType.IPv4 === ipNumType) {\n            let withinRange = Validator.isWithinRange(bigInt(prefixValue), bigInt.zero, bigInt(32));\n            return [withinRange, withinRange ? []: [Validator.invalidPrefixValueMessage]];\n        }\n        if (IPNumType.IPv6 === ipNumType) {\n            let withinRange = Validator.isWithinRange(bigInt(prefixValue), bigInt.zero, bigInt(128));\n            return [withinRange, withinRange ? []: [Validator.invalidPrefixValueMessage]];\n        }\n        return [false, [Validator.invalidInetNumType]]\n    }\n\n    /**\n     * Checks if given string is a valid IPv4 subnet mask\n     *\n     * @param {string} ipv4SubnetMaskString the given IPv4 subnet mask string\n     * @returns {[boolean , string]} first value is true if valid IPv4 subnet mask string, false otherwise. Second value\n     * contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4SubnetMask(ipv4SubnetMaskString: string) : [boolean, string[]] {\n        let ipv4InBinary = dottedDecimalNotationToBinaryString(ipv4SubnetMaskString);\n        let isValid = Validator.IPV4_SUBNET_MASK_BIT_PATTERN.test(ipv4InBinary);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidSubnetMaskMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv6 subnet mask\n     *\n     * @param {string} ipv6SubnetMaskString the given IPv6 subnet mask string\n     * @returns {[boolean , string]} first value is true if valid IPv6 subnet mask string, false otherwise. Second value\n     * contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6SubnetMask(ipv6SubnetMaskString: string) : [boolean, string[]] {\n        let ipv6InBinary = hexadectetNotationToBinaryString(ipv6SubnetMaskString);\n        let isValid = Validator.IPV6_SUBNET_MASK_BIT_PATTERN.test(ipv6InBinary);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidSubnetMaskMessage]];\n    }\n\n    /**\n     * Checks if the given string is a valid IPv4 range in Cidr notation\n     *\n     * @param {string} ipv4RangeAsCidrString the IPv4 range in Cidr notation\n     *\n     * @returns {[boolean , string[]]} first value is true if valid IPv4 range in Cidr notation, false otherwise. Second\n     * value contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4CidrNotation(ipv4RangeAsCidrString: string): [boolean, string[]] {\n        let cidrComponents = ipv4RangeAsCidrString.split(\"/\");\n        if(cidrComponents.length !== 2 || (cidrComponents[0].length === 0 || cidrComponents[1].length === 0)) {\n            return [false, [Validator.invalidIPv4CidrNotationMessage]];\n        }\n\n        let ip = cidrComponents[0];\n        let range = cidrComponents[1];\n\n        if (isNaN(Number(range))) {\n            return [false, [Validator.invalidIPv4CidrNotationMessage]];\n        }\n\n        let [validIpv4, invalidIpv4Message] = Validator.isValidIPv4String(ip);\n        let [validPrefix, invalidPrefixMessage] = Validator.isValidPrefixValue(Number(range), IPNumType.IPv4);\n\n        let isValid = validIpv4 && validPrefix;\n        let invalidMessage = invalidIpv4Message.concat(invalidPrefixMessage);\n\n        return isValid ? [isValid, []]: [isValid, invalidMessage];\n    }\n\n  /**\n   *  Checks if the given string is a valid IPv4 range in Cidr notation, with the ip number in the cidr notation\n   *  being the start of the range\n   *\n   * @param {string}  ipv4CidrNotation the IPv4 range in Cidr notation\n   *\n   * * @returns {[boolean , string[]]} first value is true if valid Cidr notation, false otherwise. Second\n   * value contains [] or an array of error message when invalid\n   */\n  static isValidIPv4CidrRange(ipv4CidrNotation: string): [boolean, string[]] {\n      return Validator.isValidCidrRange(ipv4CidrNotation, Validator.isValidIPv4CidrNotation, dottedDecimalNotationToBinaryString, (value: number) => cidrPrefixToSubnetMaskBinaryString(value, IPNumType.IPv4));\n    }\n\n  /**\n   *  Checks if the given string is a valid IPv6 range in Cidr notation, with the ip number in the cidr notation\n   *  being the start of the range\n   *\n   * @param {string}  ipv6CidrNotation the IPv6 range in Cidr notation\n   *\n   * * @returns {[boolean , string[]]} first value is true if valid Cidr notation, false otherwise. Second\n   * value contains [] or an array of error message when invalid\n   */\n    static isValidIPv6CidrRange(ipv6CidrNotation: string): [boolean, string[]] {\n      return Validator.isValidCidrRange(ipv6CidrNotation, Validator.isValidIPv6CidrNotation, colonHexadecimalNotationToBinaryString, (value: number) => cidrPrefixToSubnetMaskBinaryString(value, IPNumType.IPv6));\n    }\n\n\n    private static isValidCidrRange(rangeString: string,\n                                    cidrNotationValidator: (range:string) => [boolean, string[]],\n                                    toBinaryStringConverter: (range: string) => string,\n                                    prefixFactory: (num:number) => string): [boolean, string[]] {\n      let validationResult = cidrNotationValidator(rangeString);\n\n      if (!validationResult[0]) {\n        return validationResult\n      }\n\n      let cidrComponents = rangeString.split(\"/\");\n      let ip = cidrComponents[0];\n      let range = cidrComponents[1];\n      let ipNumber = bigInt(toBinaryStringConverter(ip), 2);\n      let subnetMask = bigInt(prefixFactory(parseInt(range)), 2);\n      let isValid = ipNumber.and(subnetMask).equals(ipNumber);\n\n      return isValid ? [isValid, []]: [isValid, [Validator.InvalidIPCidrRangeMessage]];\n    }\n\n    static isValidIPv4RangeString(ipv4RangeString: string): [boolean, string[]] {\n        let firstLastValidator = (firstIP: string, lastIP: string) => bigInt(dottedDecimalNotationToBinaryString(firstIP))\n            .greaterOrEquals(dottedDecimalNotationToBinaryString(lastIP));\n\n        return this.isValidRange(ipv4RangeString, Validator.isValidIPv4String, firstLastValidator);\n    }\n\n    static isValidIPv6RangeString(ipv6RangeString: string): [boolean, string[]] {\n        let firstLastValidator = (firstIP: string, lastIP: string) => bigInt(hexadectetNotationToBinaryString(firstIP))\n            .greaterOrEquals(hexadectetNotationToBinaryString(lastIP));\n        return this.isValidRange(ipv6RangeString, Validator.isValidIPv6String, firstLastValidator);\n    }\n\n    private static isValidRange(rangeString: string,\n                                validator: (x:string) => [boolean, string[]],\n                                firstLastValidator: (first:string, last:string) => boolean):[boolean, string[]] {\n        let rangeComponents = rangeString.split(\"-\").map(component => component.trim());\n        if(rangeComponents.length !== 2 || (rangeComponents[0].length === 0 || rangeComponents[1].length === 0)) {\n            return [false, [Validator.invalidRangeNotationMessage]];\n        }\n        let firstIP = rangeComponents[0];\n        let lastIP = rangeComponents[1];\n\n        let [validFirstIP, invalidFirstIPMessage] = validator(firstIP);\n        let [validLastIP, invalidLastIPMessage] = validator(lastIP);\n\n        let isValid = validFirstIP && validLastIP;\n\n        if (isValid && firstLastValidator(firstIP, lastIP)) {\n            return [false, [Validator.invalidRangeFirstNotGreaterThanLastMessage]]\n        }\n\n        let invalidMessage = invalidFirstIPMessage.concat(invalidLastIPMessage);\n\n        return isValid ? [isValid, []]: [isValid, invalidMessage];\n    }\n\n    /**\n     * Checks if the given string is a valid IPv6 range in Cidr notation\n     *\n     * @param {string} ipv6RangeAsCidrString the IPv6 range in Cidr notation\n     *\n     * @returns {[boolean , string]} first value is true if valid IPv6 range in Cidr notation, false otherwise.\n     * Second value contains \"valid\" or an error message when value is invalid\n     */\n    // TODO change to be like isValidIPv4CidrNotation where validation is done on the component of the cidr notation\n    // instead of a single regex check\n    static isValidIPv6CidrNotation(ipv6RangeAsCidrString: string): [boolean, string[]] {\n        let isValid = Validator.IPV6_RANGE_PATTERN.test(ipv6RangeAsCidrString);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv6CidrNotationString]];\n    }\n\n    /**\n     * Checks if the given string is a binary string. That is contains only contiguous 1s and 0s\n     *\n     * @param {string} binaryString the binary string\n     * @returns {(boolean|string)[]} a tuple representing if valid or not and corresponding message\n     */\n    static isValidBinaryString(binaryString: string): [boolean, string[]] {\n        if (/^([10])+$/.test(binaryString)) {\n            return [true, []]\n        } else {\n            return [false, [Validator.invalidBinaryStringErrorMessage]]\n        }\n    }\n\n    private static isNumeric(value: string): boolean {\n        return /^(\\d+)$/.test(value)\n    }\n\n    private static isHexadecatet(value: string): boolean {\n        return /^[0-9A-Fa-f]{4}$/.test(value)\n    }\n\n}\n\n","import * as bigInt from \"big-integer/BigInteger\";\nimport {expandIPv6Number} from \"./IPv6Utils\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\n\n/**\n * Converts a given BigInteger number to a hexadecimal string\n * @param num the BigInteger number\n * @returns {string} the hexadeciaml string\n */\nexport let bigIntegerNumberToHexadecimalString = (num: bigInt.BigInteger): string => {\n    return num.toString(16);\n};\n\n/**\n * Converts a number in hexadecimal (base 16) to binary string\n * @param {string} hexadecimalString the number in base 16\n * @returns {string} the number converted to base 2\n */\nexport let hexadecimalStringToBinaryString = (hexadecimalString: string) : string => {\n    let inDecimal = bigInt(hexadecimalString, 16);\n    return inDecimal.toString(2);\n};\n\n/**\n * Converts a number in hexadecimal (base 16) to binary hexadecatet string.\n * This means the bits in the output cannot be more than 16\n *\n * @param hexadecimalString {string} the number converted to binary hexadecatet string\n */\nexport let hexadecimalStringToHexadecatetString = (hexadecimalString: string): string => {\n  let binaryString = hexadecimalStringToBinaryString(hexadecimalString);\n\n  let length = binaryString.length;\n  if (length > 16) {\n    throw new Error(\"Given decimal in binary contains digits greater than an Hexadecatet\")\n  }\n  return leftPadWithZeroBit(binaryString, 16);\n};\n\n/**\n * Given an IPv6 number in hexadecimal notated string, e.g 2001:0db8:0000:0000:0000:0000:0000:0000 converts it to\n * binary string\n *\n * @param hexadecimalString IPv6 string\n * @returns {string} the binary value of the given ipv6 number in string\n */\nexport let colonHexadecimalNotationToBinaryString = (hexadecimalString: string): string => {\n  let expandedIPv6 = expandIPv6Number(hexadecimalString);\n  let stringHexadecimal = expandedIPv6.split(\":\");\n\n  return stringHexadecimal.reduce((binaryAsString, hexidecimal) => {\n    return binaryAsString.concat(hexadecimalStringToHexadecatetString(hexidecimal))\n  }, '');\n};\n\n\n/**\n * Converts number in binary string to hexadecimal string\n * @param {string} num in binary string\n * @returns {string} num in hexadecimal string\n */\nexport let binaryStringToHexadecimalString = (num: string): string => {\n    // first convert to binary string to decimal (big Integer)\n    let inDecimal = bigInt(num, 2);\n    return inDecimal.toString(16);\n};\n\n/**\n * Converts a given IPv6 number expressed in the hexadecimal string notation into a 16 bit binary number in string\n * @param {string} hexadectetString the IPv6 number\n * @returns {string} the IPv6 number converted to binary string\n */\nexport let hexadectetNotationToBinaryString = (hexadectetString: string): string => {\n  let expand = expandIPv6Number(hexadectetString);\n  let hexadecimals = expand.split(\":\");\n  return hexadecimals.reduce((hexadecimalAsString, hexavalue) => {\n    return hexadecimalAsString.concat(leftPadWithZeroBit(hexadecimalStringToBinaryString(hexavalue),16));\n  }, '');\n};","export enum IPNumType {\n    ASN,\n    IPv4,\n    IPv6\n}","import {IPNumber} from \"./interface/IPNumber\";\nimport {Hexadecatet} from \"./Hexadecatet\";\nimport {Validator} from \"./Validator\";\nimport {bigIntegerNumberToBinaryString} from \"./BinaryUtils\";\nimport {binaryStringToHexadecimalString} from \"./HexadecimalUtils\";\nimport {expandIPv6Number} from \"./IPv6Utils\";\nimport * as bigInt from \"big-integer/BigInteger\";\nimport {AbstractIPNum} from \"./AbstractIPNum\";\nimport {IPNumType} from \"./IPNumType\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {IPv4} from \"./IPv4\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {hexadectetNotationToBinaryString} from \"./HexadecimalUtils\";\n\n\n/**\n * Represents an IPv6 number. A 128 bit number that is used to uniquely identify a device that is part of a computer\n * network that uses the internet protocol for communication.\n *\n * @see https://en.wikipedia.org/wiki/IPv6\n * @see https://www.rfc-editor.org/info/rfc8200\n */\nexport class IPv6 extends AbstractIPNum implements IPNumber {\n    /**\n     * The decimal value represented by the IPv6 number in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the IPv6 number\n     */\n    readonly bitSize: number = 128;\n    /**\n     * The maximum bit size (i.e. binary value) of the IPv6 number in BigInteger\n     */\n    readonly maximumBitSize: bigInt.BigInteger = Validator.ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE;\n    /**\n     * The type of IP number. Value is one of the values of the {@link IPNumType} enum\n     * @type {IPNumType} the type of IP number\n     */\n    readonly type: IPNumType = IPNumType.IPv6;\n    /**\n     * An array of {@link Hexadecatet}'s\n     *\n     * @type {Array} the hexadecatet that makes up the IPv6 number\n     */\n    readonly hexadecatet: Array<Hexadecatet> = [];\n\n    /**\n     * The string character used to separate the individual hexadecatet when the IPv6 is rendered as strings\n     *\n     * @type {string} The string character used to separate the individual hexadecatet when rendered as strings\n     */\n    readonly separator: string = \":\";\n\n    /**\n     * A convenience method for creating an {@link IPv6} by providing the decimal value of the IP number in BigInteger\n     *\n     * @param {bigInt.BigInteger} bigIntValue the decimal value of the IP number in BigInteger\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromBigInteger(bigIntValue: bigInt.BigInteger): IPv6 {\n        return new IPv6(bigIntValue);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv6} by providing the IP number in hexadecatet notation. E.g\n     * \"2001:800:0:0:0:0:0:2002\"\n     *\n     * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more information on hexadecatet notation.\n     *\n     * @param {string} ipString the IP number in hexadecatet\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromHexadecimalString(ipString: string) : IPv6 {\n        return new IPv6(ipString);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv6} from binary string\n     *\n     * @param {string} ipBinaryString the binary string representing the IPv6 number to be created\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromBinaryString(ipBinaryString: string) : IPv6 {\n        let validationResult = Validator.isValidBinaryString(ipBinaryString);\n        if (validationResult[0]) {\n            let paddedBinaryString = leftPadWithZeroBit(ipBinaryString, 128);\n            return new IPv6(parseBinaryStringToBigInteger(paddedBinaryString));\n        } else {\n            throw Error(validationResult[1].join(','))\n        }\n    }\n\n    /**\n     * A convenience method for creating an IPv4-Compatible {@link IPv6} Address from an instance of {@link IPv4}\n     *\n     * @param {IPv4} ipv4 to create an IPv4-Compatible {@link IPv6} Address\n     * @returns {IPv6} the IPv4-Compatible {@link IPv6} Address\n     */\n    static fromIPv4(ipv4: IPv4): IPv6 {\n        return ipv4.toIPv4MappedIPv6();\n    }\n\n    /**\n     * A convenience method for creating an IPv4-Compatible {@link IPv6} Address from a IPv4 represented in\n     * dot-decimal notation i.e. 127.0.0.1\n     *\n     * @param {IPv4} ip4DotDecimalString string represented in a dot decimal string\n     * @returns {IPv6} the IPv4-Compatible {@link IPv6} Address\n     */\n    static fromIPv4DotDecimalString(ip4DotDecimalString: string): IPv6 {\n        return new IPv4(ip4DotDecimalString).toIPv4MappedIPv6();\n    }\n\n    /**\n     * Constructor for an IPv6 number.\n     *\n     * @param {string | bigInt.BigInteger} ipValue value to construct an IPv6 from. The given value can either be\n     * numeric or string. If a string is given then it needs to be in hexadecatet string notation\n     */\n    constructor(ipValue: string | bigInt.BigInteger) {\n        super();\n        if (typeof ipValue === \"string\" ) {\n            let expandedIPv6 = expandIPv6Number(ipValue);\n            let [value, hexadecatet] = this.constructFromHexadecimalDottedString(expandedIPv6);\n            this.value = value;\n            this.hexadecatet = hexadecatet;\n\n        } else {\n            let [value, hexadecatet] = this.constructFromBigIntegerValue(ipValue);\n            this.value = value;\n            this.hexadecatet = hexadecatet;\n        }\n    }\n\n    /**\n     * A string representation of the IPv6 number.\n     *\n     * @returns {string} The string representation of IPv6\n     */\n    public toString(): string {\n        let ipv6String = this.hexadecatet.map((value) => { return value.toString()}).join(\":\");\n        if (this.hexadecatet.length < 8) {\n            return \"::\" + ipv6String;\n        } else {\n            return ipv6String\n        }\n    }\n\n    /**\n     * Gets the individual {@link Hexadecatet} that makes up the IPv6 number\n     *\n     * @returns {Array<Hexadecatet>} The individual {@link Hexadecatet} that makes up the IPv6 number\n     */\n    //TODO maybe rename to something like getSegments? so it can be same with getOctet\n    public getHexadecatet():Array<Hexadecatet> {\n        return this.hexadecatet;\n    }\n\n    /**\n     * Returns the next IPv6 number\n     *\n     * @returns {IPv6} the next IPv6 number\n     */\n    public nextIPNumber(): IPv6 {\n        return IPv6.fromBigInteger(this.getValue().add(1))\n    }\n\n    /**\n     * Returns the previous IPv6 number\n     *\n     * @returns {IPv6} the previous IPv6 number\n     */\n    public previousIPNumber(): IPv6 {\n        return IPv6.fromBigInteger(this.getValue().minus(1))\n    }\n\n    private constructFromBigIntegerValue(ipv6Number: bigInt.BigInteger): [bigInt.BigInteger, Array<Hexadecatet>]  {\n        let [isValid, message] = Validator.isValidIPv6Number(ipv6Number);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let binaryString = bigIntegerNumberToBinaryString(ipv6Number);\n        return [ipv6Number, this.binaryStringToHexadecatets(binaryString)]\n    }\n\n    private constructFromHexadecimalDottedString(expandedIPv6: string): [bigInt.BigInteger, Array<Hexadecatet>] {\n        let [isValid, message] = Validator.isValidIPv6String(expandedIPv6);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringHexadecimals: string[] = expandedIPv6.split(\":\");\n        let hexadecatet: Hexadecatet[]  = stringHexadecimals.map((stringHexadecatet) => {\n            return Hexadecatet.fromString(stringHexadecatet);\n        });\n        let value = bigInt(hexadectetNotationToBinaryString(expandedIPv6), 2);\n        return [value, hexadecatet];\n    }\n\n    private binaryStringToHexadecatets(binaryString: string): Hexadecatet[] {\n        let hexadecimalString = binaryStringToHexadecimalString(binaryString);\n        let hexadecimalStrings: string[] = hexadecimalString.match(/.{1,4}/g)!;\n        return hexadecimalStrings.map((stringHexadecatet)=> {\n            return Hexadecatet.fromString(stringHexadecatet);\n        });\n    }\n}","import {Octet} from \"./Octet\";\nimport {Validator} from \"./Validator\";\nimport {IPNumber} from \"./interface/IPNumber\";\nimport * as bigInt from \"big-integer\"\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport {bigIntegerNumberToBinaryString} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {AbstractIPNum} from \"./AbstractIPNum\";\nimport {IPNumType} from \"./IPNumType\";\nimport {IPv6} from \"./IPv6\";\n\n/**\n * Represents an IPv4 number. A 32 bit number that is used to uniquely identify a device that is part of a computer\n * network that uses the internet protocol for communication.\n *\n * @see https://en.wikipedia.org/wiki/IPv4\n * @see https://www.rfc-editor.org/info/rfc791\n */\nexport class IPv4 extends AbstractIPNum implements IPNumber {\n    /**\n     * The decimal value represented by the IPv4 number in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the IPv4 number\n     */\n    readonly bitSize: number = 32;\n    /**\n     * The maximum bit size (i.e. binary value) of the IPv4 number in BigInteger\n     */\n    readonly maximumBitSize: bigInt.BigInteger = Validator.THIRTY_TWO_BIT_SIZE;\n    /**\n     * The type of IP number. Value is one of the values of the {@link IPNumType} enum\n     * @type {IPNumType} the type of IP number\n     */\n    readonly type: IPNumType = IPNumType.IPv4;\n    /**\n     * An array of {@link Octet}'s\n     *\n     * @type {Array} the octets that makes up the IPv4 number\n     */\n    readonly octets: Array<Octet> = [];\n\n    /**\n     * The string character used to separate the individual octets when the IPv4 is rendered as strings\n     *\n     * @type {string} The string character used to separate the individual octets when rendered as strings\n     */\n    readonly separator: string = \".\";\n\n    /**\n     * A convenience method for creating an {@link IPv4} by providing the decimal value of the IP number in BigInteger\n     *\n     * @param {bigInt.BigInteger} bigIntValue the decimal value of the IP number in BigInteger\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromBigInteger(bigIntValue: bigInt.BigInteger): IPv4 {\n        return new IPv4(bigIntValue);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv4} by providing the IP number in dot-decimal notation. E.g\n     * \"10.1.1.10\"\n     *\n     * {@see https://en.wikipedia.org/wiki/Dot-decimal_notation} for more information on dot-decimal notation.\n     *\n     * @param {string} ipString the IP number in dot-decimal notation\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromDecimalDottedString(ipString: string) : IPv4 {\n        return new IPv4(ipString);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv4} from binary string\n     *\n     * @param {string} ipBinaryString the binary string representing the IPv4 number to be created\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromBinaryString(ipBinaryString: string) : IPv4 {\n        let validationResult = Validator.isValidBinaryString(ipBinaryString);\n        if (validationResult[0]) {\n            return new IPv4(parseBinaryStringToBigInteger(ipBinaryString));\n        } else {\n            throw Error(validationResult[1].join(','))\n        }\n    }\n\n    /**\n     * Constructor for an IPv4 number.\n     *\n     * @param {string | bigInt.BigInteger} ipValue value to construct an IPv4 from. The given value can either be\n     * numeric or string. If a string is given then it needs to be in dot-decimal notation\n     */\n    constructor(ipValue: string | bigInt.BigInteger) {\n        super();\n        if (typeof ipValue === \"string\" ) {\n            let [value, octets] = this.constructFromDecimalDottedString(ipValue);\n            this.value = value;\n            this.octets = octets\n        } else {\n            let [value, octets] = this.constructFromBigIntegerValue(ipValue);\n            this.value = value;\n            this.octets = octets;\n        }\n    }\n\n    /**\n     * A string representation of the IPv4 number. The string representation is in dot-decimal notation\n     *\n     * @returns {string} The string representation in dot-decimal notation\n     */\n    public toString(): string {\n        return this.octets.map((value) => { return value.toString()}).join(this.separator);\n    }\n\n    /**\n     * Gets the individual {@link Octet} that makes up the IPv4 number\n     *\n     * @returns {Array<Octet>} The individual {@link Octet} that makes up the IPv4 number\n     */\n    public getOctets(): Array<Octet> {\n        return this.octets;\n    }\n\n    /**\n     * Returns the next IPv4 number\n     *\n     * @returns {IPv4} the next IPv4 number\n     */\n    public nextIPNumber(): IPv4 {\n        return IPv4.fromBigInteger(this.getValue().add(1))\n    }\n\n    /**\n     * Returns the previous IPv4 number\n     *\n     * @returns {IPv4} the previous IPv4 number\n     */\n    public previousIPNumber(): IPv4 {\n        return IPv4.fromBigInteger(this.getValue().minus(1))\n    }\n\n    /**\n     * Returns this IPv4 number as a IPv4-Mapped IPv6 Address\n     *\n     * The IPv4-Mapped IPv6 Address allows an IPv4 number to be embedded within an IPv6 number\n     *\n     * {@see https://tools.ietf.org/html/rfc4291#section-2.5.5} for more information on the IPv4-Mapped IPv6 Address\n     *\n     * @returns {IPv6} an IPv6 number with the IPv4 embedded within it\n     */\n    public toIPv4MappedIPv6(): IPv6 {\n        let binary = '1'.repeat(16) + this.toBinaryString();\n        return IPv6.fromBinaryString(binary);\n    }\n\n\n    private constructFromDecimalDottedString(ipString: string): [bigInt.BigInteger, Array<Octet>] {\n        let octets;\n        let value;\n        let [isValid, message] = Validator.isValidIPv4String(ipString);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let stringOctets = ipString.split(\".\");\n        octets = stringOctets.map((rawOctet) => {\n            return Octet.fromString(rawOctet)\n        });\n        value = bigInt(dottedDecimalNotationToBinaryString(ipString), 2);\n        return [value, octets]\n    }\n\n    private constructFromBigIntegerValue(ipv4Number: bigInt.BigInteger): [bigInt.BigInteger, Array<Octet>]  {\n        let [isValid, message] = Validator.isValidIPv4Number(ipv4Number);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let binaryString = bigIntegerNumberToBinaryString(ipv4Number);\n        return [ipv4Number, this.binaryStringToDecimalOctets(binaryString)]\n    }\n\n    private binaryStringToDecimalOctets(ipv4BinaryString: string): Array<Octet> {\n        if (ipv4BinaryString.length < 32) {\n            ipv4BinaryString = leftPadWithZeroBit(ipv4BinaryString, 32);\n        }\n        let octets: string[] = ipv4BinaryString.match(/.{1,8}/g)!;\n        return octets.map((octet) => {\n            return Octet.fromString(parseBinaryStringToBigInteger(octet).toString())\n        });\n    }\n}","import {Validator} from \"./Validator\";\nimport * as bigInt from \"big-integer\"\n\n/**\n * A base 16 (hexadecimal) representation of a 16 bit value.\n *\n * It consists of four (base 16) number.\n *\n * It is used to represents the components of an IPv6 address\n */\nexport class Hexadecatet {\n    private readonly value: number;\n\n    /**\n     * A convenience method for constructing an instance of {@link Hexadecatet} from a four (base 16) number\n     * representation of a 16bit value.\n     *\n     * @param {string} rawValue the four (base 16) number\n     * @returns {Hexadecatet} an instance of {@link Hexadecatet}\n     */\n    static fromString(rawValue:string):Hexadecatet {\n        return new Hexadecatet(rawValue);\n    };\n\n    /**\n     * A convenience method for constructing an instance of {@link Hexadecatet} from a decimal number representation\n     * of a 16 bit value\n     *\n     * @param {number} rawValue decimal number representation of a 16 bit value\n     * @returns {Hexadecatet} an instance of {@link Hexadecatet}\n     */\n    static fromNumber(rawValue:number):Hexadecatet {\n        return new Hexadecatet(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of {@link Hexadecatet}\n     *\n     * @param {string | number} givenValue a string or numeric value. If given value is a string then it should be a\n     * four (base 16) number representation of a 16bit value. If it is a number, then it should be a decimal number\n     * representation of a 16 bit value\n     */\n    constructor(givenValue: string | number) {\n        let hexadecatetValue: number;\n        if (typeof givenValue === 'string') {\n            hexadecatetValue = parseInt(givenValue, 16);\n        } else {\n            hexadecatetValue = parseInt(String(givenValue), 16);\n        }\n\n        let [isValid, message] = Validator.isValidIPv6Hexadecatet(bigInt(hexadecatetValue));\n\n        if (!isValid) {\n            throw Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = hexadecatetValue;\n    }\n\n    /**\n     * Returns the numeric value in base 10 (ie decimal)\n     *\n     * @returns {number} the numeric value in base 10 (ie decimal)\n     */\n    public getValue():number {\n        return this.value;\n    }\n\n    /**\n     * Returns the string representation of the base 16 representation of the value\n     * @returns {string} the string representation of the base 16 representation of the value\n     */\n    // TODO pad with a zero if digit is less than 4\n    public toString(): string {\n        return this.value.toString(16);\n    }\n}","import {leftPadWithZeroBit} from \"./BinaryUtils\";\n\n/**\n * Expands an IPv6 number in abbreviated format into its full form\n *\n * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more on the representation of IPv6 addresses\n *\n * @param {string} ipv6String the abbreviated IPv6 address to expand\n * @returns {string} the expanded IPv6 address\n */\nexport let expandIPv6Number = (ipv6String:string):string => {\n    let expandWithZero = (hexadecimalArray: string[]): string => {\n        let paddedArray = hexadecimalArray.map((hexadecimal) => {\n            return leftPadWithZeroBit(hexadecimal, 4);\n        });\n\n        return paddedArray.join(\":\")\n    };\n\n    let expandDoubleColon = (gapCount: number): string => {\n        let pads = [];\n        for (let count=0; count<gapCount; count++) {\n            pads.push(\"0000\");\n        }\n        return pads.join(\":\");\n    };\n\n    if (/(:){3,}/.test(ipv6String)) throw \"given IPv6 contains consecutive : more than two\";\n\n    if (ipv6String.includes(\"::\")) {\n        let split = ipv6String.split(\"::\");\n        let leftPortion = split[0];\n        let rightPortion = split[1];\n\n        let leftPortionSplit = leftPortion.split(\":\").filter(hexadecimal => {return hexadecimal !== \"\"});\n        let rightPortionSplit = rightPortion.split(\":\").filter(hexadecimal => {return hexadecimal !== \"\"});\n        let doublePortion = expandDoubleColon(8 - (leftPortionSplit.length + rightPortionSplit.length));\n\n\n        let leftString = expandWithZero(leftPortionSplit);\n        if (leftString !== \"\") {\n            leftString += \":\";\n        }\n\n\n        let rightString = expandWithZero(rightPortionSplit);\n        if (rightString !== \"\") {\n            rightString = \":\"+rightString;\n        }\n\n        return `${leftString}${doublePortion}${rightString}`;\n\n    } else {\n        return expandWithZero(ipv6String.split(\":\"));\n    }\n};\n\n\n/**\n * Collapses an IPv6 number in full format into its abbreviated form\n *\n * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more on the representation of IPv6 addresses\n *\n * @param {string} ipv6String the full form IPv6 number to collapse\n * @returns {string} the collapsed IPv6 number\n */\nexport let collapseIPv6Number = (ipv6String:string):string => {\n    let hexadecimals: string[] = ipv6String.split(\":\");\n    let hexadecimalsWithoutLeadingZeros = hexadecimals.map((hexidecimal) => {\n       let withoutLeadingZero = hexidecimal.replace(/^0+/, '');\n       if (withoutLeadingZero !== '') {\n           return withoutLeadingZero;\n       } else {\n           return \"0\";\n       }\n\n    });\n    let contracted = hexadecimalsWithoutLeadingZeros.join(\":\").replace(/(^0)?(:0){2,}/, ':');\n    if (contracted.slice(-1) === \":\") {\n        return `${contracted}:`;\n    }\n    return contracted;\n};\n","import * as bigInt from \"big-integer\"\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\n\n/**\n * Provides the implementation of functionality that are common to {@link IPNumber}'s\n */\nexport abstract class AbstractIPNum {\n    /**\n     * The decimal value represented by the IP number in BigInteger\n     */\n    abstract readonly value: bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the IP number\n     */\n    abstract readonly bitSize: number;\n    /**\n     * The maximum bit size (i.e. binary value) of the IP number in BigInteger\n     */\n    abstract readonly maximumBitSize: bigInt.BigInteger;\n\n    /**\n     * Gets the numeric value of an IP number as {@link BigInteger}\n     *\n     * @returns {bigInt.BigInteger} the numeric value of an IP number.\n     */\n    public getValue():bigInt.BigInteger {\n        return this.value;\n    }\n\n    /**\n     * Gets the binary string representation of an IP number.\n     *\n     * @returns {string} the string binary representation.\n     */\n    public toBinaryString(): string {\n        return leftPadWithZeroBit(this.value.toString(2), this.bitSize);\n    }\n\n    /**\n     * Checks if an IP number has a value greater than the present value\n     * @returns {boolean} true, if there is a value greater than the present value. Returns false otherwise.\n     */\n    hasNext():boolean {\n        return this.value.lesser(this.maximumBitSize);\n    }\n\n    /**\n     * Checks if an IP number has a value lesser than the present value\n     * @returns {boolean} true, if there is a value lesser than the present value. Returns false otherwise.\n     */\n    hasPrevious():boolean {\n        return this.value.greater(bigInt.zero);\n    }\n\n    /**\n     * Checks if the given IP number, is equals to the current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is equals\n     */\n    public isEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.equals(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is lesser than this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is less than this current one. False otherwise.\n     */\n    public isLessThan(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.lt(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is greater than this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is greater than this current one. False otherwise.\n     */\n    public isGreaterThan(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.gt(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is less than or equals to this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is less than or equals to this current one. False otherwise.\n     */\n    public isLessThanOrEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.lesserOrEquals(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is greater than or equals to this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} {boolean} true if the given IP number is greater than or equals to this current one. False\n     * otherwise.\n     */\n    public isGreaterThanOrEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.greaterOrEquals(anotherIPNum.value);\n    }\n}","import {Octet} from \"./Octet\";\nimport {Validator} from \"./Validator\";\nimport * as bigInt from \"big-integer\"\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport {Hexadecatet} from \"./Hexadecatet\";\nimport {IPv4} from \"./IPv4\";\nimport {IPv6} from \"./IPv6\";\nimport {hexadectetNotationToBinaryString} from \"./HexadecimalUtils\";\n\n/**\n * The IPv4SubnetMask can be seen as a specialized IPv4 number where, in a 32 bit number, starting from the left, you\n * have continuous bits turned on (with 1 value) followed by bits turned off (with 0 value). In networking, it is used\n * to demarcate which bits are used to identify a network, and the ones that are used to identify hosts on the network\n */\nexport class IPv4SubnetMask extends IPv4 {\n    /**\n     * An array of {@link Octet}'s\n     *\n     * @type {Array} the octets that makes up the IPv4SubnetMask\n     */\n    readonly octets: Array<Octet> = [];\n\n    /**\n     * The decimal value represented by the IPv4 subnet mask in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n\n    /**\n     * A convenience method for creating an instance of IPv4SubnetMask. The passed strings need to be a valid IPv4\n     * number in dot-decimal notation.\n     *\n     * @param {string} rawValue The passed string in dot-decimal notation\n     * @returns {IPv4SubnetMask} the instance of IPv4SubnetMask\n     */\n    static fromDecimalDottedString(rawValue:string):IPv4SubnetMask {\n        return new IPv4SubnetMask(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of IPv4SubnetMask.\n     * The passed strings need to be a valid IPv4 subnet mask number in dot-decimal notation.\n     *\n     * @param {string} ipString The passed string in dot-decimal notation\n     */\n    constructor(ipString: string) {\n        super(ipString);\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidIPv4SubnetMask(ipString);\n\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringOctets = ipString.split(\".\");\n        this.octets = stringOctets.map((rawOctet) => {\n            return Octet.fromString(rawOctet)\n        });\n        this.value = bigInt(dottedDecimalNotationToBinaryString(ipString), 2);\n    }\n}\n\n/**\n * The IPv6SubnetMask can be seen as a specialized IPv4 number where, in a 128 bit number, starting from the left,\n * you have continuous bits turned on (with 1 value) followed by bits turned off (with 0 value). In networking, it\n * is used to to demarcate which bits are used to identify a network, and the ones that are used to identify hosts\n * on the network\n */\nexport class IPv6SubnetMask extends IPv6 {\n    /**\n     * An array of {@link Hexadecatet}'s\n     *\n     * @type {Array} the hexadecatet that makes up the IPv6 number\n     */\n    readonly hexadecatet: Array<Hexadecatet> = [];\n\n    /**\n     * The decimal value represented by the IPv6 number in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n\n\n    /**\n     * A convenience method for creating an instance of IPv6SubnetMask.\n     * The passed strings need to be a valid IPv4 subnet mask number in dot-decimal notation.\n     *\n     * @param {string} rawValue The passed string in textual notation\n     * @returns {IPv6SubnetMask} the instance of IPv6SubnetMask\n     */\n    static fromHexadecimalString(rawValue:string):IPv6SubnetMask {\n        return new IPv6SubnetMask(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of IPv6SubnetMask.\n     * The passed strings need to be a valid IPv6 subnet mask number in dot-decimal notation\n     *\n     * @param {string} ipString The passed IPv6 string\n     */\n    constructor(ipString: string) {\n        super(ipString);\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidIPv6SubnetMask(ipString);\n\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringHexadecimals = ipString.split(\":\");\n        this.hexadecatet = stringHexadecimals.map((stringHexadecatet) => {\n            return Hexadecatet.fromString(stringHexadecatet)\n        });\n        this.value = bigInt(hexadectetNotationToBinaryString(ipString), 2);\n    }\n}","import {Validator} from \"./Validator\";\nimport {IPv4SubnetMask} from \"./SubnetMask\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {IPNumType} from \"./IPNumType\";\nimport {IPv6SubnetMask} from \"./SubnetMask\";\nimport {binaryStringToHexadecimalString} from \"./HexadecimalUtils\";\nimport {Hexadecatet} from \"./Hexadecatet\";\n\n\ninterface Prefix {\n    value: number;\n    getValue(): number;\n}\n\n/**\n * Represents the prefix portion in the CIDR notation for representing IP ranges\n *\n * The IPv4 prefix portion represents the subnet mask. It is the number of continuous bits turned on (with value 1)\n * counting from the left side of an 8 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing} for more information on CIDR\n */\nclass IPv4Prefix implements Prefix {\n    /**\n     * The decimal value of the 8bit number representing the prefix\n     */\n    value: number;\n\n    /**\n     * Convenience method for constructing an instance of IPv4 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv4 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv4 prefix\n     */\n    static fromNumber(rawValue:number):IPv4Prefix {\n        return new IPv4Prefix(rawValue);\n    };\n\n    /**\n     * Constructor for an instance of IPv4 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv4 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv4 prefix\n     */\n    constructor(rawValue: number) {\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidPrefixValue(rawValue, IPNumType.IPv4);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = rawValue;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix\n     *\n     * @returns {number} the decimal value of the IPv4 prefix\n     */\n    public getValue(): number {\n        return this.value;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix as string\n     * @returns {string} he decimal value of the IPv4 prefix as string\n     */\n    public toString(): string {\n        return this.value.toString();\n    }\n\n    /**\n     * Converts the IPv4 prefix to a {@link IPv4SubnetMask}\n     *\n     * The IPv4 Subnet mask is the representation of the prefix in the dot-decimal notation\n     *\n     * @returns {IPv4SubnetMask} the subnet mask representation of the prefix\n     */\n    public toSubnetMask(): IPv4SubnetMask {\n        let onBits = '1'.repeat(this.value);\n        let offBits = '0'.repeat(32 - this.value);\n        return IPv4SubnetMask.fromDecimalDottedString(this.toDecimalNotation(`${onBits}${offBits}`));\n    }\n\n    private toDecimalNotation(bits:string): string {\n        return `${parseBinaryStringToBigInteger(bits.substr(0,8))}.${parseBinaryStringToBigInteger(bits.substr(8,8))}.${parseBinaryStringToBigInteger(bits.substr(16,8))}.${parseBinaryStringToBigInteger(bits.substr(24,8))}`\n    }\n}\n\n/**\n * Represents the prefix portion in the CIDR notation for representing IP ranges\n *\n * The IPv6 prefix portion represents the subnet mask. It is the number of continuous bits turned on (with value 1)\n * counting from the left side of an 128 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing} for more information on CIDR\n */\nclass IPv6Prefix implements Prefix {\n    /**\n     * The decimal value of the 16bit number representing the prefix\n     */\n    value: number;\n\n    /**\n     * Convenience method for constructing an instance of IPv46 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv6 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv6 prefix\n     */\n    static fromNumber(rawValue:number):IPv6Prefix {\n        return new IPv6Prefix(rawValue);\n    };\n\n    /**\n     * Constructor for an instance of IPv6 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv6 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv6 prefix\n     */\n    constructor(rawValue: number) {\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidPrefixValue(rawValue, IPNumType.IPv6);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = rawValue;\n    }\n\n    /**\n     * Gets the decimal value of the IPv6 prefix\n     *\n     * @returns {number} the decimal value of the IPv6 prefix\n     */\n    public getValue(): number {\n        return this.value;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix as string\n     * @returns {string} he decimal value of the IPv4 prefix as string\n     */\n    public toString(): string {\n        return this.value.toString();\n    }\n\n    /**\n     * Converts the IPv6 prefix to a {@link IPv6SubnetMask}\n     *\n     * The IPv6 Subnet mask is the representation of the prefix in 8 groups of 16 bit values represented in hexadecimal\n     *\n     * @returns {IPv6SubnetMask} the subnet mask representation of the prefix\n     */\n    public toSubnetMask(): IPv6SubnetMask {\n        let onBits = '1'.repeat(this.value);\n        let offBits = '0'.repeat(128 - this.value);\n        return IPv6SubnetMask.fromHexadecimalString(this.toHexadecatetNotation(`${onBits}${offBits}`));\n    }\n\n    private toHexadecatetNotation(bits:string): string {\n        let binaryStrings: string[] = bits.match(/.{1,16}/g)!;\n        let hexadecimalStrings: Hexadecatet[] = binaryStrings.map((binaryString) => {\n            return Hexadecatet.fromString(binaryStringToHexadecimalString(binaryString));\n        });\n        return hexadecimalStrings.map((value) => { return value.toString()}).join(\":\");\n    }\n}\n\nexport {Prefix, IPv4Prefix, IPv6Prefix}","import {Validator} from \"./Validator\"\nimport bigInt = require(\"big-integer\");\n\n/**\n * A binary representation of a 8 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Octet_(computing)} for more information on Octets\n *\n * An octet is used in the textual representation of an {@link IPv4} number, where the IP number value is divided\n * into 4 octets\n */\nexport class Octet {\n    private readonly value: number;\n\n    /**\n     * Convenience method for creating an Octet out of a string value representing the value of the octet\n     *\n     * @param {string} rawValue the octet value in string\n     * @returns {Octet} the Octet instance\n     */\n    static fromString(rawValue:string):Octet {\n        return new Octet(rawValue);\n    };\n\n    /**\n     * Convenience method for creating an Octet out of a numeric value representing the value of the octet\n     *\n     * @param {number} rawValue the octet value in number\n     * @returns {Octet} the Octet instance\n     */\n    static fromNumber(rawValue:number):Octet {\n        return new Octet(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of an Octet.\n     *\n     * The constructor parameter given could either be a string or number.\n     *\n     * If a string, it is the string representation of the numeric value of the octet\n     * If a number, it is the numeric representation of the value of the octet\n     *\n     * @param {string | number} givenValue value of the octet to be created.\n     */\n    constructor(givenValue: string | number) {\n        let octetValue: number;\n        if (typeof givenValue === 'string') {\n            octetValue = parseInt(givenValue);\n        } else {\n            octetValue = givenValue;\n        }\n        let [isValid, message] = Validator.isValidIPv4Octet(bigInt(octetValue));\n        if (!isValid) {\n            throw Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = octetValue;\n    }\n\n    /**\n     * Method to get the numeric value of the octet\n     *\n     * @returns {number} the numeric value of the octet\n     */\n    public getValue():number {\n        return this.value;\n    }\n\n    /**\n     * Returns a decimal representation of the value of the octet in string\n     *\n     * @returns {string} a decimal representation of the value of the octet in string\n     */\n    public toString(): string {\n        return this.value.toString(10);\n    }\n}","import * as bigInt from \"big-integer\";\nimport {Prefix} from \"./Prefix\";\nimport {IPv6} from \"./IPv6\";\nimport {IPv6CidrRange} from \"./IPv6CidrRange\";\nimport {IPv4CidrRange} from \"./IPv4CidrRange\";\nimport {IPv4} from \"./IPv4\";\n\n/**\n * Provides the implementation of functionality that are common to {@link IPRange}s\n */\n\nexport abstract class AbstractIpRange {\n\n    abstract readonly bitValue: bigInt.BigInteger;\n    abstract readonly cidrPrefix: Prefix;\n    abstract getFirst(): IPv6 | IPv4\n    abstract getLast(): IPv6 | IPv4\n\n    public getSize(): bigInt.BigInteger {\n        /**\n         * Using bitwise shit operation this will be\n         * 1 << (this.bitValue - this.prefix.getValue())\n         * Since left shift a number by x is equivalent to multiplying the number by the power x raised to 2\n         * 2 << 4 = 2 * (2 raised to 4)\n         */\n        return bigInt(2).pow(this.bitValue.minus(bigInt(this.cidrPrefix.getValue())));\n    }\n\n    public inside(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        let thisFirst: IPv6 | IPv4 = this.getFirst();\n        let thisLast: IPv6 | IPv4 = this.getLast();\n        let otherFirst: IPv6 | IPv4 = otherRange.getFirst();\n        let otherLast: IPv6 | IPv4 = otherRange.getLast();\n\n        return (otherFirst.isLessThanOrEquals(thisFirst) && otherLast.isGreaterThanOrEquals(thisLast));\n    }\n\n    public contains(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        let thisFirst: IPv6 | IPv4 = this.getFirst();\n        let thisLast: IPv6 | IPv4 = this.getLast();\n        let otherFirst: IPv6 | IPv4 = otherRange.getFirst();\n        let otherLast: IPv6 | IPv4 = otherRange.getLast();\n\n        return (thisFirst.isLessThanOrEquals(otherFirst) && thisLast.isGreaterThanOrEquals(otherLast));\n    }\n\n    public isOverlapping(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        let thisFirst: IPv6 | IPv4 = this.getFirst();\n        let thisLast: IPv6 | IPv4 = this.getLast();\n        let otherFirst: IPv6 | IPv4 = otherRange.getFirst();\n        let otherLast: IPv6 | IPv4 = otherRange.getLast();\n\n        return (\n            thisLast.isGreaterThan(otherFirst) && thisLast.isLessThanOrEquals(otherLast) && thisFirst.isLessThan(otherFirst)\n            ||\n            otherLast.isGreaterThan(thisFirst) && otherLast.isLessThanOrEquals(thisLast) && otherFirst.isLessThan(otherFirst)\n        );\n    }\n\n    public isConsecutive(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        let thisFirst: IPv6 | IPv4 = this.getFirst();\n        let thisLast: IPv6 | IPv4 = this.getLast();\n        let otherFirst: IPv6 | IPv4 = otherRange.getFirst();\n        let otherLast: IPv6 | IPv4 = otherRange.getLast();\n\n        return (\n            thisLast.hasNext() && thisLast.nextIPNumber().isEquals(otherFirst)\n            ||\n            otherLast.hasNext() && otherLast.nextIPNumber().isEquals(thisFirst)\n        )\n    }\n\n    public hasNextRange(): boolean {\n        let sizeOfCurrentRange = this.getSize();\n        return bigInt(2).pow(this.bitValue)\n            .minus(sizeOfCurrentRange)\n            .greaterOrEquals(this.getFirst().getValue().plus(sizeOfCurrentRange));\n    }\n\n    public hasPreviousRange(): boolean {\n        return this.getSize()\n            .lesserOrEquals(this.getFirst().getValue())\n    }\n\n}","import {IPv6Prefix} from \"./Prefix\";\nimport {IPv6} from \"./IPv6\";\nimport * as bigInt from \"big-integer\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {Validator} from \"./Validator\";\nimport {IPRange} from \"./interface/IPRange\";\nimport {AbstractIpRange} from \"./AbstractIpRange\";\n\n/**\n * Represents a continuous segment of IPv6 number following the\n * classless inter-domain routing scheme for allocating IP addresses.\n *\n * @see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n */\nexport class IPv6CidrRange extends AbstractIpRange implements IPRange, IterableIterator<IPv6> {\n    readonly bitValue: bigInt.BigInteger = bigInt(128);\n    private internalCounterValue: IPv6;\n\n    /**\n     * Convenience method for constructing an instance of an IPV6Range from an IP range represented in CIDR notation\n     *\n     * @param {string} rangeIncidrNotation the range of the IPv6 number in CIDR notation\n     * @returns {IPV6Range} the IPV6Range\n     */\n    static fromCidr(rangeIncidrNotation:string):IPv6CidrRange {\n        let [isValid, message] = Validator.isValidIPv6CidrNotation(rangeIncidrNotation);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let cidrComponents: Array<string> = rangeIncidrNotation.split(\"/\");\n        let ipString = cidrComponents[0];\n        let prefix = parseInt(cidrComponents[1]);\n\n        return new IPv6CidrRange(IPv6.fromHexadecimalString(ipString), IPv6Prefix.fromNumber(prefix));\n    };\n\n    /**\n     * Constructor for creating an instance of an IPv6 range.\n     *\n     * The arguments taken by the constructor is inspired by the CIDR notation which basically consists of the IP\n     * number and the prefix.\n     *\n     * @param {IPv6} ipv6 the IP number used to construct the range. By convention this is the first IP number in\n     * the range, but it could also be any IP number within the range\n     * @param {IPv6Prefix} cidrPrefix the prefix which is a representation of the number of bits used to mask the\n     * given IPv6 number in other to create the range\n     */\n    constructor(private readonly ipv6: IPv6, readonly cidrPrefix: IPv6Prefix) {\n        super();\n        this.internalCounterValue = this.getFirst();\n    }\n\n    /**\n     * Gets the size of IPv6 numbers contained within the IPv6 range\n     *\n     * @returns {bigInt.BigInteger} the amount of IPv6 numbers in the range\n     */\n    public getSize(): bigInt.BigInteger {\n        return super.getSize();\n    }\n\n    /**\n     * Method that returns the IPv6 range in CIDR (Classless Inter-Domain Routing) notation.\n     *\n     * See {@link https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation} for more information\n     * on the Classless Inter-Domain Routing notation\n     *\n     * @returns {string} the IPv6 range in CIDR (Classless Inter-Domain Routing) notation\n     */\n    public toCidrString(): string {\n        return `${this.ipv6.toString()}/${this.cidrPrefix.toString()}`\n    }\n\n    /**\n     * Method that returns the IPv6 range in string notation where the first IPv6 number and last IPv6 number are\n     * separated by an hyphen. eg. \"2001:db8:0:0:0:0:0:0-2001:db8:0:ffff:ffff:ffff:ffff:ffff\"\n     *\n     * @returns {string} the range in [first IPv6 number] - [last IPv6 number] format\n     */\n    public toRangeString(): string {\n        return `${this.getFirst()}-${this.getLast()}`\n    }\n\n    /**\n     * Method that returns the first IPv6 number in the IPv6 range\n     *\n     * @returns {IPv6} the first IPv6 number in the IPv6 range\n     */\n    public getFirst(): IPv6 {\n        return IPv6.fromBigInteger(this.ipv6.getValue().and(this.cidrPrefix.toSubnetMask().getValue()));\n    }\n\n    /**\n     * Method that returns the last IPv6 number in the IPv6 range\n     *\n     * @returns {IPv6} the last IPv6 number in the IPv6 range\n     */\n    public getLast(): IPv6 {\n        let onMask = bigInt(\"1\".repeat(128), 2);\n        let subnetMaskAsBigInteger = this.cidrPrefix.toSubnetMask().getValue();\n        let invertedSubnetMask = leftPadWithZeroBit(subnetMaskAsBigInteger.xor(onMask).toString(2), 128);\n        return IPv6.fromBigInteger(this.ipv6.getValue().or(parseBinaryStringToBigInteger(invertedSubnetMask)));\n    }\n\n    /**\n     * Indicates whether the given IPv6 range is an adjacent range.\n     *\n     * An adjacent range being one where the end of the given range, when incremented by one marks the start of the\n     * other range. Or where the start of the given range, when decreased by one, marks the end of the other range\n     *\n     * @param {IPv6CidrRange} otherRange the other IPv6 range to compare with\n     * @returns {boolean} true if the two IPv6 ranges are consecutive, false otherwise\n     */\n    public isConsecutive(otherRange: IPv6CidrRange): boolean {\n        return super.isConsecutive(otherRange);\n    }\n\n    /**\n     * Indicates if the given IPv6 range is a subset.\n     *\n     * By a subset range, it means all the values of the given range are contained by this IPv6 range\n     *\n     * @param {IPv6CidrRange} otherRange the other IPv6 range\n     * @returns {boolean} true if the other Ipv6 range is a subset. False otherwise.\n     */\n    public contains(otherRange: IPv6CidrRange): boolean {\n        return super.contains(otherRange);\n    }\n\n    /**\n     * Indicate if the given range is a container range.\n     *\n     * By container range, it means all the IP number in this current range can be found within the given range.\n     *\n     * @param {IPv6CidrRange} otherRange he other IPv6 range\n     * @returns {boolean} true if the other Ipv6 range is a container range. False otherwise.\n     */\n    public inside(otherRange: IPv6CidrRange): boolean {\n        return super.inside(otherRange);\n    }\n\n    /**\n     * Checks if two IPv6 ranges overlap\n     * @param {IPv6CidrRange} otherRange the other IPv6 range\n     * @returns {boolean} true if the ranges overlap, false otherwise\n     */\n    public isOverlapping(otherRange: IPv6CidrRange): boolean {\n        return super.isOverlapping(otherRange);\n    }\n\n    /**\n     * Method that takes IPv6 number from within an IPv6 range, starting from the first IPv6 number\n     *\n     * @param {number} count the amount of IPv6 number to take from the IPv6 range\n     * @returns {Array<IPv6>} an array of IPv6 number, taken from the IPv6 range\n     */\n    public take(count: number): Array<IPv6> {\n        let iPv6s: Array<IPv6>  = [this.getFirst()];\n        let iteratingIPv6 = this.getFirst();\n\n        if (bigInt(count).greater(this.getSize())) {\n            throw new Error(`${count.toString()} is greater than ${this.getSize().toString()}, the size of the range`);\n        }\n\n        for (var counter = 0; counter < count - 1; counter++) {\n            iPv6s.push(iteratingIPv6.nextIPNumber());\n            iteratingIPv6 = iteratingIPv6.nextIPNumber();\n        }\n        return iPv6s;\n    }\n\n    /**\n     * Method that splits an IPv6 range into two halves\n     *\n     * @returns {Array<IPv6CidrRange>} An array of two {@link IPv6CidrRange}\n     */\n    public split() : Array<IPv6CidrRange> {\n        let prefixToSplit = this.cidrPrefix.getValue();\n        if (prefixToSplit === 128) {\n            throw new Error(\"Cannot split an IP range with a single IP number\");\n        }\n        let splitCidr = IPv6Prefix.fromNumber(prefixToSplit + 1);\n        let firstIPOfFirstRange = this.getFirst();\n        let firstRange = new IPv6CidrRange(firstIPOfFirstRange, splitCidr);\n        let firstIPOfSecondRange = firstRange.getLast().nextIPNumber();\n        let secondRange = new IPv6CidrRange(firstIPOfSecondRange, splitCidr);\n        return [firstRange, secondRange];\n    }\n\n    public hasNextRange(): boolean {\n        return super.hasNextRange();\n    }\n\n    public hasPreviousRange(): boolean {\n        return super.hasPreviousRange();\n    }\n\n    public nextRange(): IPv6CidrRange | undefined {\n        if (this.hasNextRange()) {\n            let sizeOfCurrentRange = this.getSize();\n            let startOfNextRange = this.getFirst().getValue().plus(sizeOfCurrentRange);\n            return new IPv6CidrRange(new IPv6(startOfNextRange), this.cidrPrefix)\n        }\n        return;\n    }\n\n    public previousRange(): IPv6CidrRange | undefined {\n        if (this.hasPreviousRange()) {\n            let sizeOfCurrentRange = this.getSize();\n            let startOfPreviousRange = this.getFirst().getValue().minus(sizeOfCurrentRange);\n            return new IPv6CidrRange(new IPv6(startOfPreviousRange), this.cidrPrefix)\n        }\n        return;\n    }\n\n    next(value?: any): IteratorResult<IPv6>;\n    next(value?: any): IteratorResult<IPv6>;\n    next(value?: any) {\n        let returnValue = this.internalCounterValue;\n        this.internalCounterValue = this.internalCounterValue.nextIPNumber();\n\n        if (returnValue.isLessThanOrEquals(this.getLast())) {\n            return {\n                done:false,\n                value: returnValue\n            }\n        } else {\n            return {\n                done:true\n            }\n        }\n    }\n\n    [Symbol.iterator](): IterableIterator<IPv6> {\n        return this;\n    }\n}","import {IPv4} from \"./IPv4\";\nimport {IPv4Prefix} from \"./Prefix\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {Validator} from \"./Validator\";\nimport * as bigInt from \"big-integer\";\nimport {IPRange} from \"./interface/IPRange\";\nimport {AbstractIpRange} from \"./AbstractIpRange\";\n\n/**\n * Represents a continuous segment of IPv4 numbers following the\n * classless inter-domain routing scheme for allocating IP addresses.\n *\n * @see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n */\nexport class IPv4CidrRange extends AbstractIpRange implements IPRange, IterableIterator<IPv4> {\n    readonly bitValue: bigInt.BigInteger = bigInt(32);\n    private internalCounterValue: IPv4;\n\n    /**\n     * Convenience method for constructing an instance of an IPv4CidrRange from an IP range represented in CIDR notation\n     *\n     * @param {string} rangeIncidrNotation the range of the IPv4 number in CIDR notation\n     * @returns {IPv4CidrRange} the IPv4CidrRange\n     */\n    static fromCidr(rangeIncidrNotation:string):IPv4CidrRange {\n        let [isValid, errorMessages] = Validator.isValidIPv4CidrNotation(rangeIncidrNotation);\n        if (!isValid) {\n            let messages = errorMessages.filter(message => {return message !== ''});\n            throw new Error(messages.join(' and '));\n        }\n        let cidrComponents: Array<string> = rangeIncidrNotation.split(\"/\");\n        let ipString = cidrComponents[0];\n        let prefix = parseInt(cidrComponents[1]);\n        return new IPv4CidrRange(IPv4.fromDecimalDottedString(ipString), IPv4Prefix.fromNumber(prefix));\n    };\n\n    /**\n     * Constructor for creating an instance of an IPv4 range.\n     *\n     * The arguments taken by the constructor is inspired by the CIDR notation which basically consists of the IP\n     * number and the prefix.\n     *\n     * @param {IPv4} ipv4 the IP number used to construct the range. By convention this is the first IP number in\n     * the range, but it could also be any IP number within the range\n     * @param {IPv4Prefix} cidrPrefix the prefix which is a representation of the number of bits used to mask the\n     * given IP number in other to create the range\n     */\n    constructor(private readonly ipv4: IPv4, readonly cidrPrefix: IPv4Prefix) {\n        super();\n        this.internalCounterValue = this.getFirst();\n    }\n\n    /**\n     * Gets the size of IPv4 numbers contained within the IPv4 range\n     *\n     * @returns {bigInt.BigInteger} the amount of IPv4 numbers in the range\n     */\n    public getSize(): bigInt.BigInteger {\n        return super.getSize();\n    }\n\n    /**\n     * Method that returns the IPv4 range in CIDR (Classless Inter-Domain Routing) notation.\n     *\n     * See {@link https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation} for more information\n     * on the Classless Inter-Domain Routing notation\n     *\n     * @returns {string} the IPv4 range in CIDR (Classless Inter-Domain Routing) notation\n     */\n    public toCidrString(): string {\n        return `${this.ipv4.toString()}/${this.cidrPrefix.toString()}`\n    }\n\n    /**\n     * Method that returns the IPv4 range in string notation where the first IPv4 number and last IPv4 number are\n     * separated by an hyphen. eg. 192.198.0.0-192.198.0.255\n     *\n     * @returns {string} the range in [first IPv4 number] - [last IPv4 number] format\n     */\n    public toRangeString(): string {\n        return `${this.getFirst()}-${this.getLast()}`\n    }\n\n\n    /**\n     * Method that returns the first IPv4 number in the IPv4 range\n     *\n     * @returns {IPv4} the first IPv4 number in the IPv4 range\n     */\n    public getFirst(): IPv4 {\n        return IPv4.fromBigInteger(this.ipv4.getValue().and(this.cidrPrefix.toSubnetMask().getValue()));\n    }\n\n    /**\n     * Method that returns the last IPv4 number in the IPv4 range\n     *\n     * @returns {IPv4} the last IPv4 number in the IPv4 range\n     */\n    public getLast(): IPv4 {\n        let onMask = bigInt(\"1\".repeat(32), 2);\n        let subnetAsBigInteger = this.cidrPrefix.toSubnetMask().getValue();\n        let invertedSubnet = leftPadWithZeroBit(subnetAsBigInteger.xor(onMask).toString(2), 32);\n        return IPv4.fromBigInteger(this.ipv4.getValue().or(parseBinaryStringToBigInteger(invertedSubnet)));\n    }\n\n    /**\n     * Indicates whether the given IPv4 range is an adjacent range.\n     *\n     * An adjacent range being one where the end of the given range, when incremented by one marks the start of the\n     * other range. Or where the start of the given range, when decreased by one, marks the end of the other range\n     *\n     * @param {IPv4CidrRange} otherRange the other IPv4 range to compare with\n     * @returns {boolean} true if the two IPv4 ranges are consecutive, false otherwise\n     */\n    public isConsecutive(otherRange: IPv4CidrRange): boolean {\n        return super.isConsecutive(otherRange);\n    }\n\n    /**\n     * Indicates if the given IPv4 range is a subset.\n     *\n     * By a subset range, it means all the values of the given range are contained by this IPv4 range\n     *\n     * @param {IPv4CidrRange} otherRange the other IPv4 range\n     * @returns {boolean} true if the other Ipv4 range is a subset. False otherwise.\n     */\n    public contains(otherRange: IPv4CidrRange): boolean {\n        return super.contains(otherRange);\n    }\n\n    /**\n     * Indicate if the given range is a container range.\n     *\n     * By container range, it means all the IP number in this current range can be found within the given range.\n     *\n     * @param {IPv4CidrRange} otherRange he other IPv4 range\n     * @returns {boolean} true if the other Ipv4 range is a container range. False otherwise.\n     */\n    public inside(otherRange: IPv4CidrRange): boolean {\n        return super.inside(otherRange);\n    }\n\n    /**\n     * Checks if two IPv4 ranges overlap\n     * @param {IPv4CidrRange} otherRange the other IPv4 range\n     * @returns {boolean} true if the ranges overlap, false otherwise\n     */\n    public isOverlapping(otherRange: IPv4CidrRange): boolean {\n        return super.isOverlapping(otherRange);\n    }\n\n    /**\n     * Method that takes IPv4 number from within an IPv4 range, starting from the first IPv4 number\n     *\n     * @param {number} count the amount of IPv4 number to take from the IPv4 range\n     * @returns {Array<IPv4>} an array of IPv4 number, taken from the IPv4 range\n     */\n    public take(count: number): Array<IPv4> {\n        let ipv4s: Array<IPv4>  = [this.getFirst()];\n        let iteratingIPv4 = this.getFirst();\n\n        if (bigInt(count).greater(this.getSize())) {\n            let errMessage = Validator.takeOutOfRangeSizeMessage\n                .replace(\"$count\", count.toString())\n                .replace(\"$size\", this.getSize().toString());\n            throw new Error(errMessage);\n        }\n\n        for (var counter = 0; counter < count - 1; counter++) {\n            ipv4s.push(iteratingIPv4.nextIPNumber());\n            iteratingIPv4 = iteratingIPv4.nextIPNumber();\n        }\n        return ipv4s;\n    }\n\n    /**\n     * Method that splits an IPv4 range into two halves\n     *\n     * @returns {Array<IPv4CidrRange>} An array of two {@link IPv4CidrRange}\n     */\n    public split() : Array<IPv4CidrRange> {\n        let prefixToSplit = this.cidrPrefix.getValue();\n        if (prefixToSplit === 32) {\n            throw new Error(\"Cannot split an IP range with a single IP number\");\n        }\n        let splitCidr = IPv4Prefix.fromNumber(prefixToSplit + 1);\n        let firstIPOfFirstRange = this.getFirst();\n        let firstRange = new IPv4CidrRange(firstIPOfFirstRange, splitCidr);\n        let firstIPOfSecondRange = firstRange.getLast().nextIPNumber();\n        let secondRange = new IPv4CidrRange(firstIPOfSecondRange, splitCidr);\n        return [firstRange, secondRange];\n    }\n\n    public hasNextRange(): boolean {\n        return super.hasNextRange();\n    }\n\n    public hasPreviousRange(): boolean {\n        return super.hasPreviousRange();\n    }\n\n    public nextRange(): IPv4CidrRange | undefined {\n        if (this.hasNextRange()) {\n            let sizeOfCurrentRange = this.getSize();\n            let startOfNextRange = this.getFirst().getValue().plus(sizeOfCurrentRange);\n            return new IPv4CidrRange(new IPv4(startOfNextRange), this.cidrPrefix)\n        }\n\n        return;\n    }\n\n    public previousRange(): IPv4CidrRange | undefined {\n        if (this.hasPreviousRange()) {\n            let sizeOfCurrentRange = this.getSize();\n            let startOfPreviousRange = this.getFirst().getValue().minus(sizeOfCurrentRange);\n            return new IPv4CidrRange(new IPv4(startOfPreviousRange), this.cidrPrefix)\n        }\n\n        return;\n    }\n\n    next(value?: any): IteratorResult<IPv4>;\n    next(value?: any): IteratorResult<IPv4>;\n    next(value?: any) {\n        let returnValue = this.internalCounterValue;\n        this.internalCounterValue = this.internalCounterValue.nextIPNumber();\n\n        if (returnValue.isLessThanOrEquals(this.getLast())) {\n            return {\n                done:false,\n                value: returnValue\n            }\n        } else {\n            return {\n                done:true\n            }\n        }\n    }\n\n    [Symbol.iterator](): IterableIterator<IPv4> {\n        return this;\n    }\n}","import {Validator} from \"./Validator\"\nimport {IPNumber} from \"./interface/IPNumber\"\nimport {decimalNumberToBinaryString} from \"./BinaryUtils\";\nimport * as bigInt from \"big-integer\"\nimport {IPNumType} from \"./IPNumType\";\nimport {AbstractIPNum} from \"./AbstractIPNum\";\n\n/**\n * Represents an Autonomous System Number. Which is a number that is used to identify\n * a group of IP addresses with a common, clearly defined routing policy.\n *\n * @see https://en.wikipedia.org/wiki/Autonomous_system_(Internet)\n * @see https://tools.ietf.org/html/rfc5396\n */\nexport class Asn extends AbstractIPNum implements IPNumber {\n    /**\n     * The decimal value represented by the ASN number in BigInteger\n     */\n    readonly value:bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the ASN number\n     */\n    bitSize: number = 32;\n    /**\n     * The maximum bit size (i.e. binary value) of the ASN number in BigInteger\n     */\n    maximumBitSize: bigInt.BigInteger = Validator.THIRTY_TWO_BIT_SIZE;\n\n    type: IPNumType = IPNumType.ASN;\n    private static AS_PREFIX = \"AS\";\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a string\n     *\n     * The given string can be in asplain, asdot or asdot+ representation format.\n     * {@see https://tools.ietf.org/html/rfc5396} for more information on\n     * the different ASN string representation\n     *\n     * @param {string} rawValue the asn string. In either asplain, asdot or asdot+ format\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromString(rawValue:string):Asn {\n        return new Asn(rawValue);\n    };\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a numeric value\n     *\n     * @param {number} rawValue the asn numeric value\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromNumber(rawValue:number):Asn {\n        return new Asn(rawValue);\n    };\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a binary string\n     *\n     * @param {string} binaryString to create an ASN instance from\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromBinaryString(binaryString: string): Asn {\n        let validationResult = Validator.isValidBinaryString(binaryString);\n        if (validationResult[0]) {\n            return new Asn(parseInt(binaryString, 2))\n        } else {\n            throw Error(validationResult[1].join(','))\n        }\n    }\n\n    /**\n     * Constructor for an instance of {@link ASN}\n     *\n     * @param {string | number} rawValue value to construct an ASN from. The given value can either be numeric or\n     * string. If in string then it can be in asplain, asdot or asdot+ string representation format\n     */\n    constructor(rawValue:string | number) {\n        super();\n        if (typeof rawValue === 'string') {\n            if (Asn.startWithASprefix(rawValue)) {\n                this.value = bigInt(parseInt(rawValue.substring(2)));\n            } else if(rawValue.indexOf(\".\") != -1) {\n                this.value = bigInt(this.parseFromDotNotation(rawValue));\n            } else {\n                this.value = bigInt(parseInt(rawValue));\n            }\n        } else {\n            let valueAsBigInt = bigInt(rawValue);\n            let [isValid, message] = Validator.isValidAsnNumber(valueAsBigInt);\n            if (!isValid) {\n                throw Error(message.filter(msg => {return msg !== '';}).toString());\n            }\n            this.value = valueAsBigInt;\n        }\n    }\n\n    /**\n     * A string representation where the asn value is prefixed by \"ASN\". For example \"AS65526\"\n     *\n     * @returns {string} A string representation where the asn value is prefixed by \"ASN\"\n     */\n    toString():string {\n        let stringValue = this.value.toString();\n        return `${Asn.AS_PREFIX}${stringValue}`;\n    }\n\n    /**\n     * A string representation where the ASN numeric value of is represented as a string. For example \"65526\"\n     *\n     * @returns {string} A string representation where the ASN numeric value of is represented as a string\n     */\n    toASPlain():string {\n        return this.value.toString();\n    }\n\n    /**\n     * A string representation where the ASN value is represented using the asplain notation if the ASN value is\n     * less than 65536 and uses asdot+ notation when the value is greater than 65536.\n     *\n     * For example 65526 will be represented as \"65526\" while 65546 will be represented as \"1.10\"\n     *\n     *\n     * @returns {string} A string representation of the ASN in either asplain or asdot+ notation depending on\n     * whether the numeric value of the ASN number is greater than 65526 or not.\n     */\n    toASDot():string {\n        if (this.value.valueOf() >= 65536) {\n            return this.toASDotPlus();\n        }\n        return this.toASPlain();\n    }\n\n    /**\n     * A string representation where the ASN value is represented using the asdot+ notation\n     *\n     * @returns {string} A string representation where the ASN value is represented using the asdot+ notation\n     *\n     */\n    toASDotPlus():string {\n        let high = Math.floor(this.value.valueOf() / 65535);\n        let low = (this.value.valueOf() % 65535) - high;\n        return `${high}.${low}`;\n    }\n\n    /**\n     * Converts the ASN value to binary numbers represented with strings\n     *\n     * @returns {string} a binary string representation of the value of the ASN number\n     */\n    toBinaryString():string {\n        return decimalNumberToBinaryString(this.value.valueOf());\n    }\n\n    /**\n     * Checks if the ASN value is 16bit\n     *\n     * @returns {boolean} true if the ASN is a 16bit value. False otherwise.\n     */\n    is16Bit():boolean {\n        let [valid16BitAsnNumber,] = Validator.isValid16BitAsnNumber(this.value);\n        return valid16BitAsnNumber;\n    }\n\n    /**\n     * Checks if the ASN value is 32bit\n     *\n     * @returns {boolean} true if the ASN is a 32bit value. False otherwise.\n     */\n    is32Bit():boolean {\n        return !this.is16Bit();\n    }\n\n    /**\n     * Returns the next ASN number\n     *\n     * @returns {IPNumber} the next ASN number\n     */\n    nextIPNumber(): IPNumber {\n        return new Asn(this.value.valueOf() + 1);\n    }\n\n    /**\n     * Returns the previous ASN number\n     *\n     * @returns {IPNumber} the previous ASN number\n     */\n    previousIPNumber(): IPNumber {\n        return new Asn(this.value.valueOf() - 1)\n    }\n\n    private static startWithASprefix(word:string):boolean {\n        return word.indexOf(Asn.AS_PREFIX) === 0;\n    }\n\n    private parseFromDotNotation(rawValue: string): number {\n        let values: string[] = rawValue.split(\".\");\n        let high = parseInt(values[0]);\n        let low = parseInt(values[1]);\n        return (high * 65535) + (low + high);\n    }\n}","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/**\n * Exposes all the library's modules making them available from the \"ip-num\" module.\n * Making it possible to get access to all any of the modules by doing require(\"ip-num\")\n *\n * @example\n * let ipNum = require(\"ip-num\")\n * ipNum.IPv4CidrRange // gets access to IPv4CidrRange\n * ipNum.Asn // gets access to Asn\n */\nexport * from './interface/IPNumber'\nexport * from './interface/IPRange'\nexport * from './AbstractIPNum'\nexport * from './Asn'\nexport * from './BinaryUtils'\nexport * from './Hexadecatet'\nexport * from './HexadecimalUtils'\nexport * from './IPNumType'\nexport * from './IPv4'\nexport * from './IPv4CidrRange'\nexport * from './IPv6'\nexport * from './IPv6CidrRange'\nexport * from './IPv6Utils'\nexport * from './Octet'\nexport * from './Prefix'\nexport * from './SubnetMask'\nexport * from './Validator'"],"sourceRoot":""}