{"version":3,"sources":["webpack://ipnum/webpack/bootstrap","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/BinaryUtils.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/node_modules/big-integer/BigInteger.js","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/Validator.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/IPv6Utils.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/IPNumType.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/IPv6.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/IPv4.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/Hexadecatet.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/HexadecimalUtils.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/AbstractIPNum.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/SubnetMask.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/Prefix.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/Octet.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/IPv6Range.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/IPv4Range.ts","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/Asn.ts","webpack://ipnum/(webpack)/buildin/module.js","webpack://ipnum//Users/daderemi/Documents/play/ip-num/src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","bigInt","decimalNumberToBinaryString","num","Number","toString","bigIntegerNumberToBinaryString","decimalNumberToOctetString","binaryString","length","Error","leftPadWithZeroBit","parseBinaryStringToBigInteger","dottedDecimalNotationToBinaryString","dottedDecimal","split","reduce","binaryAsString","octet","concat","parseInt","finalStringLength","repeat","__WEBPACK_AMD_DEFINE_RESULT__","undefined","BASE","LOG_BASE","MAX_INT","MAX_INT_ARR","smallToArray","LOG_MAX_INT","Math","log","Integer","v","radix","parseValue","parseBase","BigInteger","sign","this","isSmall","SmallInteger","isPrecise","floor","arrayToSmall","arr","trim","compareAbs","createArray","x","Array","truncate","ceil","add","a","b","sum","l_a","l_b","carry","base","push","addAny","addSmall","subtract","difference","a_l","b_l","borrow","subtractSmall","multiplyLong","product","a_i","j","multiplySmall","shiftLeft","multiplySmallAndArray","square","divModSmall","lambda","q","remainder","divisor","quotient","divModAny","self","negate","abs","comparison","quotientDigit","shift","result","divisorMostSignificantDigit","divMod1","guess","xlen","highx","highy","check","part","unshift","reverse","divMod2","qSign","mod","mSign","isBasicPrime","isUnit","equals","isEven","isDivisibleBy","lesser","plus","subtractAny","minus","small","multiply","l1","l2","useKaratsuba","multiplyKaratsuba","y","max","slice","ac","bd","times","_multiplyBySmall","divmod","divide","over","pow","modPow","exp","isZero","isPositive","isOdd","compare","Infinity","compareTo","eq","notEquals","neq","greater","gt","lt","greaterOrEquals","geq","lesserOrEquals","leq","isNegative","isPrime","nPrev","prev","isProbablePrime","iterations","randBetween","modInv","lastT","lastR","zero","newT","one","newR","next","powersOfTwo","powers2Length","highestPower2","shift_isSmall","bitwise","fn","xSign","ySign","xRem","not","yRem","xDigit","yDigit","xDivMod","yDivMod","toJSNumber","String","shiftRight","remQuo","and","or","xor","LOBMASK_I","LOBMASK_BI","roughLOB","min","gcd","text","absBase","toLowerCase","test","charCodeAt","isNaN","digits","charCode","start","parseBaseFromArray","val","stringify","digit","charAt","toBase","apply","map","valueOf","neg","out","left","toBaseString","join","parseStringValue","decimalPlace","indexOf","parseNumberValue","toArray","str","toJSON","minusOne","lcm","isInstance","low","range","random","restricted","top","fromArray","BinaryUtils_1","IPNumType_1","IPv6Utils_1","IPv6Utils_2","Validator","[object Object]","ipNumber","lowerBound","upperBound","asnNumber","isValid","isWithinRange","THIRTY_TWO_BIT_SIZE","invalidAsnRangeMessage","SIXTEEN_BIT_SIZE","invalid16BitAsnRangeMessage","ipv4Number","invalidIPv4NumberMessage","ipv6Number","ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE","invalidIPv6NumberMessage","octetNumber","withinRange","EIGHT_BIT_SIZE","invalidOctetRangeMessage","hexadecatetNum","invalidHexadecatetMessage","ipv4String","rawOctets","includes","invalidOctetCountMessage","every","isNumeric","isValidIPv4Octet","ipv6String","hexadecimals","expandIPv6Number","invalidHexadecatetCountMessage","hexadecimal","isHexadecatet","isValidIPv6Hexadecatet","error","prefixValue","ipNumType","IPNumType","IPv4","invalidPrefixValueMessage","IPv6","invalidInetNumType","ipv4SubnetMaskString","ipv4InBinary","IPV4_SUBNET_MASK_BIT_PATTERN","invalidSubnetMaskMessage","ipv6SubnetMaskString","ipv6InBinary","hexadectetNotationToBinaryString","IPV6_SUBNET_MASK_BIT_PATTERN","ipv4RangeAsCidrString","cidrComponents","invalidIPv4CidrNotationMessage","ip","validIpv4","invalidIpv4Message","isValidIPv4String","validPrefix","invalidPrefixMessage","isValidPrefixValue","invalidMessage","ipv6RangeAsCidrString","IPV6_RANGE_PATTERN","invalidIPv6CidrNotationString","invalidBinaryStringErrorMessage","IPV4_PATTERN","RegExp","IPV4_RANGE_PATTERN","takeOutOfRangeSizeMessage","cannotSplitSingleRangeErrorMessage","HexadecimalUtils_1","expandWithZero","hexadecimalArray","leftPortion","rightPortion","leftPortionSplit","filter","rightPortionSplit","doublePortion","gapCount","pads","count","expandDoubleColon","leftString","rightString","collapseIPv6Number","contracted","hexidecimal","withoutLeadingZero","replace","hexadectetString","hexadecimalAsString","hexavalue","hexadecimalStringToBinaryString","Hexadecatet_1","Validator_1","AbstractIPNum_1","BinaryUtils_2","IPv4_1","BinaryUtils_3","AbstractIPNum","ipValue","super","bitSize","maximumBitSize","type","hexadecatet","separator","expandedIPv6","constructFromHexadecimalDottedString","constructFromBigIntegerValue","bigIntValue","ipString","ipBinaryString","validationResult","isValidBinaryString","paddedBinaryString","ipv4","toIPv4MappedIPv6","ip4DotDecimalString","fromBigInteger","getValue","message","isValidIPv6Number","msg","binaryStringToHexadecatets","isValidIPv6String","stringHexadecatet","Hexadecatet","fromString","binaryStringToHexadecimalString","match","Octet_1","BinaryUtils_4","IPv6_1","octets","constructFromDecimalDottedString","binary","toBinaryString","fromBinaryString","rawOctet","Octet","isValidIPv4Number","binaryStringToDecimalOctets","ipv4BinaryString","rawValue","givenValue","hexadecatetValue","bigIntegerNumberToHexadecimalString","hexadecimalString","anotherIPNum","IPv4SubnetMask","isValidIPv4SubnetMask","stringOctets","IPv6SubnetMask","isValidIPv6SubnetMask","stringHexadecimals","SubnetMask_1","SubnetMask_2","IPv4Prefix","onBits","offBits","fromDecimalDottedString","toDecimalNotation","bits","substr","IPv6Prefix","fromHexadecimalString","toHexadecatetNotation","octetValue","Prefix_1","IPv6Range","ipv6","cidrPrefix","bitValue","internalCounterValue","getFirst","rangeIncidrNotation","isValidIPv6CidrNotation","prefix","fromNumber","getLast","toSubnetMask","onMask","subnetMaskAsBigInteger","invertedSubnetMask","otherRange","thisFirst","thisLast","otherFirst","otherLast","hasNext","nextIPNumber","isEquals","isLessThanOrEquals","isGreaterThanOrEquals","isGreaterThan","isLessThan","iPv6s","iteratingIPv6","getSize","counter","prefixToSplit","splitCidr","firstIPOfFirstRange","firstRange","firstIPOfSecondRange","returnValue","done","iterator","IPv4Range","errorMessages","isValidIPv4CidrNotation","messages","subnetAsBigInteger","invertedSubnet","ipv4s","iteratingIPv4","errMessage","Asn","ASN","startWithASprefix","substring","parseFromDotNotation","valueAsBigInt","isValidAsnNumber","stringValue","AS_PREFIX","toASDotPlus","toASPlain","high","valid16BitAsnNumber","isValid16BitAsnNumber","is16Bit","word","values","webpackPolyfill","deprecate","paths","children","__export"],"mappings":"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","file":"../../ip-num.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 17);\n","import * as bigInt from \"big-integer/BigInteger\";\n\n/**\n * Converts a decimal number to binary string\n *\n * @param num number to parse\n * @returns {string} the binary string representation of number\n */\n\nexport let decimalNumberToBinaryString = (num:number):string => {\n    return Number(num).toString(2);\n};\n\n/**\n * Converts a given BigInteger number to a binary string\n * @param num the BigInteger number\n * @returns {string} the binary string\n */\nexport let bigIntegerNumberToBinaryString = (num: bigInt.BigInteger): string => {\n    return num.toString(2);\n};\n\n\n/**\n * Converts a decimal number to binary octet (8 bit) string. If needed the octet will be padded with zeros\n * to make it up to 8 bits\n *\n * @param {number} num to convert to octet string\n * @returns {string} the octet string representation of given number\n */\nexport let decimalNumberToOctetString = (num:number): string => {\n    let binaryString = decimalNumberToBinaryString(num);\n    let length = binaryString.length;\n    if (length > 8) {\n        throw new Error(\"Given decimal in binary contains digits greater than an octet\")\n    }\n    return leftPadWithZeroBit(binaryString, 8);\n};\n\n/**\n * Parses number in binary to number in BigInteger\n *\n * @param num binary number in string to parse\n * @returns {number} binary number in BigInteger\n */\nexport let parseBinaryStringToBigInteger = (num:string): bigInt.BigInteger => {\n    return bigInt(num, 2);\n};\n\n/**\n * Given an IPv4 number in dot-decimal notated string, e.g 192.168.0.1 converts it to\n * binary string, e.g. '11000000101010000000000000000001'\n *\n * @param dottedDecimal IPv4 string in dot-decimal notation\n * @returns {string} the binary value of the given ipv4 number in string\n */\nexport let dottedDecimalNotationToBinaryString = (dottedDecimal: string): string => {\n    let stringOctets = dottedDecimal.split(\".\");\n    return stringOctets.reduce((binaryAsString, octet) => {\n        return binaryAsString.concat(decimalNumberToOctetString(parseInt(octet)));\n    }, '');\n};\n\n/**\n * Given a binary string, adds a number of zero to the left until string is as long as the given string length\n * @param {string} binaryString the string to pad\n * @param {number} finalStringLength the final length of string after padding\n * @returns {string}\n */\nexport let leftPadWithZeroBit = (binaryString: string, finalStringLength: number): string => {\n    if (binaryString.length > finalStringLength) {\n        throw new Error(`Given string is already longer than given final length after padding: ${finalStringLength}`);\n    }\n    return \"0\".repeat(finalStringLength - binaryString.length).concat(binaryString);\n};\n","var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        LOG_MAX_INT = Math.log(MAX_INT);\r\n\r\n    function Integer(v, radix) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 ? parseValue(v) : parseBase(v, radix);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a,b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n            if (isPrecise(a.value * this.value)) {\r\n                return new SmallInteger(a.value * this.value);\r\n            }\r\n            return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n            if (a.value === 0) return Integer[0];\r\n            if (a.value === 1) return this;\r\n            if (a.value === -1) return this.negate();\r\n            return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    function square(a) {\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < l; j++) {\r\n                a_j = a[j];\r\n                product = a_i * a_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        var value = n.value;\r\n        if (value === 0) return false;\r\n        if (value === 1) return true;\r\n        if (value === 2) return this.isEven();\r\n        return this.mod(n).equals(Integer[0]);\r\n    };\r\n    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(25)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    BigInteger.prototype.isPrime = function () {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs(),\r\n            nPrev = n.prev();\r\n        var a = [2, 3, 5, 7, 11, 13, 17, 19],\r\n            b = nPrev,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2);\r\n        for (i = 0; i < a.length; i++) {\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;\r\n            for (t = true, d = b; t && d.lesser(nPrev) ; d = d.multiply(2)) {\r\n                x = x.square().mod(n);\r\n                if (x.equals(nPrev)) t = false;\r\n            }\r\n            if (t) return false;\r\n        }\r\n        return true;\r\n    };\r\n    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        // use the Fermat primality test\r\n        for (var i = 0; i < t; i++) {\r\n            var a = bigInt.randBetween(2, n.minus(2));\r\n            if (!a.modPow(n.prev(), n).isUnit()) return false; // definitely composite\r\n        }\r\n        return true; // large chance of being prime\r\n    };\r\n    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.equals(bigInt.zero)) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.equals(1)) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return ((typeof n === \"number\" || typeof n === \"string\") && +Math.abs(n) <= BASE) ||\r\n            (n instanceof BigInteger && n.value.length <= 1);\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (n) {\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (n) {\r\n        var remQuo;\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero()) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value, x = typeof v === \"number\" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = Math.min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(Math.random() * range));\r\n        var length = range.value.length - 1;\r\n        var result = [], restricted = true;\r\n        for (var i = length; i >= 0; i--) {\r\n            var top = restricted ? range.value[i] : BASE;\r\n            var digit = truncate(Math.random() * top);\r\n            result.unshift(digit);\r\n            if (digit < top) restricted = false;\r\n        }\r\n        result = arrayToSmall(result);\r\n        return low.add(typeof result === \"number\" ? new SmallInteger(result) : new BigInteger(result, false));\r\n    }\r\n    var parseBase = function (text, base) {\r\n        var length = text.length;\r\n\t\tvar i;\r\n\t\tvar absBase = Math.abs(base);\r\n\t\tfor(var i = 0; i < length; i++) {\r\n\t\t\tvar c = text[i].toLowerCase();\r\n\t\t\tif(c === \"-\") continue;\r\n\t\t\tif(/[a-z0-9]/.test(c)) {\r\n\t\t\t    if(/[0-9]/.test(c) && +c >= absBase) {\r\n\t\t\t\t\tif(c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n\t\t\t\t} else if(c.charCodeAt(0) - 87 >= absBase) {\r\n\t\t\t\t\tthrow new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n        if (2 <= base && base <= 36) {\r\n            if (length <= LOG_MAX_INT / Math.log(base)) {\r\n\t\t\t\tvar result = parseInt(text, base);\r\n\t\t\t\tif(isNaN(result)) {\r\n\t\t\t\t\tthrow new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n\t\t\t\t}\r\n                return new SmallInteger(parseInt(text, base));\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i].toLowerCase(),\r\n                charCode = c.charCodeAt(0);\r\n            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));\r\n            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\");\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit) {\r\n        if (digit <= 35) {\r\n            return \"0123456789abcdefghijklmnopqrstuvwxyz\".charAt(digit);\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return {value: [0], isNegative: false};\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return {value: [0], isNegative: false};\r\n            if (n.isNegative())\r\n              return {\r\n                value: [].concat.apply([], Array.apply(null, Array(-n))\r\n                            .map(Array.prototype.valueOf, [1, 0])\r\n                          ),\r\n                isNegative: false\r\n              };\r\n\r\n            var arr = Array.apply(null, Array(+n - 1))\r\n              .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n              value: [].concat.apply([], arr),\r\n              isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.equals(1)) {\r\n            if (n.isZero()) return {value: [0], isNegative: false};\r\n            \r\n            return {\r\n              value: Array.apply(null, Array(+n))\r\n                       .map(Number.prototype.valueOf, 1),\r\n              isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return {value: out.reverse(), isNegative: neg};\r\n    }\r\n\r\n    function toBaseString(n, base) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(stringify).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n      return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n      return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix);\r\n        return String(this.value);\r\n    };\r\n    BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n\r\n    function parseStringValue(v) {\r\n            if (isPrecise(+v)) {\r\n                var x = +v;\r\n                if (x === truncate(x))\r\n                    return new SmallInteger(x);\r\n                throw \"Invalid integer: \" + v;\r\n            }\r\n            var sign = v[0] === \"-\";\r\n            if (sign) v = v.slice(1);\r\n            var split = v.split(/e/i);\r\n            if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n            if (split.length === 2) {\r\n                var exp = split[1];\r\n                if (exp[0] === \"+\") exp = exp.slice(1);\r\n                exp = +exp;\r\n                if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n                var text = split[0];\r\n                var decimalPlace = text.indexOf(\".\");\r\n                if (decimalPlace >= 0) {\r\n                    exp -= text.length - decimalPlace - 1;\r\n                    text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n                }\r\n                if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n                text += (new Array(exp + 1)).join(\"0\");\r\n                v = text;\r\n            }\r\n            var isValid = /^([0-9][0-9]*)$/.test(v);\r\n            if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n            var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n            while (max > 0) {\r\n                r.push(+v.slice(min, max));\r\n                min -= l;\r\n                if (min < 0) min = 0;\r\n                max -= l;\r\n            }\r\n            trim(r);\r\n            return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = new SmallInteger(i);\r\n        if (i > 0) Integer[-i] = new SmallInteger(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif ( typeof define === \"function\" && define.amd ) {\r\n  define( \"big-integer\", [], function() {\r\n    return bigInt;\r\n  });\r\n}\r\n","'use strict';\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport * as bigInt from \"big-integer\";\nimport {IPNumType} from \"./IPNumType\";\nimport {hexadectetNotationToBinaryString} from \"./IPv6Utils\";\nimport {expandIPv6Number} from \"./IPv6Utils\";\n\nexport class Validator {\n    static IPV4_PATTERN: RegExp = new RegExp(/^(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/);\n    static IPV4_RANGE_PATTERN: RegExp = new RegExp(/^(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\/)([1-9]|[1-2][0-9]|3[0-2])$/);\n    static IPV6_RANGE_PATTERN: RegExp = new RegExp(/^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8]))?$/);\n    static IPV4_SUBNET_MASK_BIT_PATTERN: RegExp = new RegExp(/^(1){0,32}(0){0,32}$/);\n    static IPV6_SUBNET_MASK_BIT_PATTERN: RegExp = new RegExp(/^(1){0,128}(0){0,128}$/);\n\n    static EIGHT_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(8), 2);\n    static SIXTEEN_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(16), 2);\n    static THIRTY_TWO_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(32), 2);\n    static ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(128), 2);\n\n    static invalidAsnRangeMessage = \"ASN number given less than zero or is greater than 32bit\";\n    static invalid16BitAsnRangeMessage = \"ASN number given less than zero or is greater than 16bit\";\n    static invalidIPv4NumberMessage = \"IPv4 number given less than zero or is greater than 32bit\";\n    static invalidIPv6NumberMessage = \"IPv6 number given less than zero or is greater than 128bit\";\n    static invalidOctetRangeMessage = \"Value given contains an invalid Octet; Value is less than zero or is greater than 8bit\";\n    static invalidHexadecatetMessage = \"The value given is less than zero or is greater than 16bit\";\n    static invalidOctetCountMessage = \"An IP4 number cannot have less or greater than 4 octets\";\n    static invalidHexadecatetCountMessage = \"An IP6 number must have exactly 8 hexadecatet\";\n    static invalidSubnetMaskMessage = \"The Subnet Mask is invalid\";\n    static invalidPrefixValueMessage = \"A Prefix value cannot be less than 0 or greater than 32\";\n    static invalidIPv4CidrNotationMessage = \"Cidr notation should be in the form [ip number]/[range]\";\n    static invalidIPv6CidrNotationString = \"A Cidr notation string should contain an IPv6 number and prefix\";\n    static takeOutOfRangeSizeMessage = \"$count is greater than $size, the size of the range\";\n    static cannotSplitSingleRangeErrorMessage = \"Cannot split an IP range with a single IP number\";\n    static invalidInetNumType = \"Given ipNumType must be either InetNumType.IPv4 or InetNumType.IPv6\";\n    static invalidBinaryStringErrorMessage = \"Binary string should contain only contiguous 1s and 0s\";\n\n    /**\n     * Checks if given ipNumber is in between the given lower and upper bound\n     *\n     * @param ipNumber ipNumber to check\n     * @param lowerBound lower bound\n     * @param upperBound upper bound\n     * @returns {boolean} true if ipNumber is between lower and upper bound\n     */\n    private static isWithinRange(ipNumber: bigInt.BigInteger, lowerBound: bigInt.BigInteger, upperBound: bigInt.BigInteger) : boolean {\n        return ipNumber.greaterOrEquals(lowerBound) && ipNumber.lesserOrEquals(upperBound);\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an ASN number\n     *\n     * @param asnNumber the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid ASN, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidAsnNumber(asnNumber: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = this.isWithinRange(asnNumber, bigInt.zero, this.THIRTY_TWO_BIT_SIZE);\n        return [isValid, isValid ? []: [Validator.invalidAsnRangeMessage]];\n    }\n\n    /**\n     * Checks if the given ASN number is a 16bit ASN number\n     *\n     * @param {bigInt.BigInteger} asnNumber to check if 16bit or not\n     * @returns {[boolean , string]} first value is true if valid 16bit ASN, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValid16BitAsnNumber(asnNumber: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = Validator.isWithinRange(asnNumber, bigInt.zero, Validator.SIXTEEN_BIT_SIZE);\n        return [isValid, isValid ? []: [Validator.invalid16BitAsnRangeMessage]];\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an IPv4 number\n     *\n     * @param ipv4Number the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid IPv4 number, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4Number(ipv4Number: bigInt.BigInteger): [boolean, string[]]  {\n        let isValid = this.isWithinRange(ipv4Number, bigInt.zero, this.THIRTY_TWO_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv4NumberMessage]];\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an IPv6 number\n     *\n     * @param ipv6Number the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid IPv6 number, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6Number(ipv6Number: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = this.isWithinRange(ipv6Number, bigInt.zero, this.ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv6NumberMessage]];\n    }\n\n    /**\n     * Checks if the number given is valid for an IPv4 octet\n     *\n     * @param octetNumber the octet value\n     * @returns {boolean} true if valid octet, false otherwise\n     */\n    static isValidIPv4Octet(octetNumber: bigInt.BigInteger): [boolean, string[]] {\n        let withinRange = this.isWithinRange(octetNumber, bigInt.zero, this.EIGHT_BIT_SIZE);\n        return [withinRange, withinRange ? []: [Validator.invalidOctetRangeMessage]];\n    }\n\n    /**\n     * Checks if the number given is valid for an IPv6 hexadecatet\n     *\n     * @param {bigInt.BigInteger} hexadecatetNum the hexadecatet value\n     * @returns {[boolean , string]} first value is true if valid hexadecatet, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6Hexadecatet(hexadecatetNum: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = this.isWithinRange(hexadecatetNum, bigInt.zero, this.SIXTEEN_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidHexadecatetMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv4 value.\n     *\n     * @param {string} ipv4String the IPv4 string to validate\n     * @returns {[boolean , string]} result of validation, first value represents if is valid IPv4, second value\n     * contains error message if invalid IPv4\n     */\n    static isValidIPv4String(ipv4String: string): [boolean, string[]] {\n        let rawOctets = ipv4String.split(\".\");\n\n        if (rawOctets.length != 4 || rawOctets.includes('')) {\n            return [false, [Validator.invalidOctetCountMessage]];\n        }\n\n        let isValid = rawOctets.every(octet => {\n            return Validator.isNumeric(octet) ? Validator.isValidIPv4Octet(bigInt(octet))[0] : false;\n        });\n\n        return [isValid, isValid ? []: [Validator.invalidOctetRangeMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv6 value.\n     *\n     * @param {string} ipv6String the IPv6 string to validate\n     * @returns {[boolean , string]} result of validation, first value represents if is valid IPv6, second value\n     * contains error message if invalid IPv6\n     */\n    static isValidIPv6String(ipv6String: string): [boolean, string[]] {\n        try {\n            let hexadecimals = expandIPv6Number(ipv6String).split(\":\");\n            if (hexadecimals.length != 8 ) {\n                return [false, [Validator.invalidHexadecatetCountMessage]]\n            }\n\n            let isValid = hexadecimals.every(hexadecimal => {\n                return Validator.isHexadecatet(hexadecimal) ?\n                    Validator.isValidIPv6Hexadecatet(bigInt(parseInt(hexadecimal, 16)))[0] : false;\n            });\n\n            return [isValid, isValid? []: [Validator.invalidHexadecatetMessage]];\n        } catch (error) {\n            return [false, [error]]\n        }\n    }\n\n    /**\n     * Checks if given value is a valid prefix value\n     *\n     * @param prefixValue value to check\n     * @param ipNumType The type of IP number\n     * @returns {(boolean|string)[]} a tuple representing if valid or not and corresponding message\n     */\n    static isValidPrefixValue(prefixValue: number, ipNumType: IPNumType): [boolean, string[]] {\n        if (IPNumType.IPv4 === ipNumType) {\n            let withinRange = Validator.isWithinRange(bigInt(prefixValue), bigInt.zero, bigInt(32));\n            return [withinRange, withinRange ? []: [Validator.invalidPrefixValueMessage]];\n        }\n        if (IPNumType.IPv6 === ipNumType) {\n            let withinRange = Validator.isWithinRange(bigInt(prefixValue), bigInt.zero, bigInt(128));\n            return [withinRange, withinRange ? []: [Validator.invalidPrefixValueMessage]];\n        }\n        return [false, [Validator.invalidInetNumType]]\n    }\n\n    /**\n     * Checks if given string is a valid IPv4 subnet mask\n     *\n     * @param {string} ipv4SubnetMaskString the given IPv4 subnet mask string\n     * @returns {[boolean , string]} first value is true if valid IPv4 subnet mask string, false otherwise. Second value\n     * contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4SubnetMask(ipv4SubnetMaskString: string) : [boolean, string[]] {\n        let ipv4InBinary = dottedDecimalNotationToBinaryString(ipv4SubnetMaskString);\n        let isValid = Validator.IPV4_SUBNET_MASK_BIT_PATTERN.test(ipv4InBinary);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidSubnetMaskMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv6 subnet mask\n     *\n     * @param {string} ipv6SubnetMaskString the given IPv6 subnet mask string\n     * @returns {[boolean , string]} first value is true if valid IPv6 subnet mask string, false otherwise. Second value\n     * contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6SubnetMask(ipv6SubnetMaskString: string) : [boolean, string[]] {\n        let ipv6InBinary = hexadectetNotationToBinaryString(ipv6SubnetMaskString);\n        let isValid = Validator.IPV6_SUBNET_MASK_BIT_PATTERN.test(ipv6InBinary);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidSubnetMaskMessage]];\n    }\n\n    /**\n     * Checks if the given string is a valid IPv4 range in Cidr notation\n     *\n     * @param {string} ipv4RangeAsCidrString the IPv4 range in Cidr notation\n     *\n     * @returns {[boolean , string[]]} first value is true if valid IPv4 range in Cidr notation, false otherwise. Second\n     * value contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4CidrNotation(ipv4RangeAsCidrString: string): [boolean, string[]] {\n        let cidrComponents = ipv4RangeAsCidrString.split(\"/\");\n        if(cidrComponents.length !== 2 || (cidrComponents[0].length === 0 || cidrComponents[1].length === 0)) {\n            return [false, [Validator.invalidIPv4CidrNotationMessage]];\n        }\n\n        let ip = cidrComponents[0];\n        let range = cidrComponents[1];\n\n        if (isNaN(Number(range))) {\n            return [false, [Validator.invalidIPv4CidrNotationMessage]];\n        }\n\n        let [validIpv4, invalidIpv4Message] = Validator.isValidIPv4String(ip);\n        let [validPrefix, invalidPrefixMessage] = Validator.isValidPrefixValue(Number(range), IPNumType.IPv4);\n\n        let isValid = validIpv4 && validPrefix;\n        let invalidMessage = invalidIpv4Message.concat(invalidPrefixMessage);\n\n        return isValid ? [isValid, []]: [isValid, invalidMessage];\n    }\n\n    /**\n     * Checks if the given string is a valid IPv6 range in Cidr notation\n     *\n     * @param {string} ipv6RangeAsCidrString the IPv6 range in Cidr notation\n     *\n     * @returns {[boolean , string]} first value is true if valid IPv6 range in Cidr notation, false otherwise.\n     * Second value contains \"valid\" or an error message when value is invalid\n     */\n    // TODO change to be like isValidIPv4CidrNotation where validation is done on the component of the cidr notation\n    // instead of a single regex check\n    static isValidIPv6CidrNotation(ipv6RangeAsCidrString: string): [boolean, string[]] {\n        let isValid = Validator.IPV6_RANGE_PATTERN.test(ipv6RangeAsCidrString);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv6CidrNotationString]];\n    }\n\n    /**\n     * Checks if the given string is a binary string. That is contains only contiguous 1s and 0s\n     *\n     * @param {string} binaryString the binary string\n     * @returns {(boolean|string)[]} a tuple representing if valid or not and corresponding message\n     */\n    static isValidBinaryString(binaryString: string): [boolean, string[]] {\n        if (/^([10])+$/.test(binaryString)) {\n            return [true, []]\n        } else {\n            return [false, [Validator.invalidBinaryStringErrorMessage]]\n        }\n    }\n\n    private static isNumeric(value: string): boolean {\n        return /^(\\d+)$/.test(value)\n    }\n\n    private static isHexadecatet(value: string): boolean {\n        return /^[0-9A-Fa-f]{4}$/.test(value)\n    }\n\n}\n\n","import {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {hexadecimalStringToBinaryString} from \"./HexadecimalUtils\";\n\n/**\n * Expands an IPv6 number in abbreviated format into its full form\n *\n * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more on the representation of IPv6 addresses\n *\n * @param {string} ipv6String the abbreviated IPv6 address to expand\n * @returns {string} the expanded IPv6 address\n */\nexport let expandIPv6Number = (ipv6String:string):string => {\n    let expandWithZero = (hexadecimalArray: string[]): string => {\n        let paddedArray = hexadecimalArray.map((hexadecimal) => {\n            return leftPadWithZeroBit(hexadecimal, 4);\n        });\n\n        return paddedArray.join(\":\")\n    };\n\n    let expandDoubleColon = (gapCount: number): string => {\n        let pads = [];\n        for (let count=0; count<gapCount; count++) {\n            pads.push(\"0000\");\n        }\n        return pads.join(\":\");\n    };\n\n    if (/(:){3,}/.test(ipv6String)) throw \"given IPv6 contains consecutive : more than two\";\n\n    if (ipv6String.includes(\"::\")) {\n        let split = ipv6String.split(\"::\");\n        let leftPortion = split[0];\n        let rightPortion = split[1];\n\n        let leftPortionSplit = leftPortion.split(\":\").filter(hexadecimal => {return hexadecimal !== \"\"});\n        let rightPortionSplit = rightPortion.split(\":\").filter(hexadecimal => {return hexadecimal !== \"\"});\n        let doublePortion = expandDoubleColon(8 - (leftPortionSplit.length + rightPortionSplit.length));\n\n\n        let leftString = expandWithZero(leftPortionSplit);\n        if (leftString !== \"\") {\n            leftString += \":\";\n        }\n\n\n        let rightString = expandWithZero(rightPortionSplit);\n        if (rightString !== \"\") {\n            rightString = \":\"+rightString;\n        }\n\n        return `${leftString}${doublePortion}${rightString}`;\n\n    } else {\n        return expandWithZero(ipv6String.split(\":\"));\n    }\n};\n\n\n/**\n * Collapses an IPv6 number in full format into its abbreviated form\n *\n * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more on the representation of IPv6 addresses\n *\n * @param {string} ipv6String the full form IPv6 number to collapse\n * @returns {string} the collapsed IPv6 number\n */\nexport let collapseIPv6Number = (ipv6String:string):string => {\n    let hexadecimals: string[] = ipv6String.split(\":\");\n    let hexadecimalsWithoutLeadingZeros = hexadecimals.map((hexidecimal) => {\n       let withoutLeadingZero = hexidecimal.replace(/^0+/, '');\n       if (withoutLeadingZero !== '') {\n           return withoutLeadingZero;\n       } else {\n           return \"0\";\n       }\n\n    });\n    let contracted = hexadecimalsWithoutLeadingZeros.join(\":\").replace(/(^0)?(:0){2,}/, ':');\n    if (contracted.slice(-1) === \":\") {\n        return `${contracted}:`;\n    }\n    return contracted;\n};\n\n\n/**\n * Converts a given IPv6 number expressed in the hexadecimal string notation into a 16 bit binary number in string\n * @param {string} hexadectetString the IPv6 number\n * @returns {string} the IPv6 number converted to binary string\n */\nexport let hexadectetNotationToBinaryString = (hexadectetString: string): string => {\n    let expand = expandIPv6Number(hexadectetString);\n    let hexadecimals = expand.split(\":\");\n    return hexadecimals.reduce((hexadecimalAsString, hexavalue) => {\n        return hexadecimalAsString.concat(leftPadWithZeroBit(hexadecimalStringToBinaryString(hexavalue),16));\n    }, '');\n};","export enum IPNumType {\n    ASN,\n    IPv4,\n    IPv6\n}","import {IPNumber} from \"./interface/IPNumber\";\nimport {Hexadecatet} from \"./Hexadecatet\";\nimport {Validator} from \"./Validator\";\nimport {bigIntegerNumberToBinaryString} from \"./BinaryUtils\";\nimport {binaryStringToHexadecimalString} from \"./HexadecimalUtils\";\nimport {expandIPv6Number} from \"./IPv6Utils\";\nimport {hexadectetNotationToBinaryString} from \"./IPv6Utils\";\nimport * as bigInt from \"big-integer/BigInteger\";\nimport {AbstractIPNum} from \"./AbstractIPNum\";\nimport {IPNumType} from \"./IPNumType\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {IPv4} from \"./IPv4\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\n\n\n/**\n * Represents an IPv6 number. A 128 bit number that is used to uniquely identify a device that is part of a computer\n * network that uses the internet protocol for communication.\n *\n * @see https://en.wikipedia.org/wiki/IPv6\n * @see https://www.rfc-editor.org/info/rfc8200\n */\nexport class IPv6 extends AbstractIPNum implements IPNumber {\n    /**\n     * The decimal value represented by the IPv6 number in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the IPv6 number\n     */\n    readonly bitSize: number = 128;\n    /**\n     * The maximum bit size (i.e. binary value) of the IPv6 number in BigInteger\n     */\n    readonly maximumBitSize: bigInt.BigInteger = Validator.ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE;\n    /**\n     * The type of IP number. Value is one of the values of the {@link IPNumType} enum\n     * @type {IPNumType} the type of IP number\n     */\n    readonly type: IPNumType = IPNumType.IPv6;\n    /**\n     * An array of {@link Hexadecatet}'s\n     *\n     * @type {Array} the hexadecatet that makes up the IPv6 number\n     */\n    readonly hexadecatet: Array<Hexadecatet> = [];\n\n    /**\n     * The string character used to separate the individual hexadecatet when the IPv6 is rendered as strings\n     *\n     * @type {string} The string character used to separate the individual hexadecatet when rendered as strings\n     */\n    readonly separator: string = \":\";\n\n    /**\n     * A convenience method for creating an {@link IPv6} by providing the decimal value of the IP number in BigInteger\n     *\n     * @param {bigInt.BigInteger} bigIntValue the decimal value of the IP number in BigInteger\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromBigInteger(bigIntValue: bigInt.BigInteger): IPv6 {\n        return new IPv6(bigIntValue);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv6} by providing the IP number in hexadecatet notation. E.g\n     * \"2001:800:0:0:0:0:0:2002\"\n     *\n     * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more information on hexadecatet notation.\n     *\n     * @param {string} ipString the IP number in hexadecatet\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromHexadecimalString(ipString: string) : IPv6 {\n        return new IPv6(ipString);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv6} from binary string\n     *\n     * @param {string} ipBinaryString the binary string representing the IPv6 number to be created\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromBinaryString(ipBinaryString: string) : IPv6 {\n        let validationResult = Validator.isValidBinaryString(ipBinaryString);\n        if (validationResult[0]) {\n            let paddedBinaryString = leftPadWithZeroBit(ipBinaryString, 128);\n            return new IPv6(parseBinaryStringToBigInteger(paddedBinaryString));\n        } else {\n            throw Error(validationResult[1].join(','))\n        }\n    }\n\n    /**\n     * A convenience method for creating an IPv4-Compatible {@link IPv6} Address from an instance of {@link IPv4}\n     *\n     * @param {IPv4} ipv4 to create an IPv4-Compatible {@link IPv6} Address\n     * @returns {IPv6} the IPv4-Compatible {@link IPv6} Address\n     */\n    static fromIPv4(ipv4: IPv4): IPv6 {\n        return ipv4.toIPv4MappedIPv6();\n    }\n\n    /**\n     * A convenience method for creating an IPv4-Compatible {@link IPv6} Address from a IPv4 represented in\n     * dot-decimal notation i.e. 127.0.0.1\n     *\n     * @param {IPv4} ip4DotDecimalString string represented in a dot decimal string\n     * @returns {IPv6} the IPv4-Compatible {@link IPv6} Address\n     */\n    static fromIPv4DotDecimalString(ip4DotDecimalString: string): IPv6 {\n        return new IPv4(ip4DotDecimalString).toIPv4MappedIPv6();\n    }\n\n    /**\n     * Constructor for an IPv6 number.\n     *\n     * @param {string | bigInt.BigInteger} ipValue value to construct an IPv6 from. The given value can either be\n     * numeric or string. If a string is given then it needs to be in hexadecatet string notation\n     */\n    constructor(ipValue: string | bigInt.BigInteger) {\n        super();\n        if (typeof ipValue === \"string\" ) {\n            let expandedIPv6 = expandIPv6Number(ipValue);\n            let [value, hexadecatet] = this.constructFromHexadecimalDottedString(expandedIPv6);\n            this.value = value;\n            this.hexadecatet = hexadecatet;\n\n        } else {\n            let [value, hexadecatet] = this.constructFromBigIntegerValue(ipValue);\n            this.value = value;\n            this.hexadecatet = hexadecatet;\n        }\n    }\n\n    /**\n     * A string representation of the IPv6 number.\n     *\n     * @returns {string} The string representation of IPv6\n     */\n    public toString(): string {\n        let ipv6String = this.hexadecatet.map((value) => { return value.toString()}).join(\":\");\n        if (this.hexadecatet.length < 8) {\n            return \"::\" + ipv6String;\n        } else {\n            return ipv6String\n        }\n    }\n\n    /**\n     * Gets the individual {@link Hexadecatet} that makes up the IPv6 number\n     *\n     * @returns {Array<Hexadecatet>} The individual {@link Hexadecatet} that makes up the IPv6 number\n     */\n    //TODO maybe rename to something like getSegments? so it can be same with getOctet\n    public getHexadecatet():Array<Hexadecatet> {\n        return this.hexadecatet;\n    }\n\n    /**\n     * Returns the next IPv6 number\n     *\n     * @returns {IPv6} the next IPv6 number\n     */\n    public nextIPNumber(): IPv6 {\n        return IPv6.fromBigInteger(this.getValue().add(1))\n    }\n\n    /**\n     * Returns the previous IPv6 number\n     *\n     * @returns {IPv6} the previous IPv6 number\n     */\n    public previousIPNumber(): IPv6 {\n        return IPv6.fromBigInteger(this.getValue().minus(1))\n    }\n\n    private constructFromBigIntegerValue(ipv6Number: bigInt.BigInteger): [bigInt.BigInteger, Array<Hexadecatet>]  {\n        let [isValid, message] = Validator.isValidIPv6Number(ipv6Number);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let binaryString = bigIntegerNumberToBinaryString(ipv6Number);\n        return [ipv6Number, this.binaryStringToHexadecatets(binaryString)]\n    }\n\n    private constructFromHexadecimalDottedString(expandedIPv6: string): [bigInt.BigInteger, Array<Hexadecatet>] {\n        let [isValid, message] = Validator.isValidIPv6String(expandedIPv6);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringHexadecimals: string[] = expandedIPv6.split(\":\");\n        let hexadecatet: Hexadecatet[]  = stringHexadecimals.map((stringHexadecatet) => {\n            return Hexadecatet.fromString(stringHexadecatet);\n        });\n        let value = bigInt(hexadectetNotationToBinaryString(expandedIPv6), 2);\n        return [value, hexadecatet];\n    }\n\n    private binaryStringToHexadecatets(binaryString: string): Hexadecatet[] {\n        let hexadecimalString = binaryStringToHexadecimalString(binaryString);\n        let hexadecimalStrings: string[] = hexadecimalString.match(/.{1,4}/g)!;\n        return hexadecimalStrings.map((stringHexadecatet)=> {\n            return Hexadecatet.fromString(stringHexadecatet);\n        });\n    }\n}","import {Octet} from \"./Octet\";\nimport {Validator} from \"./Validator\";\nimport {IPNumber} from \"./interface/IPNumber\";\nimport * as bigInt from \"big-integer\"\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport {bigIntegerNumberToBinaryString} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {AbstractIPNum} from \"./AbstractIPNum\";\nimport {IPNumType} from \"./IPNumType\";\nimport {IPv6} from \"./IPv6\";\n\n/**\n * Represents an IPv4 number. A 32 bit number that is used to uniquely identify a device that is part of a computer\n * network that uses the internet protocol for communication.\n *\n * @see https://en.wikipedia.org/wiki/IPv4\n * @see https://www.rfc-editor.org/info/rfc791\n */\nexport class IPv4 extends AbstractIPNum implements IPNumber {\n    /**\n     * The decimal value represented by the IPv4 number in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the IPv4 number\n     */\n    readonly bitSize: number = 32;\n    /**\n     * The maximum bit size (i.e. binary value) of the IPv4 number in BigInteger\n     */\n    readonly maximumBitSize: bigInt.BigInteger = Validator.THIRTY_TWO_BIT_SIZE;\n    /**\n     * The type of IP number. Value is one of the values of the {@link IPNumType} enum\n     * @type {IPNumType} the type of IP number\n     */\n    readonly type: IPNumType = IPNumType.IPv4;\n    /**\n     * An array of {@link Octet}'s\n     *\n     * @type {Array} the octets that makes up the IPv4 number\n     */\n    readonly octets: Array<Octet> = [];\n\n    /**\n     * The string character used to separate the individual octets when the IPv4 is rendered as strings\n     *\n     * @type {string} The string character used to separate the individual octets when rendered as strings\n     */\n    readonly separator: string = \".\";\n\n    /**\n     * A convenience method for creating an {@link IPv4} by providing the decimal value of the IP number in BigInteger\n     *\n     * @param {bigInt.BigInteger} bigIntValue the decimal value of the IP number in BigInteger\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromBigInteger(bigIntValue: bigInt.BigInteger): IPv4 {\n        return new IPv4(bigIntValue);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv4} by providing the IP number in dot-decimal notation. E.g\n     * \"10.1.1.10\"\n     *\n     * {@see https://en.wikipedia.org/wiki/Dot-decimal_notation} for more information on dot-decimal notation.\n     *\n     * @param {string} ipString the IP number in dot-decimal notation\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromDecimalDottedString(ipString: string) : IPv4 {\n        return new IPv4(ipString);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv4} from binary string\n     *\n     * @param {string} ipBinaryString the binary string representing the IPv4 number to be created\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromBinaryString(ipBinaryString: string) : IPv4 {\n        let validationResult = Validator.isValidBinaryString(ipBinaryString);\n        if (validationResult[0]) {\n            return new IPv4(parseBinaryStringToBigInteger(ipBinaryString));\n        } else {\n            throw Error(validationResult[1].join(','))\n        }\n    }\n\n    /**\n     * Constructor for an IPv4 number.\n     *\n     * @param {string | bigInt.BigInteger} ipValue value to construct an IPv4 from. The given value can either be\n     * numeric or string. If a string is given then it needs to be in dot-decimal notation\n     */\n    constructor(ipValue: string | bigInt.BigInteger) {\n        super();\n        if (typeof ipValue === \"string\" ) {\n            let [value, octets] = this.constructFromDecimalDottedString(ipValue);\n            this.value = value;\n            this.octets = octets\n        } else {\n            let [value, octets] = this.constructFromBigIntegerValue(ipValue);\n            this.value = value;\n            this.octets = octets;\n        }\n    }\n\n    /**\n     * A string representation of the IPv4 number. The string representation is in dot-decimal notation\n     *\n     * @returns {string} The string representation in dot-decimal notation\n     */\n    public toString(): string {\n        return this.octets.map((value) => { return value.toString()}).join(this.separator);\n    }\n\n    /**\n     * Gets the individual {@link Octet} that makes up the IPv4 number\n     *\n     * @returns {Array<Octet>} The individual {@link Octet} that makes up the IPv4 number\n     */\n    public getOctets(): Array<Octet> {\n        return this.octets;\n    }\n\n    /**\n     * Returns the next IPv4 number\n     *\n     * @returns {IPv4} the next IPv4 number\n     */\n    public nextIPNumber(): IPv4 {\n        return IPv4.fromBigInteger(this.getValue().add(1))\n    }\n\n    /**\n     * Returns the previous IPv4 number\n     *\n     * @returns {IPv4} the previous IPv4 number\n     */\n    public previousIPNumber(): IPv4 {\n        return IPv4.fromBigInteger(this.getValue().minus(1))\n    }\n\n    /**\n     * Returns this IPv4 number as a IPv4-Mapped IPv6 Address\n     *\n     * The IPv4-Mapped IPv6 Address allows an IPv4 number to be embedded within an IPv6 number\n     *\n     * {@see https://tools.ietf.org/html/rfc4291#section-2.5.5} for more information on the IPv4-Mapped IPv6 Address\n     *\n     * @returns {IPv6} an IPv6 number with the IPv4 embedded within it\n     */\n    public toIPv4MappedIPv6(): IPv6 {\n        let binary = '1'.repeat(16) + this.toBinaryString();\n        return IPv6.fromBinaryString(binary);\n    }\n\n\n    private constructFromDecimalDottedString(ipString: string): [bigInt.BigInteger, Array<Octet>] {\n        let octets;\n        let value;\n        let [isValid, message] = Validator.isValidIPv4String(ipString);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let stringOctets = ipString.split(\".\");\n        octets = stringOctets.map((rawOctet) => {\n            return Octet.fromString(rawOctet)\n        });\n        value = bigInt(dottedDecimalNotationToBinaryString(ipString), 2);\n        return [value, octets]\n    }\n\n    private constructFromBigIntegerValue(ipv4Number: bigInt.BigInteger): [bigInt.BigInteger, Array<Octet>]  {\n        let [isValid, message] = Validator.isValidIPv4Number(ipv4Number);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let binaryString = bigIntegerNumberToBinaryString(ipv4Number);\n        return [ipv4Number, this.binaryStringToDecimalOctets(binaryString)]\n    }\n\n    private binaryStringToDecimalOctets(ipv4BinaryString: string): Array<Octet> {\n        if (ipv4BinaryString.length < 32) {\n            ipv4BinaryString = leftPadWithZeroBit(ipv4BinaryString, 32);\n        }\n        let octets: string[] = ipv4BinaryString.match(/.{1,8}/g)!;\n        return octets.map((octet) => {\n            return Octet.fromString(parseBinaryStringToBigInteger(octet).toString())\n        });\n    }\n}","import {Validator} from \"./Validator\";\nimport * as bigInt from \"big-integer\"\n\n/**\n * A base 16 (hexadecimal) representation of a 16 bit value.\n *\n * It consists of four (base 16) number.\n *\n * It is used to represents the components of an IPv6 address\n */\nexport class Hexadecatet {\n    private readonly value: number;\n\n    /**\n     * A convenience method for constructing an instance of {@link Hexadecatet} from a four (base 16) number\n     * representation of a 16bit value.\n     *\n     * @param {string} rawValue the four (base 16) number\n     * @returns {Hexadecatet} an instance of {@link Hexadecatet}\n     */\n    static fromString(rawValue:string):Hexadecatet {\n        return new Hexadecatet(rawValue);\n    };\n\n    /**\n     * A convenience method for constructing an instance of {@link Hexadecatet} from a decimal number representation\n     * of a 16 bit value\n     *\n     * @param {number} rawValue decimal number representation of a 16 bit value\n     * @returns {Hexadecatet} an instance of {@link Hexadecatet}\n     */\n    static fromNumber(rawValue:number):Hexadecatet {\n        return new Hexadecatet(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of {@link Hexadecatet}\n     *\n     * @param {string | number} givenValue a string or numeric value. If given value is a string then it should be a\n     * four (base 16) number representation of a 16bit value. If it is a number, then it should be a decimal number\n     * representation of a 16 bit value\n     */\n    constructor(givenValue: string | number) {\n        let hexadecatetValue: number;\n        if (typeof givenValue === 'string') {\n            hexadecatetValue = parseInt(givenValue, 16);\n        } else {\n            hexadecatetValue = parseInt(String(givenValue), 16);\n        }\n\n        let [isValid, message] = Validator.isValidIPv6Hexadecatet(bigInt(hexadecatetValue));\n\n        if (!isValid) {\n            throw Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = hexadecatetValue;\n    }\n\n    /**\n     * Returns the numeric value in base 10 (ie decimal)\n     *\n     * @returns {number} the numeric value in base 10 (ie decimal)\n     */\n    public getValue():number {\n        return this.value;\n    }\n\n    /**\n     * Returns the string representation of the base 16 representation of the value\n     * @returns {string} the string representation of the base 16 representation of the value\n     */\n    // TODO pad with a zero if digit is less than 4\n    public toString(): string {\n        return this.value.toString(16);\n    }\n}","import * as bigInt from \"big-integer/BigInteger\";\n\n/**\n * Converts a given BigInteger number to a hexadecimal string\n * @param num the BigInteger number\n * @returns {string} the hexadeciaml string\n */\nexport let bigIntegerNumberToHexadecimalString = (num: bigInt.BigInteger): string => {\n    return num.toString(16);\n};\n\n/**\n * Converts a number in hexadecimal (base 16) to binary string\n * @param {string} hexadecimalString the number in base 16\n * @returns {string} the number converted to base 2\n */\nexport let hexadecimalStringToBinaryString = (hexadecimalString: string) : string => {\n    let inDecimal = bigInt(hexadecimalString, 16);\n    return inDecimal.toString(2);\n};\n\n/**\n * Converts number in binary string to hexadecimal string\n * @param {string} num in binary string\n * @returns {string} num in hexadecimal string\n */\nexport let binaryStringToHexadecimalString = (num: string): string => {\n    // first convert to binary string to decimal (big Integer)\n    let inDecimal = bigInt(num, 2);\n    return inDecimal.toString(16);\n};","import * as bigInt from \"big-integer\"\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\n\n/**\n * Provides the implementation of functionality that are common to {@link IPNumber}'s\n */\nexport abstract class AbstractIPNum {\n    /**\n     * The decimal value represented by the IP number in BigInteger\n     */\n    abstract readonly value: bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the IP number\n     */\n    abstract readonly bitSize: number;\n    /**\n     * The maximum bit size (i.e. binary value) of the IP number in BigInteger\n     */\n    abstract readonly maximumBitSize: bigInt.BigInteger;\n\n    /**\n     * Gets the numeric value of an IP number as {@link BigInteger}\n     *\n     * @returns {bigInt.BigInteger} the numeric value of an IP number.\n     */\n    public getValue():bigInt.BigInteger {\n        return this.value;\n    }\n\n    /**\n     * Gets the binary string representation of an IP number.\n     *\n     * @returns {string} the string binary representation.\n     */\n    public toBinaryString(): string {\n        return leftPadWithZeroBit(this.value.toString(2), this.bitSize);\n    }\n\n    /**\n     * Checks if an IP number has a value greater than the present value\n     * @returns {boolean} true, if there is a value greater than the present value. Returns false otherwise.\n     */\n    hasNext():boolean {\n        return this.value.lesser(this.maximumBitSize);\n    }\n\n    /**\n     * Checks if an IP number has a value lesser than the present value\n     * @returns {boolean} true, if there is a value lesser than the present value. Returns false otherwise.\n     */\n    hasPrevious():boolean {\n        return this.value.greater(bigInt.zero);\n    }\n\n    /**\n     * Checks if the given IP number, is equals to the current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is equals\n     */\n    public isEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.equals(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is lesser than this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is less than this current one. False otherwise.\n     */\n    public isLessThan(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.lt(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is greater than this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is greater than this current one. False otherwise.\n     */\n    public isGreaterThan(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.gt(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is less than or equals to this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is less than or equals to this current one. False otherwise.\n     */\n    public isLessThanOrEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.lesserOrEquals(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is greater than or equals to this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} {boolean} true if the given IP number is greater than or equals to this current one. False\n     * otherwise.\n     */\n    public isGreaterThanOrEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.greaterOrEquals(anotherIPNum.value);\n    }\n}","import {Octet} from \"./Octet\";\nimport {Validator} from \"./Validator\";\nimport * as bigInt from \"big-integer\"\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport {Hexadecatet} from \"./Hexadecatet\";\nimport {hexadectetNotationToBinaryString} from \"./IPv6Utils\";\nimport {IPv4} from \"./IPv4\";\nimport {IPv6} from \"./IPv6\";\n\n/**\n * The IPv4SubnetMask can be seen as a specialized IPv4 number where, in a 32 bit number, starting from the left, you\n * have continuous bits turned on (with 1 value) followed by bits turned off (with 0 value). In networking, it is used\n * to demarcate which bits are used to identify a network, and the ones that are used to identify hosts on the network\n */\nexport class IPv4SubnetMask extends IPv4 {\n    /**\n     * An array of {@link Octet}'s\n     *\n     * @type {Array} the octets that makes up the IPv4SubnetMask\n     */\n    readonly octets: Array<Octet> = [];\n\n    /**\n     * The decimal value represented by the IPv4 subnet mask in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n\n    /**\n     * A convenience method for creating an instance of IPv4SubnetMask. The passed strings need to be a valid IPv4\n     * number in dot-decimal notation.\n     *\n     * @param {string} rawValue The passed string in dot-decimal notation\n     * @returns {IPv4SubnetMask} the instance of IPv4SubnetMask\n     */\n    static fromDecimalDottedString(rawValue:string):IPv4SubnetMask {\n        return new IPv4SubnetMask(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of IPv4SubnetMask.\n     * The passed strings need to be a valid IPv4 subnet mask number in dot-decimal notation.\n     *\n     * @param {string} ipString The passed string in dot-decimal notation\n     */\n    constructor(ipString: string) {\n        super(ipString);\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidIPv4SubnetMask(ipString);\n\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringOctets = ipString.split(\".\");\n        this.octets = stringOctets.map((rawOctet) => {\n            return Octet.fromString(rawOctet)\n        });\n        this.value = bigInt(dottedDecimalNotationToBinaryString(ipString), 2);\n    }\n}\n\n/**\n * The IPv6SubnetMask can be seen as a specialized IPv4 number where, in a 128 bit number, starting from the left,\n * you have continuous bits turned on (with 1 value) followed by bits turned off (with 0 value). In networking, it\n * is used to to demarcate which bits are used to identify a network, and the ones that are used to identify hosts\n * on the network\n */\nexport class IPv6SubnetMask extends IPv6 {\n    /**\n     * An array of {@link Hexadecatet}'s\n     *\n     * @type {Array} the hexadecatet that makes up the IPv6 number\n     */\n    readonly hexadecatet: Array<Hexadecatet> = [];\n\n    /**\n     * The decimal value represented by the IPv6 number in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n\n\n    /**\n     * A convenience method for creating an instance of IPv6SubnetMask.\n     * The passed strings need to be a valid IPv4 subnet mask number in dot-decimal notation.\n     *\n     * @param {string} rawValue The passed string in textual notation\n     * @returns {IPv6SubnetMask} the instance of IPv6SubnetMask\n     */\n    static fromHexadecimalString(rawValue:string):IPv6SubnetMask {\n        return new IPv6SubnetMask(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of IPv6SubnetMask.\n     * The passed strings need to be a valid IPv6 subnet mask number in dot-decimal notation\n     *\n     * @param {string} ipString The passed IPv6 string\n     */\n    constructor(ipString: string) {\n        super(ipString);\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidIPv6SubnetMask(ipString);\n\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringHexadecimals = ipString.split(\":\");\n        this.hexadecatet = stringHexadecimals.map((stringHexadecatet) => {\n            return Hexadecatet.fromString(stringHexadecatet)\n        });\n        this.value = bigInt(hexadectetNotationToBinaryString(ipString), 2);\n    }\n}","import {Validator} from \"./Validator\";\nimport {IPv4SubnetMask} from \"./SubnetMask\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {IPNumType} from \"./IPNumType\";\nimport {IPv6SubnetMask} from \"./SubnetMask\";\nimport {binaryStringToHexadecimalString} from \"./HexadecimalUtils\";\nimport {Hexadecatet} from \"./Hexadecatet\";\n\n/**\n * Represents the prefix portion in the CIDR notation for representing IP ranges\n *\n * The IPv4 prefix portion represents the subnet mask. It is the number of continuous bits turned on (with value 1)\n * counting from the left side of an 8 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing} for more information on CIDR\n */\nclass IPv4Prefix {\n    /**\n     * The decimal value of the 8bit number representing the prefix\n     */\n    value: number;\n\n    /**\n     * Convenience method for constructing an instance of IPv4 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv4 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv4 prefix\n     */\n    static fromNumber(rawValue:number):IPv4Prefix {\n        return new IPv4Prefix(rawValue);\n    };\n\n    /**\n     * Constructor for an instance of IPv4 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv4 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv4 prefix\n     */\n    constructor(rawValue: number) {\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidPrefixValue(rawValue, IPNumType.IPv4);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = rawValue;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix\n     *\n     * @returns {number} the decimal value of the IPv4 prefix\n     */\n    public getValue(): number {\n        return this.value;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix as string\n     * @returns {string} he decimal value of the IPv4 prefix as string\n     */\n    public toString(): string {\n        return this.value.toString();\n    }\n\n    /**\n     * Converts the IPv4 prefix to a {@link IPv4SubnetMask}\n     *\n     * The IPv4 Subnet mask is the representation of the prefix in the dot-decimal notation\n     *\n     * @returns {IPv4SubnetMask} the subnet mask representation of the prefix\n     */\n    public toSubnetMask(): IPv4SubnetMask {\n        let onBits = '1'.repeat(this.value);\n        let offBits = '0'.repeat(32 - this.value);\n        return IPv4SubnetMask.fromDecimalDottedString(this.toDecimalNotation(`${onBits}${offBits}`));\n    }\n\n    private toDecimalNotation(bits:string): string {\n        return `${parseBinaryStringToBigInteger(bits.substr(0,8))}.${parseBinaryStringToBigInteger(bits.substr(8,8))}.${parseBinaryStringToBigInteger(bits.substr(16,8))}.${parseBinaryStringToBigInteger(bits.substr(24,8))}`\n    }\n}\n\n/**\n * Represents the prefix portion in the CIDR notation for representing IP ranges\n *\n * The IPv6 prefix portion represents the subnet mask. It is the number of continuous bits turned on (with value 1)\n * counting from the left side of an 128 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing} for more information on CIDR\n */\nclass IPv6Prefix {\n    /**\n     * The decimal value of the 16bit number representing the prefix\n     */\n    value: number;\n\n    /**\n     * Convenience method for constructing an instance of IPv46 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv6 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv6 prefix\n     */\n    static fromNumber(rawValue:number):IPv6Prefix {\n        return new IPv6Prefix(rawValue);\n    };\n\n    /**\n     * Constructor for an instance of IPv6 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv6 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv6 prefix\n     */\n    constructor(rawValue: number) {\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidPrefixValue(rawValue, IPNumType.IPv6);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = rawValue;\n    }\n\n    /**\n     * Gets the decimal value of the IPv6 prefix\n     *\n     * @returns {number} the decimal value of the IPv6 prefix\n     */\n    public getValue(): number {\n        return this.value;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix as string\n     * @returns {string} he decimal value of the IPv4 prefix as string\n     */\n    public toString(): string {\n        return this.value.toString();\n    }\n\n    /**\n     * Converts the IPv6 prefix to a {@link IPv6SubnetMask}\n     *\n     * The IPv6 Subnet mask is the representation of the prefix in 8 groups of 16 bit values represented in hexadecimal\n     *\n     * @returns {IPv6SubnetMask} the subnet mask representation of the prefix\n     */\n    public toSubnetMask(): IPv6SubnetMask {\n        let onBits = '1'.repeat(this.value);\n        let offBits = '0'.repeat(128 - this.value);\n        return IPv6SubnetMask.fromHexadecimalString(this.toHexadecatetNotation(`${onBits}${offBits}`));\n    }\n\n    private toHexadecatetNotation(bits:string): string {\n        let binaryStrings: string[] = bits.match(/.{1,16}/g)!;\n        let hexadecimalStrings: Hexadecatet[] = binaryStrings.map((binaryString) => {\n            return Hexadecatet.fromString(binaryStringToHexadecimalString(binaryString));\n        });\n        return hexadecimalStrings.map((value) => { return value.toString()}).join(\":\");\n    }\n}\n\nexport {IPv4Prefix, IPv6Prefix}","import {Validator} from \"./Validator\"\nimport bigInt = require(\"big-integer\");\n\n/**\n * A binary representation of a 8 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Octet_(computing)} for more information on Octets\n *\n * An octet is used in the textual representation of an {@link IPv4} number, where the IP number value is divided\n * into 4 octets\n */\nexport class Octet {\n    private readonly value: number;\n\n    /**\n     * Convenience method for creating an Octet out of a string value representing the value of the octet\n     *\n     * @param {string} rawValue the octet value in string\n     * @returns {Octet} the Octet instance\n     */\n    static fromString(rawValue:string):Octet {\n        return new Octet(rawValue);\n    };\n\n    /**\n     * Convenience method for creating an Octet out of a numeric value representing the value of the octet\n     *\n     * @param {number} rawValue the octet value in number\n     * @returns {Octet} the Octet instance\n     */\n    static fromNumber(rawValue:number):Octet {\n        return new Octet(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of an Octet.\n     *\n     * The constructor parameter given could either be a string or number.\n     *\n     * If a string, it is the string representation of the numeric value of the octet\n     * If a number, it is the numeric representation of the value of the octet\n     *\n     * @param {string | number} givenValue value of the octet to be created.\n     */\n    constructor(givenValue: string | number) {\n        let octetValue: number;\n        if (typeof givenValue === 'string') {\n            octetValue = parseInt(givenValue);\n        } else {\n            octetValue = givenValue;\n        }\n        let [isValid, message] = Validator.isValidIPv4Octet(bigInt(octetValue));\n        if (!isValid) {\n            throw Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = octetValue;\n    }\n\n    /**\n     * Method to get the numeric value of the octet\n     *\n     * @returns {number} the numeric value of the octet\n     */\n    public getValue():number {\n        return this.value;\n    }\n\n    /**\n     * Returns a decimal representation of the value of the octet in string\n     *\n     * @returns {string} a decimal representation of the value of the octet in string\n     */\n    public toString(): string {\n        return this.value.toString(10);\n    }\n}","import {IPv6Prefix} from \"./Prefix\";\nimport {IPv6} from \"./IPv6\";\nimport * as bigInt from \"big-integer\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {Validator} from \"./Validator\";\nimport {IPRange} from \"./interface/IPRange\";\n\n/**\n * Represents a continuous segment of IPv6 number following the\n * classless inter-domain routing scheme for allocating IP addresses.\n *\n * @see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n */\n// TODO introduce an abstract class to share some of the logic between IPv4Range and IPv6Range\nexport class IPv6Range implements IPRange, IterableIterator<IPv6> {\n    private readonly bitValue: bigInt.BigInteger = bigInt(128);\n    private internalCounterValue: IPv6;\n\n    /**\n     * Convenience method for constructing an instance of an IPV6Range from an IP range represented in CIDR notation\n     *\n     * @param {string} rangeIncidrNotation the range of the IPv6 number in CIDR notation\n     * @returns {IPV6Range} the IPV6Range\n     */\n    static fromCidr(rangeIncidrNotation:string):IPv6Range {\n        let [isValid, message] = Validator.isValidIPv6CidrNotation(rangeIncidrNotation);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let cidrComponents: Array<string> = rangeIncidrNotation.split(\"/\");\n        let ipString = cidrComponents[0];\n        let prefix = parseInt(cidrComponents[1]);\n\n        return new IPv6Range(IPv6.fromHexadecimalString(ipString), IPv6Prefix.fromNumber(prefix));\n    };\n\n    /**\n     * Constructor for creating an instance of an IPv6 range.\n     *\n     * The arguments taken by the constructor is inspired by the CIDR notation which basically consists of the IP\n     * number and the prefix.\n     *\n     * @param {IPv6} IPv6 the IP number used to construct the range. By convention this is the first IP number in\n     * the range, but it could also be any IP number within the range\n     * @param {IPv6Prefix} cidrPrefix the prefix which is a representation of the number of bits used to mask the\n     * given IPv6 number in other to create the range\n     */\n    constructor(private readonly ipv6: IPv6, private readonly cidrPrefix: IPv6Prefix) {\n        this.internalCounterValue = this.getFirst();\n    }\n\n    /**\n     * Gets the size of IPv6 numbers contained within the IPv6 range\n     *\n     * @returns {bigInt.BigInteger} the amount of IPv6 numbers in the range\n     */\n    public getSize(): bigInt.BigInteger {\n        /**\n         * Using bitwise shit operation this will be\n         * 1 << (this.bitValue - this.prefix.getValue())\n         * Since left shift a number by x is equivalent to multiplying the number by the power x raised to 2\n         * 2 << 4 = 2 * (2 raised to 4)\n         */\n        return bigInt(2).pow(this.bitValue.minus(bigInt(this.cidrPrefix.getValue())));\n    }\n\n    /**\n     * Method that returns the IPv6 range in CIDR (Classless Inter-Domain Routing) notation.\n     *\n     * See {@link https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation} for more information\n     * on the Classless Inter-Domain Routing notation\n     *\n     * @returns {string} the IPv6 range in CIDR (Classless Inter-Domain Routing) notation\n     */\n    public toCidrString(): string {\n        return `${this.ipv6.toString()}/${this.cidrPrefix.toString()}`\n    }\n\n    /**\n     * Method that returns the IPv6 range in string notation where the first IPv6 number and last IPv6 number are\n     * separated by an hyphen. eg. \"2001:db8:0:0:0:0:0:0-2001:db8:0:ffff:ffff:ffff:ffff:ffff\"\n     *\n     * @returns {string} the range in [first IPv6 number] - [last IPv6 number] format\n     */\n    public toRangeString(): string {\n        return `${this.getFirst()}-${this.getLast()}`\n    }\n\n    /**\n     * Method that returns the first IPv6 number in the IPv6 range\n     *\n     * @returns {IPv6} the first IPv6 number in the IPv6 range\n     */\n    public getFirst(): IPv6 {\n        return IPv6.fromBigInteger(this.ipv6.getValue().and(this.cidrPrefix.toSubnetMask().getValue()));\n    }\n\n    /**\n     * Method that returns the last IPv6 number in the IPv6 range\n     *\n     * @returns {IPv6} the last IPv6 number in the IPv6 range\n     */\n    public getLast(): IPv6 {\n        let onMask = bigInt(\"1\".repeat(128), 2);\n        let subnetMaskAsBigInteger = this.cidrPrefix.toSubnetMask().getValue();\n        let invertedSubnetMask = leftPadWithZeroBit(subnetMaskAsBigInteger.xor(onMask).toString(2), 128);\n        return IPv6.fromBigInteger(this.ipv6.getValue().or(parseBinaryStringToBigInteger(invertedSubnetMask)));\n    }\n\n    /**\n     * Indicates whether the given IPv6 range is an adjacent range.\n     *\n     * An adjacent range being one where the end of the given range, when incremented by one marks the start of the\n     * other range. Or where the start of the given range, when decreased by one, marks the end of the other range\n     *\n     * @param {IPv6Range} otherRange the other IPv6 range to compare with\n     * @returns {boolean} true if the two IPv6 ranges are consecutive, false otherwise\n     */\n    // TODO move this to the IPRange interface?\n    public isConsecutive(otherRange: IPv6Range): boolean {\n        let thisFirst: IPv6 = this.getFirst();\n        let thisLast: IPv6 = this.getLast();\n        let otherFirst: IPv6 = otherRange.getFirst();\n        let otherLast: IPv6 = otherRange.getLast();\n\n        return (\n            thisLast.hasNext() && thisLast.nextIPNumber().isEquals(otherFirst)\n            ||\n            otherLast.hasNext() && otherLast.nextIPNumber().isEquals(thisFirst)\n        )\n    }\n\n    /**\n     * Indicates if the given IPv6 range is a subset.\n     *\n     * By a subset range, it means all the values of the given range are contained by this IPv6 range\n     *\n     * @param {IPv6Range} otherRange the other IPv6 range\n     * @returns {boolean} true if the other Ipv6 range is a subset. False otherwise.\n     */\n    // TODO move this to the IPRange interface?\n    public contains(otherRange: IPv6Range): boolean {\n        let thisFirst: IPv6 = this.getFirst();\n        let thisLast: IPv6 = this.getLast();\n        let otherFirst: IPv6 = otherRange.getFirst();\n        let otherLast: IPv6 = otherRange.getLast();\n\n        return (thisFirst.isLessThanOrEquals(otherFirst) && thisLast.isGreaterThanOrEquals(otherLast));\n    }\n\n    /**\n     * Indicate if the given range is a container range.\n     *\n     * By container range, it means all the IP number in this current range can be found within the given range.\n     *\n     * @param {IPv6Range} otherRange he other IPv6 range\n     * @returns {boolean} true if the other Ipv6 range is a container range. False otherwise.\n     */\n    // TODO move this to the IPRange interface?\n    public inside(otherRange: IPv6Range): boolean {\n        let thisFirst: IPv6 = this.getFirst();\n        let thisLast: IPv6 = this.getLast();\n        let otherFirst: IPv6 = otherRange.getFirst();\n        let otherLast: IPv6 = otherRange.getLast();\n\n        return (otherFirst.isLessThanOrEquals(thisFirst) && otherLast.isGreaterThanOrEquals(thisLast));\n    }\n\n    /**\n     * Checks if two IPv6 ranges overlap\n     * @param {IPv6Range} otherRange the other IPv6 range\n     * @returns {boolean} true if the ranges overlap, false otherwise\n     */\n    // TODO or confirm than normal ranges cannot overlap\n    public isOverlapping(otherRange: IPv6Range): boolean {\n        let thisFirst: IPv6 = this.getFirst();\n        let thisLast: IPv6 = this.getLast();\n        let otherFirst: IPv6 = otherRange.getFirst();\n        let otherLast: IPv6 = otherRange.getLast();\n\n        return (\n            thisLast.isGreaterThan(otherFirst) && thisLast.isLessThanOrEquals(otherLast) && thisFirst.isLessThan(otherFirst)\n            ||\n            otherLast.isGreaterThan(thisFirst) && otherLast.isLessThanOrEquals(thisLast) && otherFirst.isLessThan(otherFirst)\n        );\n    }\n\n    /**\n     * Method that takes IPv6 number from within an IPv6 range, starting from the first IPv6 number\n     *\n     * @param {number} count the amount of IPv6 number to take from the IPv6 range\n     * @returns {Array<IPv6>} an array of IPv6 number, taken from the IPv6 range\n     */\n    public take(count: number): Array<IPv6> {\n        let iPv6s: Array<IPv6>  = [this.getFirst()];\n        let iteratingIPv6 = this.getFirst();\n\n        if (bigInt(count).greater(this.getSize())) {\n            throw new Error(`${count} is greater than ${this.getSize()}, the size of the range`);\n        }\n\n        for (var counter = 0; counter < count - 1; counter++) {\n            iPv6s.push(iteratingIPv6.nextIPNumber());\n            iteratingIPv6 = iteratingIPv6.nextIPNumber();\n        }\n        return iPv6s;\n    }\n\n    /**\n     * Method that splits an IPv6 range into two halves\n     *\n     * @returns {Array<IPv6Range>} An array of two {@link IPv6Range}\n     */\n    public split() : Array<IPv6Range> {\n        let prefixToSplit = this.cidrPrefix.getValue();\n        if (prefixToSplit === 128) {\n            throw new Error(\"Cannot split an IP range with a single IP number\");\n        }\n        let splitCidr = IPv6Prefix.fromNumber(prefixToSplit + 1);\n        let firstIPOfFirstRange = this.getFirst();\n        let firstRange = new IPv6Range(firstIPOfFirstRange, splitCidr);\n        let firstIPOfSecondRange = firstRange.getLast().nextIPNumber();\n        let secondRange = new IPv6Range(firstIPOfSecondRange, splitCidr);\n        return [firstRange, secondRange];\n    }\n\n\n    next(value?: any): IteratorResult<IPv6>;\n    next(value?: any): IteratorResult<IPv6>;\n    next(value?: any) {\n        let returnValue = this.internalCounterValue;\n        this.internalCounterValue = this.internalCounterValue.nextIPNumber();\n\n        if (returnValue.isLessThanOrEquals(this.getLast())) {\n            return {\n                done:false,\n                value: returnValue\n            }\n        } else {\n            return {\n                done:true\n            }\n        }\n    }\n\n    [Symbol.iterator](): IterableIterator<IPv6> {\n        return this;\n    }\n}","import {IPv4} from \"./IPv4\";\nimport {IPv4Prefix} from \"./Prefix\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {Validator} from \"./Validator\";\nimport * as bigInt from \"big-integer\";\nimport {IPRange} from \"./interface/IPRange\";\n\n/**\n * Represents a continuous segment of IPv4 numbers following the\n * classless inter-domain routing scheme for allocating IP addresses.\n *\n * @see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n */\nexport class IPv4Range implements IPRange, IterableIterator<IPv4> {\n    private readonly bitValue: bigInt.BigInteger = bigInt(32);\n    private internalCounterValue: IPv4;\n\n    /**\n     * Convenience method for constructing an instance of an IPV4Range from an IP range represented in CIDR notation\n     *\n     * @param {string} rangeIncidrNotation the range of the IPv4 number in CIDR notation\n     * @returns {IPv4Range} the IPv4Range\n     */\n    // TODO introduce an abstract class to share some of the logic between IPv4Range and IPv6Range\n    static fromCidr(rangeIncidrNotation:string):IPv4Range {\n        let [isValid, errorMessages] = Validator.isValidIPv4CidrNotation(rangeIncidrNotation);\n        if (!isValid) {\n            let messages = errorMessages.filter(message => {return message !== ''});\n            throw new Error(messages.join(' and '));\n        }\n        let cidrComponents: Array<string> = rangeIncidrNotation.split(\"/\");\n        let ipString = cidrComponents[0];\n        let prefix = parseInt(cidrComponents[1]);\n        return new IPv4Range(IPv4.fromDecimalDottedString(ipString), IPv4Prefix.fromNumber(prefix));\n    };\n\n    /**\n     * Constructor for creating an instance of an IPv4 range.\n     *\n     * The arguments taken by the constructor is inspired by the CIDR notation which basically consists of the IP\n     * number and the prefix.\n     *\n     * @param {IPv4} ipv4 the IP number used to construct the range. By convention this is the first IP number in\n     * the range, but it could also be any IP number within the range\n     * @param {IPv4Prefix} cidrPrefix the prefix which is a representation of the number of bits used to mask the\n     * given IP number in other to create the range\n     */\n    constructor(private readonly ipv4: IPv4, private readonly cidrPrefix: IPv4Prefix) {\n        this.internalCounterValue = this.getFirst();\n    }\n\n    /**\n     * Gets the size of IPv4 numbers contained within the IPv4 range\n     *\n     * @returns {bigInt.BigInteger} the amount of IPv4 numbers in the range\n     */\n    public getSize(): bigInt.BigInteger {\n        /**\n         * Using bitwise shit operation this will be\n         * 1 << (this.bitValue - this.prefix.getValue())\n         * Since left shift a number by x is equivalent to multiplying the number by the power x raised to 2\n         * 2 << 4 = 2 * (2 raised to 4)\n          */\n        return bigInt(2).pow(this.bitValue.minus(bigInt(this.cidrPrefix.getValue())));\n    }\n\n    /**\n     * Method that returns the IPv4 range in CIDR (Classless Inter-Domain Routing) notation.\n     *\n     * See {@link https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation} for more information\n     * on the Classless Inter-Domain Routing notation\n     *\n     * @returns {string} the IPv4 range in CIDR (Classless Inter-Domain Routing) notation\n     */\n    public toCidrString(): string {\n        return `${this.ipv4.toString()}/${this.cidrPrefix.toString()}`\n    }\n\n    /**\n     * Method that returns the IPv4 range in string notation where the first IPv4 number and last IPv4 number are\n     * separated by an hyphen. eg. 192.198.0.0-192.198.0.255\n     *\n     * @returns {string} the range in [first IPv4 number] - [last IPv4 number] format\n     */\n    public toRangeString(): string {\n        return `${this.getFirst()}-${this.getLast()}`\n    }\n\n\n    /**\n     * Method that returns the first IPv4 number in the IPv4 range\n     *\n     * @returns {IPv4} the first IPv4 number in the IPv4 range\n     */\n    public getFirst(): IPv4 {\n        return IPv4.fromBigInteger(this.ipv4.getValue().and(this.cidrPrefix.toSubnetMask().getValue()));\n    }\n\n    /**\n     * Method that returns the last IPv4 number in the IPv4 range\n     *\n     * @returns {IPv4} the last IPv4 number in the IPv4 range\n     */\n    public getLast(): IPv4 {\n        let onMask = bigInt(\"1\".repeat(32), 2);\n        let subnetAsBigInteger = this.cidrPrefix.toSubnetMask().getValue();\n        let invertedSubnet = leftPadWithZeroBit(subnetAsBigInteger.xor(onMask).toString(2), 32);\n        return IPv4.fromBigInteger(this.ipv4.getValue().or(parseBinaryStringToBigInteger(invertedSubnet)));\n    }\n\n    /**\n     * Indicates whether the given IPv4 range is an adjacent range.\n     *\n     * An adjacent range being one where the end of the given range, when incremented by one marks the start of the\n     * other range. Or where the start of the given range, when decreased by one, marks the end of the other range\n     *\n     * @param {IPv4Range} otherRange the other IPv4 range to compare with\n     * @returns {boolean} true if the two IPv4 ranges are consecutive, false otherwise\n     */\n    // TODO move this to the IPRange interface?\n    public isConsecutive(otherRange: IPv4Range): boolean {\n        let thisFirst: IPv4 = this.getFirst();\n        let thisLast: IPv4 = this.getLast();\n        let otherFirst: IPv4 = otherRange.getFirst();\n        let otherLast: IPv4 = otherRange.getLast();\n\n        return (\n            thisLast.hasNext() && thisLast.nextIPNumber().isEquals(otherFirst)\n            ||\n            otherLast.hasNext() && otherLast.nextIPNumber().isEquals(thisFirst)\n        )\n    }\n\n    /**\n     * Indicates if the given IPv4 range is a subset.\n     *\n     * By a subset range, it means all the values of the given range are contained by this IPv4 range\n     *\n     * @param {IPv4Range} otherRange the other IPv4 range\n     * @returns {boolean} true if the other Ipv4 range is a subset. False otherwise.\n     */\n    // TODO move this to the IPRange interface?\n    public contains(otherRange: IPv4Range): boolean {\n        let thisFirst: IPv4 = this.getFirst();\n        let thisLast: IPv4 = this.getLast();\n        let otherFirst: IPv4 = otherRange.getFirst();\n        let otherLast: IPv4 = otherRange.getLast();\n\n        return (thisFirst.isLessThanOrEquals(otherFirst) && thisLast.isGreaterThanOrEquals(otherLast));\n    }\n\n    /**\n     * Indicate if the given range is a container range.\n     *\n     * By container range, it means all the IP number in this current range can be found within the given range.\n     *\n     * @param {IPv4Range} otherRange he other IPv4 range\n     * @returns {boolean} true if the other Ipv4 range is a container range. False otherwise.\n     */\n    public inside(otherRange: IPv4Range): boolean {\n        let thisFirst: IPv4 = this.getFirst();\n        let thisLast: IPv4 = this.getLast();\n        let otherFirst: IPv4 = otherRange.getFirst();\n        let otherLast: IPv4 = otherRange.getLast();\n\n        return (otherFirst.isLessThanOrEquals(thisFirst) && otherLast.isGreaterThanOrEquals(thisLast));\n    }\n\n    /**\n     * Checks if two IPv4 ranges overlap\n     * @param {IPv4Range} otherRange the other IPv4 range\n     * @returns {boolean} true if the ranges overlap, false otherwise\n     */\n    // TODO or confirm than normal ranges cannot overlap\n    public isOverlapping(otherRange: IPv4Range): boolean {\n        let thisFirst: IPv4 = this.getFirst();\n        let thisLast: IPv4 = this.getLast();\n        let otherFirst: IPv4 = otherRange.getFirst();\n        let otherLast: IPv4 = otherRange.getLast();\n\n        return (\n            thisLast.isGreaterThan(otherFirst) && thisLast.isLessThanOrEquals(otherLast) && thisFirst.isLessThan(otherFirst)\n            ||\n            otherLast.isGreaterThan(thisFirst) && otherLast.isLessThanOrEquals(thisLast) && otherFirst.isLessThan(otherFirst)\n        );\n    }\n\n    /**\n     * Method that takes IPv4 number from within an IPv4 range, starting from the first IPv4 number\n     *\n     * @param {number} count the amount of IPv4 number to take from the IPv4 range\n     * @returns {Array<IPv4>} an array of IPv4 number, taken from the IPv4 range\n     */\n    public take(count: number): Array<IPv4> {\n        let ipv4s: Array<IPv4>  = [this.getFirst()];\n        let iteratingIPv4 = this.getFirst();\n\n        if (bigInt(count).greater(this.getSize())) {\n            let errMessage = Validator.takeOutOfRangeSizeMessage\n                .replace(\"$count\", count.toString())\n                .replace(\"$size\", this.getSize().toString());\n            throw new Error(errMessage);\n        }\n\n        for (var counter = 0; counter < count - 1; counter++) {\n            ipv4s.push(iteratingIPv4.nextIPNumber());\n            iteratingIPv4 = iteratingIPv4.nextIPNumber();\n        }\n        return ipv4s;\n    }\n\n    /**\n     * Method that splits an IPv4 range into two halves\n     *\n     * @returns {Array<IPv4Range>} An array of two {@link IPv4Range}\n     */\n    public split() : Array<IPv4Range> {\n        let prefixToSplit = this.cidrPrefix.getValue();\n        if (prefixToSplit === 32) {\n            throw new Error(\"Cannot split an IP range with a single IP number\");\n        }\n        let splitCidr = IPv4Prefix.fromNumber(prefixToSplit + 1);\n        let firstIPOfFirstRange = this.getFirst();\n        let firstRange = new IPv4Range(firstIPOfFirstRange, splitCidr);\n        let firstIPOfSecondRange = firstRange.getLast().nextIPNumber();\n        let secondRange = new IPv4Range(firstIPOfSecondRange, splitCidr);\n        return [firstRange, secondRange];\n    }\n\n    next(value?: any): IteratorResult<IPv4>;\n    next(value?: any): IteratorResult<IPv4>;\n    next(value?: any) {\n        let returnValue = this.internalCounterValue;\n        this.internalCounterValue = this.internalCounterValue.nextIPNumber();\n\n        if (returnValue.isLessThanOrEquals(this.getLast())) {\n            return {\n                done:false,\n                value: returnValue\n            }\n        } else {\n            return {\n                done:true\n            }\n        }\n    }\n\n    [Symbol.iterator](): IterableIterator<IPv4> {\n        return this;\n    }\n}","import {Validator} from \"./Validator\"\nimport {IPNumber} from \"./interface/IPNumber\"\nimport {decimalNumberToBinaryString} from \"./BinaryUtils\";\nimport * as bigInt from \"big-integer\"\nimport {IPNumType} from \"./IPNumType\";\nimport {AbstractIPNum} from \"./AbstractIPNum\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\n\n/**\n * Represents an Autonomous System Number. Which is a number that is used to identify\n * a group of IP addresses with a common, clearly defined routing policy.\n *\n * @see https://en.wikipedia.org/wiki/Autonomous_system_(Internet)\n * @see https://www.rfc-editor.org/info/rfc4271\n */\nexport class Asn extends AbstractIPNum implements IPNumber {\n    /**\n     * The decimal value represented by the ASN number in BigInteger\n     */\n    readonly value:bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the ASN number\n     */\n    bitSize: number = 32;\n    /**\n     * The maximum bit size (i.e. binary value) of the ASN number in BigInteger\n     */\n    maximumBitSize: bigInt.BigInteger = Validator.THIRTY_TWO_BIT_SIZE;\n\n    type: IPNumType = IPNumType.ASN;\n    private static AS_PREFIX = \"AS\";\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a string\n     *\n     * The given string can be in asplain, asdot or asdot+ representation format.\n     * {@see https://tools.ietf.org/html/rfc5396} for more information on\n     * the different ASN string representation\n     *\n     * @param {string} rawValue the asn string. In either asplain, asdot or asdot+ format\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromString(rawValue:string):Asn {\n        return new Asn(rawValue);\n    };\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a numeric value\n     *\n     * @param {number} rawValue the asn numeric value\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromNumber(rawValue:number):Asn {\n        return new Asn(rawValue);\n    };\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a binary string\n     *\n     * @param {string} binaryString to create an ASN instance from\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromBinaryString(binaryString: string): Asn {\n        let validationResult = Validator.isValidBinaryString(binaryString);\n        if (validationResult[0]) {\n            return new Asn(parseInt(binaryString, 2))\n        } else {\n            throw Error(validationResult[1].join(','))\n        }\n    }\n\n    /**\n     * Constructor for an instance of {@link ASN}\n     *\n     * @param {string | number} rawValue value to construct an ASN from. The given value can either be numeric or\n     * string. If in string then it can be in asplain, asdot or asdot+ string representation format\n     */\n    constructor(rawValue:string | number) {\n        super();\n        if (typeof rawValue === 'string') {\n            if (Asn.startWithASprefix(rawValue)) {\n                this.value = bigInt(parseInt(rawValue.substring(2)));\n            } else if(rawValue.indexOf(\".\") != -1) {\n                this.value = bigInt(this.parseFromDotNotation(rawValue));\n            } else {\n                this.value = bigInt(parseInt(rawValue));\n            }\n        } else {\n            let valueAsBigInt = bigInt(rawValue);\n            let [isValid, message] = Validator.isValidAsnNumber(valueAsBigInt);\n            if (!isValid) {\n                throw Error(message.filter(msg => {return msg !== '';}).toString());\n            }\n            this.value = valueAsBigInt;\n        }\n    }\n\n    /**\n     * A string representation where the asn value is prefixed by \"ASN\". For example \"AS65526\"\n     *\n     * @returns {string} A string representation where the asn value is prefixed by \"ASN\"\n     */\n    toString():string {\n        let stringValue = this.value.toString();\n        return `${Asn.AS_PREFIX}${stringValue}`;\n    }\n\n    /**\n     * A string representation where the ASN numeric value of is represented as a string. For example \"65526\"\n     *\n     * @returns {string} A string representation where the ASN numeric value of is represented as a string\n     */\n    toASPlain():string {\n        return this.value.toString();\n    }\n\n    /**\n     * A string representation where the ASN value is represented using the asplain notation if the ASN value is\n     * less than 65536 and uses asdot+ notation when the value is greater than 65536.\n     *\n     * For example 65526 will be represented as \"65526\" while 65546 will be represented as \"1.10\"\n     *\n     *\n     * @returns {string} A string representation of the ASN in either asplain or asdot+ notation depending on\n     * whether the numeric value of the ASN number is greater than 65526 or not.\n     */\n    toASDot():string {\n        if (this.value.valueOf() >= 65536) {\n            return this.toASDotPlus();\n        }\n        return this.toASPlain();\n    }\n\n    /**\n     * A string representation where the ASN value is represented using the asdot+ notation\n     *\n     * @returns {string} A string representation where the ASN value is represented using the asdot+ notation\n     *\n     */\n    toASDotPlus():string {\n        let high = Math.floor(this.value.valueOf() / 65535);\n        let low = (this.value.valueOf() % 65535) - high;\n        return `${high}.${low}`;\n    }\n\n    /**\n     * Converts the ASN value to binary numbers represented with strings\n     *\n     * @returns {string} a binary string representation of the value of the ASN number\n     */\n    toBinaryString():string {\n        return decimalNumberToBinaryString(this.value.valueOf());\n    }\n\n    /**\n     * Checks if the ASN value is 16bit\n     *\n     * @returns {boolean} true if the ASN is a 16bit value. False otherwise.\n     */\n    is16Bit():boolean {\n        let [valid16BitAsnNumber,] = Validator.isValid16BitAsnNumber(this.value);\n        return valid16BitAsnNumber;\n    }\n\n    /**\n     * Checks if the ASN value is 32bit\n     *\n     * @returns {boolean} true if the ASN is a 32bit value. False otherwise.\n     */\n    is32Bit():boolean {\n        return !this.is16Bit();\n    }\n\n    /**\n     * Returns the next ASN number\n     *\n     * @returns {IPNumber} the next ASN number\n     */\n    nextIPNumber(): IPNumber {\n        return new Asn(this.value.valueOf() + 1);\n    }\n\n    /**\n     * Returns the previous ASN number\n     *\n     * @returns {IPNumber} the previous ASN number\n     */\n    previousIPNumber(): IPNumber {\n        return new Asn(this.value.valueOf() - 1)\n    }\n\n    private static startWithASprefix(word:string):boolean {\n        return word.indexOf(Asn.AS_PREFIX) === 0;\n    }\n\n    private parseFromDotNotation(rawValue: string): number {\n        let values: string[] = rawValue.split(\".\");\n        let high = parseInt(values[0]);\n        let low = parseInt(values[1]);\n        return (high * 65535) + (low + high);\n    }\n}","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/**\n * Exposes all the library's modules making them available from the \"ip-num\" module.\n * Making it possible to get access to all any of the modules by doing require(\"ip-num\")\n *\n * @example\n * let ipNum = require(\"ip-num\")\n * ipNum.IPv4Range // gets access to IPv4Range\n * ipNum.Asn // gets access to Asn\n */\nexport * from './interface/IPNumber'\nexport * from './interface/IPRange'\nexport * from './AbstractIPNum'\nexport * from './Asn'\nexport * from './BinaryUtils'\nexport * from './Hexadecatet'\nexport * from './HexadecimalUtils'\nexport * from './IPNumType'\nexport * from './IPv4'\nexport * from './IPv4Range'\nexport * from './IPv6'\nexport * from './IPv6Range'\nexport * from './IPv6Utils'\nexport * from './Octet'\nexport * from './Prefix'\nexport * from './SubnetMask'\nexport * from './Validator'"],"sourceRoot":""}