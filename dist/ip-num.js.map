{"version":3,"sources":["webpack://ipnum/webpack/bootstrap","webpack://ipnum/./src/BinaryUtils.ts","webpack://ipnum/./node_modules/big-integer/BigInteger.js","webpack://ipnum/./src/Validator.ts","webpack://ipnum/./src/IPv6Utils.ts","webpack://ipnum/./src/IPNumType.ts","webpack://ipnum/./src/Prefix.ts","webpack://ipnum/./src/HexadecimalUtils.ts","webpack://ipnum/./src/IPv6.ts","webpack://ipnum/./src/IPv4.ts","webpack://ipnum/./src/Hexadecatet.ts","webpack://ipnum/./src/AbstractIPNum.ts","webpack://ipnum/./src/Octet.ts","webpack://ipnum/./src/SubnetMask.ts","webpack://ipnum/./src/AbstractIpRange.ts","webpack://ipnum/./src/IPv6CidrRange.ts","webpack://ipnum/./src/IPv4CidrRange.ts","webpack://ipnum/./src/Asn.ts","webpack://ipnum/(webpack)/buildin/module.js","webpack://ipnum/./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","bigInt","decimalNumberToBinaryString","num","Number","toString","bigIntegerNumberToBinaryString","decimalNumberToOctetString","binaryString","length","Error","leftPadWithZeroBit","parseBinaryStringToBigInteger","dottedDecimalNotationToBinaryString","dottedDecimal","split","reduce","binaryAsString","octet","concat","parseInt","finalStringLength","repeat","__WEBPACK_AMD_DEFINE_RESULT__","undefined","BASE","LOG_BASE","MAX_INT","MAX_INT_ARR","smallToArray","LOG_MAX_INT","Math","log","Integer","v","radix","parseValue","parseBase","BigInteger","sign","this","isSmall","SmallInteger","isPrecise","floor","arrayToSmall","arr","trim","compareAbs","createArray","x","Array","truncate","ceil","add","a","b","sum","l_a","l_b","carry","base","push","addAny","addSmall","subtract","difference","a_l","b_l","borrow","subtractSmall","multiplyLong","product","a_i","j","multiplySmall","shiftLeft","multiplySmallAndArray","square","divModSmall","lambda","q","remainder","divisor","quotient","divModAny","self","negate","abs","comparison","quotientDigit","shift","result","divisorMostSignificantDigit","divMod1","guess","xlen","highx","highy","check","part","unshift","reverse","divMod2","qSign","mod","mSign","isBasicPrime","isUnit","equals","isEven","isDivisibleBy","lesser","plus","subtractAny","minus","small","multiply","l1","l2","useKaratsuba","multiplyKaratsuba","y","max","slice","ac","bd","times","_multiplyBySmall","divmod","divide","over","pow","modPow","exp","isZero","isPositive","isOdd","compare","Infinity","compareTo","eq","notEquals","neq","greater","gt","lt","greaterOrEquals","geq","lesserOrEquals","leq","isNegative","isPrime","nPrev","prev","isProbablePrime","iterations","randBetween","modInv","lastT","lastR","zero","newT","one","newR","next","powersOfTwo","powers2Length","highestPower2","shift_isSmall","bitwise","fn","xSign","ySign","xRem","not","yRem","xDigit","yDigit","xDivMod","yDivMod","toJSNumber","String","shiftRight","remQuo","and","or","xor","LOBMASK_I","LOBMASK_BI","roughLOB","min","gcd","text","absBase","toLowerCase","test","charCodeAt","isNaN","digits","charCode","start","parseBaseFromArray","val","stringify","digit","charAt","toBase","apply","map","valueOf","neg","out","left","toBaseString","join","parseStringValue","decimalPlace","indexOf","parseNumberValue","toArray","str","toJSON","minusOne","lcm","isInstance","low","range","random","restricted","top","fromArray","BinaryUtils_1","IPNumType_1","IPv6Utils_1","IPv6Utils_2","Prefix_1","Prefix_2","HexadecimalUtils_1","Validator","isWithinRange","ipNumber","lowerBound","upperBound","isValidAsnNumber","asnNumber","isValid","THIRTY_TWO_BIT_SIZE","invalidAsnRangeMessage","isValid16BitAsnNumber","SIXTEEN_BIT_SIZE","invalid16BitAsnRangeMessage","isValidIPv4Number","ipv4Number","invalidIPv4NumberMessage","isValidIPv6Number","ipv6Number","ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE","invalidIPv6NumberMessage","isValidIPv4Octet","octetNumber","withinRange","EIGHT_BIT_SIZE","invalidOctetRangeMessage","isValidIPv6Hexadecatet","hexadecatetNum","invalidHexadecatetMessage","isValidIPv4String","ipv4String","rawOctets","includes","invalidOctetCountMessage","every","isNumeric","isValidIPv6String","ipv6String","hexadecimals","expandIPv6Number","invalidHexadecatetCountMessage","hexadecimal","isHexadecatet","error","isValidPrefixValue","prefixValue","ipNumType","IPNumType","IPv4","invalidPrefixValueMessage","IPv6","invalidInetNumType","isValidIPv4SubnetMask","ipv4SubnetMaskString","ipv4InBinary","IPV4_SUBNET_MASK_BIT_PATTERN","invalidSubnetMaskMessage","isValidIPv6SubnetMask","ipv6SubnetMaskString","ipv6InBinary","hexadectetNotationToBinaryString","IPV6_SUBNET_MASK_BIT_PATTERN","isValidIPv4CidrNotation","ipv4RangeAsCidrString","cidrComponents","invalidIPv4CidrNotationMessage","ip","_a","__read","validIpv4","invalidIpv4Message","_b","validPrefix","invalidPrefixMessage","invalidMessage","isValidIPv4CidrRange","ipv4CidrNotation","isValidCidrRange","IPv4Prefix","fromNumber","isValidIPv6CidrRange","ipv6CidrNotation","isValidIPv6CidrNotation","colonHexadecimalNotationToBinaryString","IPv6Prefix","rangeString","cidrNotationValidator","toBinaryStringConverter","prefixFactory","validationResult","subnetMask","toSubnetMask","InvalidIPCidrRangeMessage","isValidIPv4RangeString","ipv4RangeString","isValidRange","firstIP","lastIP","isValidIPv6RangeString","ipv6RangeString","validator","firstLastValidator","rangeComponents","component","invalidRangeNotationMessage","validFirstIP","invalidFirstIPMessage","validLastIP","invalidLastIPMessage","invalidRangeFirstNotGreaterThanLastMessage","ipv6RangeAsCidrString","IPV6_RANGE_PATTERN","invalidIPv6CidrNotationString","isValidBinaryString","invalidBinaryStringErrorMessage","IPV4_PATTERN","RegExp","IPV4_RANGE_PATTERN","takeOutOfRangeSizeMessage","cannotSplitSingleRangeErrorMessage","expandWithZero","hexadecimalArray","leftPortion","rightPortion","leftPortionSplit","filter","rightPortionSplit","doublePortion","gapCount","pads","count","expandDoubleColon","leftString","rightString","collapseIPv6Number","contracted","hexidecimal","withoutLeadingZero","replace","hexadectetString","hexadecimalAsString","hexavalue","hexadecimalStringToBinaryString","Validator_1","SubnetMask_1","SubnetMask_2","Hexadecatet_1","rawValue","message","msg","getValue","onBits","offBits","IPv4SubnetMask","fromDecimalDottedString","toDecimalNotation","bits","substr","IPv6SubnetMask","fromHexadecimalString","toHexadecatetNotation","match","Hexadecatet","fromString","binaryStringToHexadecimalString","bigIntegerNumberToHexadecimalString","hexadecimalString","hexadecimalStringToHexadecatetString","AbstractIPNum_1","BinaryUtils_2","IPv4_1","BinaryUtils_3","_super","ipValue","_this","bitSize","maximumBitSize","type","hexadecatet","separator","expandedIPv6","constructFromHexadecimalDottedString","constructFromBigIntegerValue","__extends","fromBigInteger","bigIntValue","ipString","fromBinaryString","ipBinaryString","paddedBinaryString","fromIPv4","ipv4","toIPv4MappedIPv6","fromIPv4DotDecimalString","ip4DotDecimalString","getHexadecatet","nextIPNumber","previousIPNumber","binaryStringToHexadecatets","stringHexadecatet","AbstractIPNum","Octet_1","BinaryUtils_4","IPv6_1","octets","constructFromDecimalDottedString","getOctets","binary","toBinaryString","rawOctet","Octet","binaryStringToDecimalOctets","ipv4BinaryString","givenValue","hexadecatetValue","hasNext","hasPrevious","isEquals","anotherIPNum","isLessThan","isGreaterThan","isLessThanOrEquals","isGreaterThanOrEquals","octetValue","stringOctets","stringHexadecimals","AbstractIpRange","getSize","bitValue","cidrPrefix","inside","otherRange","thisFirst","getFirst","thisLast","getLast","otherFirst","otherLast","contains","isOverlapping","isConsecutive","hasNextRange","sizeOfCurrentRange","hasPreviousRange","IPv6CidrRange","ipv6","internalCounterValue","fromCidr","rangeIncidrNotation","prefix","toCidrString","toRangeString","onMask","subnetMaskAsBigInteger","invertedSubnetMask","take","iPv6s","iteratingIPv6","counter","prefixToSplit","splitCidr","firstRange","nextRange","startOfNextRange","previousRange","startOfPreviousRange","returnValue","done","iterator","IPv4CidrRange","errorMessages","messages","subnetAsBigInteger","invertedSubnet","ipv4s","iteratingIPv4","errMessage","Asn","ASN","startWithASprefix","substring","parseFromDotNotation","valueAsBigInt","stringValue","AS_PREFIX","toASPlain","toASDot","toASDotPlus","high","is16Bit","is32Bit","word","values","webpackPolyfill","deprecate","paths","children","__export"],"mappings":"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","file":"./ip-num.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n","import * as bigInt from \"big-integer/BigInteger\";\n\n/**\n * Converts a decimal number to binary string\n *\n * @param num number to parse\n * @returns {string} the binary string representation of number\n */\n\nexport let decimalNumberToBinaryString = (num:number):string => {\n    return Number(num).toString(2);\n};\n\n/**\n * Converts a given BigInteger number to a binary string\n * @param num the BigInteger number\n * @returns {string} the binary string\n */\nexport let bigIntegerNumberToBinaryString = (num: bigInt.BigInteger): string => {\n    return num.toString(2);\n};\n\n\n/**\n * Converts a decimal number to binary octet (8 bit) string. If needed the octet will be padded with zeros\n * to make it up to 8 bits\n *\n * @param {number} num to convert to octet string\n * @returns {string} the octet string representation of given number\n */\nexport let decimalNumberToOctetString = (num:number): string => {\n    let binaryString = decimalNumberToBinaryString(num);\n    let length = binaryString.length;\n    if (length > 8) {\n        throw new Error(\"Given decimal in binary contains digits greater than an octet\")\n    }\n    return leftPadWithZeroBit(binaryString, 8);\n};\n\n/**\n * Parses number in binary to number in BigInteger\n *\n * @param num binary number in string to parse\n * @returns {number} binary number in BigInteger\n */\nexport let parseBinaryStringToBigInteger = (num:string): bigInt.BigInteger => {\n    return bigInt(num, 2);\n};\n\n/**\n * Given an IPv4 number in dot-decimal notated string, e.g 192.168.0.1 converts it to\n * binary string, e.g. '11000000101010000000000000000001'\n *\n * @param dottedDecimal IPv4 string in dot-decimal notation\n * @returns {string} the binary value of the given ipv4 number in string\n */\nexport let dottedDecimalNotationToBinaryString = (dottedDecimal: string): string => {\n    let stringOctets = dottedDecimal.split(\".\");\n    return stringOctets.reduce((binaryAsString, octet) => {\n        return binaryAsString.concat(decimalNumberToOctetString(parseInt(octet)));\n    }, '');\n};\n\n/**\n * Given a binary string, adds a number of zero to the left until string is as long as the given string length\n * @param {string} binaryString the string to pad\n * @param {number} finalStringLength the final length of string after padding\n * @returns {string}\n */\nexport let leftPadWithZeroBit = (binaryString: string, finalStringLength: number): string => {\n    if (binaryString.length > finalStringLength) {\n        throw new Error(`Given string is already longer than given final length after padding: ${finalStringLength}`);\n    }\n    return \"0\".repeat(finalStringLength - binaryString.length).concat(binaryString);\n};\n","var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        LOG_MAX_INT = Math.log(MAX_INT);\r\n\r\n    function Integer(v, radix) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 ? parseValue(v) : parseBase(v, radix);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a,b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n            if (isPrecise(a.value * this.value)) {\r\n                return new SmallInteger(a.value * this.value);\r\n            }\r\n            return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n            if (a.value === 0) return Integer[0];\r\n            if (a.value === 1) return this;\r\n            if (a.value === -1) return this.negate();\r\n            return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    function square(a) {\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < l; j++) {\r\n                a_j = a[j];\r\n                product = a_i * a_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        var value = n.value;\r\n        if (value === 0) return false;\r\n        if (value === 1) return true;\r\n        if (value === 2) return this.isEven();\r\n        return this.mod(n).equals(Integer[0]);\r\n    };\r\n    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(25)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    BigInteger.prototype.isPrime = function () {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs(),\r\n            nPrev = n.prev();\r\n        var a = [2, 3, 5, 7, 11, 13, 17, 19],\r\n            b = nPrev,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2);\r\n        for (i = 0; i < a.length; i++) {\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;\r\n            for (t = true, d = b; t && d.lesser(nPrev) ; d = d.multiply(2)) {\r\n                x = x.square().mod(n);\r\n                if (x.equals(nPrev)) t = false;\r\n            }\r\n            if (t) return false;\r\n        }\r\n        return true;\r\n    };\r\n    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        // use the Fermat primality test\r\n        for (var i = 0; i < t; i++) {\r\n            var a = bigInt.randBetween(2, n.minus(2));\r\n            if (!a.modPow(n.prev(), n).isUnit()) return false; // definitely composite\r\n        }\r\n        return true; // large chance of being prime\r\n    };\r\n    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.equals(bigInt.zero)) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.equals(1)) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return ((typeof n === \"number\" || typeof n === \"string\") && +Math.abs(n) <= BASE) ||\r\n            (n instanceof BigInteger && n.value.length <= 1);\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (n) {\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (n) {\r\n        var remQuo;\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero()) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value, x = typeof v === \"number\" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = Math.min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(Math.random() * range));\r\n        var length = range.value.length - 1;\r\n        var result = [], restricted = true;\r\n        for (var i = length; i >= 0; i--) {\r\n            var top = restricted ? range.value[i] : BASE;\r\n            var digit = truncate(Math.random() * top);\r\n            result.unshift(digit);\r\n            if (digit < top) restricted = false;\r\n        }\r\n        result = arrayToSmall(result);\r\n        return low.add(typeof result === \"number\" ? new SmallInteger(result) : new BigInteger(result, false));\r\n    }\r\n    var parseBase = function (text, base) {\r\n        var length = text.length;\r\n\t\tvar i;\r\n\t\tvar absBase = Math.abs(base);\r\n\t\tfor(var i = 0; i < length; i++) {\r\n\t\t\tvar c = text[i].toLowerCase();\r\n\t\t\tif(c === \"-\") continue;\r\n\t\t\tif(/[a-z0-9]/.test(c)) {\r\n\t\t\t    if(/[0-9]/.test(c) && +c >= absBase) {\r\n\t\t\t\t\tif(c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n\t\t\t\t} else if(c.charCodeAt(0) - 87 >= absBase) {\r\n\t\t\t\t\tthrow new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n        if (2 <= base && base <= 36) {\r\n            if (length <= LOG_MAX_INT / Math.log(base)) {\r\n\t\t\t\tvar result = parseInt(text, base);\r\n\t\t\t\tif(isNaN(result)) {\r\n\t\t\t\t\tthrow new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n\t\t\t\t}\r\n                return new SmallInteger(parseInt(text, base));\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i].toLowerCase(),\r\n                charCode = c.charCodeAt(0);\r\n            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));\r\n            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\");\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit) {\r\n        if (digit <= 35) {\r\n            return \"0123456789abcdefghijklmnopqrstuvwxyz\".charAt(digit);\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return {value: [0], isNegative: false};\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return {value: [0], isNegative: false};\r\n            if (n.isNegative())\r\n              return {\r\n                value: [].concat.apply([], Array.apply(null, Array(-n))\r\n                            .map(Array.prototype.valueOf, [1, 0])\r\n                          ),\r\n                isNegative: false\r\n              };\r\n\r\n            var arr = Array.apply(null, Array(+n - 1))\r\n              .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n              value: [].concat.apply([], arr),\r\n              isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.equals(1)) {\r\n            if (n.isZero()) return {value: [0], isNegative: false};\r\n            \r\n            return {\r\n              value: Array.apply(null, Array(+n))\r\n                       .map(Number.prototype.valueOf, 1),\r\n              isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return {value: out.reverse(), isNegative: neg};\r\n    }\r\n\r\n    function toBaseString(n, base) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(stringify).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n      return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n      return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix);\r\n        return String(this.value);\r\n    };\r\n    BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n\r\n    function parseStringValue(v) {\r\n            if (isPrecise(+v)) {\r\n                var x = +v;\r\n                if (x === truncate(x))\r\n                    return new SmallInteger(x);\r\n                throw \"Invalid integer: \" + v;\r\n            }\r\n            var sign = v[0] === \"-\";\r\n            if (sign) v = v.slice(1);\r\n            var split = v.split(/e/i);\r\n            if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n            if (split.length === 2) {\r\n                var exp = split[1];\r\n                if (exp[0] === \"+\") exp = exp.slice(1);\r\n                exp = +exp;\r\n                if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n                var text = split[0];\r\n                var decimalPlace = text.indexOf(\".\");\r\n                if (decimalPlace >= 0) {\r\n                    exp -= text.length - decimalPlace - 1;\r\n                    text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n                }\r\n                if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n                text += (new Array(exp + 1)).join(\"0\");\r\n                v = text;\r\n            }\r\n            var isValid = /^([0-9][0-9]*)$/.test(v);\r\n            if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n            var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n            while (max > 0) {\r\n                r.push(+v.slice(min, max));\r\n                min -= l;\r\n                if (min < 0) min = 0;\r\n                max -= l;\r\n            }\r\n            trim(r);\r\n            return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = new SmallInteger(i);\r\n        if (i > 0) Integer[-i] = new SmallInteger(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif ( typeof define === \"function\" && define.amd ) {\r\n  define( \"big-integer\", [], function() {\r\n    return bigInt;\r\n  });\r\n}\r\n","'use strict';\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport * as bigInt from \"big-integer\";\nimport {IPNumType} from \"./IPNumType\";\nimport {hexadectetNotationToBinaryString} from \"./IPv6Utils\";\nimport {expandIPv6Number} from \"./IPv6Utils\";\nimport {IPv4Prefix} from \"./Prefix\";\nimport {IPv6Prefix} from \"./Prefix\";\nimport {colonHexadecimalNotationToBinaryString} from \"./HexadecimalUtils\";\n\nexport class Validator {\n    static IPV4_PATTERN: RegExp = new RegExp(/^(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/);\n    static IPV4_RANGE_PATTERN: RegExp = new RegExp(/^(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\/)([1-9]|[1-2][0-9]|3[0-2])$/);\n    static IPV6_RANGE_PATTERN: RegExp = new RegExp(/^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8]))?$/);\n    static IPV4_SUBNET_MASK_BIT_PATTERN: RegExp = new RegExp(/^(1){0,32}(0){0,32}$/);\n    static IPV6_SUBNET_MASK_BIT_PATTERN: RegExp = new RegExp(/^(1){0,128}(0){0,128}$/);\n\n    static EIGHT_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(8), 2);\n    static SIXTEEN_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(16), 2);\n    static THIRTY_TWO_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(32), 2);\n    static ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(128), 2);\n\n    static invalidAsnRangeMessage = \"ASN number given less than zero or is greater than 32bit\";\n    static invalid16BitAsnRangeMessage = \"ASN number given less than zero or is greater than 16bit\";\n    static invalidIPv4NumberMessage = \"IPv4 number given less than zero or is greater than 32bit\";\n    static invalidIPv6NumberMessage = \"IPv6 number given less than zero or is greater than 128bit\";\n    static invalidOctetRangeMessage = \"Value given contains an invalid Octet; Value is less than zero or is greater than 8bit\";\n    static invalidHexadecatetMessage = \"The value given is less than zero or is greater than 16bit\";\n    static invalidOctetCountMessage = \"An IP4 number cannot have less or greater than 4 octets\";\n    static invalidHexadecatetCountMessage = \"An IP6 number must have exactly 8 hexadecatet\";\n    static invalidSubnetMaskMessage = \"The Subnet Mask is invalid\";\n    static invalidPrefixValueMessage = \"A Prefix value cannot be less than 0 or greater than 32\";\n    static invalidIPv4CidrNotationMessage = \"Cidr notation should be in the form [ip number]/[range]\";\n    static InvalidIPCidrRangeMessage = \"Given IP number portion must is not the start of the range\";\n    static invalidRangeNotationMessage = \"Range notation should be in the form [first ip]-[last ip]\";\n    static invalidRangeFirstNotGreaterThanLastMessage = \"First IP in [first ip]-[last ip] must be less than Last IP\";\n    static invalidIPv6CidrNotationString = \"A Cidr notation string should contain an IPv6 number and prefix\";\n    static takeOutOfRangeSizeMessage = \"$count is greater than $size, the size of the range\";\n    static cannotSplitSingleRangeErrorMessage = \"Cannot split an IP range with a single IP number\";\n    static invalidInetNumType = \"Given ipNumType must be either InetNumType.IPv4 or InetNumType.IPv6\";\n    static invalidBinaryStringErrorMessage = \"Binary string should contain only contiguous 1s and 0s\";\n\n    /**\n     * Checks if given ipNumber is in between the given lower and upper bound\n     *\n     * @param ipNumber ipNumber to check\n     * @param lowerBound lower bound\n     * @param upperBound upper bound\n     * @returns {boolean} true if ipNumber is between lower and upper bound\n     */\n    private static isWithinRange(ipNumber: bigInt.BigInteger, lowerBound: bigInt.BigInteger, upperBound: bigInt.BigInteger) : boolean {\n        return ipNumber.greaterOrEquals(lowerBound) && ipNumber.lesserOrEquals(upperBound);\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an ASN number\n     *\n     * @param asnNumber the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid ASN, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidAsnNumber(asnNumber: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = this.isWithinRange(asnNumber, bigInt.zero, this.THIRTY_TWO_BIT_SIZE);\n        return [isValid, isValid ? []: [Validator.invalidAsnRangeMessage]];\n    }\n\n    /**\n     * Checks if the given ASN number is a 16bit ASN number\n     *\n     * @param {bigInt.BigInteger} asnNumber to check if 16bit or not\n     * @returns {[boolean , string]} first value is true if valid 16bit ASN, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValid16BitAsnNumber(asnNumber: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = Validator.isWithinRange(asnNumber, bigInt.zero, Validator.SIXTEEN_BIT_SIZE);\n        return [isValid, isValid ? []: [Validator.invalid16BitAsnRangeMessage]];\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an IPv4 number\n     *\n     * @param ipv4Number the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid IPv4 number, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4Number(ipv4Number: bigInt.BigInteger): [boolean, string[]]  {\n        let isValid = this.isWithinRange(ipv4Number, bigInt.zero, this.THIRTY_TWO_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv4NumberMessage]];\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an IPv6 number\n     *\n     * @param ipv6Number the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid IPv6 number, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6Number(ipv6Number: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = this.isWithinRange(ipv6Number, bigInt.zero, this.ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv6NumberMessage]];\n    }\n\n    /**\n     * Checks if the number given is valid for an IPv4 octet\n     *\n     * @param octetNumber the octet value\n     * @returns {boolean} true if valid octet, false otherwise\n     */\n    static isValidIPv4Octet(octetNumber: bigInt.BigInteger): [boolean, string[]] {\n        let withinRange = this.isWithinRange(octetNumber, bigInt.zero, this.EIGHT_BIT_SIZE);\n        return [withinRange, withinRange ? []: [Validator.invalidOctetRangeMessage]];\n    }\n\n    /**\n     * Checks if the number given is valid for an IPv6 hexadecatet\n     *\n     * @param {bigInt.BigInteger} hexadecatetNum the hexadecatet value\n     * @returns {[boolean , string]} first value is true if valid hexadecatet, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6Hexadecatet(hexadecatetNum: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = this.isWithinRange(hexadecatetNum, bigInt.zero, this.SIXTEEN_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidHexadecatetMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv4 value.\n     *\n     * @param {string} ipv4String the IPv4 string to validate\n     * @returns {[boolean , string]} result of validation, first value represents if is valid IPv4, second value\n     * contains error message if invalid IPv4\n     */\n    static isValidIPv4String(ipv4String: string): [boolean, string[]] {\n        let rawOctets = ipv4String.split(\".\");\n\n        if (rawOctets.length != 4 || rawOctets.includes('')) {\n            return [false, [Validator.invalidOctetCountMessage]];\n        }\n\n        let isValid = rawOctets.every(octet => {\n            return Validator.isNumeric(octet) ? Validator.isValidIPv4Octet(bigInt(octet))[0] : false;\n        });\n\n        return [isValid, isValid ? []: [Validator.invalidOctetRangeMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv6 value.\n     *\n     * @param {string} ipv6String the IPv6 string to validate\n     * @returns {[boolean , string]} result of validation, first value represents if is valid IPv6, second value\n     * contains error message if invalid IPv6\n     */\n    static isValidIPv6String(ipv6String: string): [boolean, string[]] {\n        try {\n            let hexadecimals = expandIPv6Number(ipv6String).split(\":\");\n            if (hexadecimals.length != 8 ) {\n                return [false, [Validator.invalidHexadecatetCountMessage]]\n            }\n\n            let isValid = hexadecimals.every(hexadecimal => {\n                return Validator.isHexadecatet(hexadecimal) ?\n                    Validator.isValidIPv6Hexadecatet(bigInt(parseInt(hexadecimal, 16)))[0] : false;\n            });\n\n            return [isValid, isValid? []: [Validator.invalidHexadecatetMessage]];\n        } catch (error) {\n            return [false, [error]]\n        }\n    }\n\n    /**\n     * Checks if given value is a valid prefix value\n     *\n     * @param prefixValue value to check\n     * @param ipNumType The type of IP number\n     * @returns {(boolean|string)[]} a tuple representing if valid or not and corresponding message\n     */\n    static isValidPrefixValue(prefixValue: number, ipNumType: IPNumType): [boolean, string[]] {\n        if (IPNumType.IPv4 === ipNumType) {\n            let withinRange = Validator.isWithinRange(bigInt(prefixValue), bigInt.zero, bigInt(32));\n            return [withinRange, withinRange ? []: [Validator.invalidPrefixValueMessage]];\n        }\n        if (IPNumType.IPv6 === ipNumType) {\n            let withinRange = Validator.isWithinRange(bigInt(prefixValue), bigInt.zero, bigInt(128));\n            return [withinRange, withinRange ? []: [Validator.invalidPrefixValueMessage]];\n        }\n        return [false, [Validator.invalidInetNumType]]\n    }\n\n    /**\n     * Checks if given string is a valid IPv4 subnet mask\n     *\n     * @param {string} ipv4SubnetMaskString the given IPv4 subnet mask string\n     * @returns {[boolean , string]} first value is true if valid IPv4 subnet mask string, false otherwise. Second value\n     * contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4SubnetMask(ipv4SubnetMaskString: string) : [boolean, string[]] {\n        let ipv4InBinary = dottedDecimalNotationToBinaryString(ipv4SubnetMaskString);\n        let isValid = Validator.IPV4_SUBNET_MASK_BIT_PATTERN.test(ipv4InBinary);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidSubnetMaskMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv6 subnet mask\n     *\n     * @param {string} ipv6SubnetMaskString the given IPv6 subnet mask string\n     * @returns {[boolean , string]} first value is true if valid IPv6 subnet mask string, false otherwise. Second value\n     * contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6SubnetMask(ipv6SubnetMaskString: string) : [boolean, string[]] {\n        let ipv6InBinary = hexadectetNotationToBinaryString(ipv6SubnetMaskString);\n        let isValid = Validator.IPV6_SUBNET_MASK_BIT_PATTERN.test(ipv6InBinary);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidSubnetMaskMessage]];\n    }\n\n    /**\n     * Checks if the given string is a valid IPv4 range in Cidr notation\n     *\n     * @param {string} ipv4RangeAsCidrString the IPv4 range in Cidr notation\n     *\n     * @returns {[boolean , string[]]} first value is true if valid IPv4 range in Cidr notation, false otherwise. Second\n     * value contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4CidrNotation(ipv4RangeAsCidrString: string): [boolean, string[]] {\n        let cidrComponents = ipv4RangeAsCidrString.split(\"/\");\n        if(cidrComponents.length !== 2 || (cidrComponents[0].length === 0 || cidrComponents[1].length === 0)) {\n            return [false, [Validator.invalidIPv4CidrNotationMessage]];\n        }\n\n        let ip = cidrComponents[0];\n        let range = cidrComponents[1];\n\n        if (isNaN(Number(range))) {\n            return [false, [Validator.invalidIPv4CidrNotationMessage]];\n        }\n\n        let [validIpv4, invalidIpv4Message] = Validator.isValidIPv4String(ip);\n        let [validPrefix, invalidPrefixMessage] = Validator.isValidPrefixValue(Number(range), IPNumType.IPv4);\n\n        let isValid = validIpv4 && validPrefix;\n        let invalidMessage = invalidIpv4Message.concat(invalidPrefixMessage);\n\n        return isValid ? [isValid, []]: [isValid, invalidMessage];\n    }\n\n  /**\n   *  Checks if the given string is a valid IPv4 range in Cidr notation, with the ip number in the cidr notation\n   *  being the start of the range\n   *\n   * @param {string}  ipv4CidrNotation the IPv4 range in Cidr notation\n   *\n   * * @returns {[boolean , string[]]} first value is true if valid Cidr notation, false otherwise. Second\n   * value contains [] or an array of error message when invalid\n   */\n  static isValidIPv4CidrRange(ipv4CidrNotation: string): [boolean, string[]] {\n      return Validator.isValidCidrRange(ipv4CidrNotation, Validator.isValidIPv4CidrNotation, dottedDecimalNotationToBinaryString, IPv4Prefix.fromNumber);\n    }\n\n  /**\n   *  Checks if the given string is a valid IPv6 range in Cidr notation, with the ip number in the cidr notation\n   *  being the start of the range\n   *\n   * @param {string}  ipv6CidrNotation the IPv6 range in Cidr notation\n   *\n   * * @returns {[boolean , string[]]} first value is true if valid Cidr notation, false otherwise. Second\n   * value contains [] or an array of error message when invalid\n   */\n    static isValidIPv6CidrRange(ipv6CidrNotation: string): [boolean, string[]] {\n      return Validator.isValidCidrRange(ipv6CidrNotation, Validator.isValidIPv6CidrNotation, colonHexadecimalNotationToBinaryString, IPv6Prefix.fromNumber);\n    }\n\n\n    private static isValidCidrRange(rangeString: string,\n                                    cidrNotationValidator: (range:string) => [boolean, string[]],\n                                    toBinaryStringConverter: (range: string) => string,\n                                    prefixFactory: (num:number) => IPv4Prefix | IPv6Prefix): [boolean, string[]] {\n      let validationResult = cidrNotationValidator(rangeString);\n\n      if (!validationResult[0]) {\n        return validationResult\n      }\n\n      let cidrComponents = rangeString.split(\"/\");\n      let ip = cidrComponents[0];\n      let range = cidrComponents[1];\n      let ipNumber = bigInt(toBinaryStringConverter(ip), 2);\n      let subnetMask = prefixFactory(parseInt(range)).toSubnetMask();\n      let isValid = ipNumber.and(subnetMask.value).equals(ipNumber);\n\n      return isValid ? [isValid, []]: [isValid, [Validator.InvalidIPCidrRangeMessage]];\n    }\n\n    static isValidIPv4RangeString(ipv4RangeString: string): [boolean, string[]] {\n        let firstLastValidator = (firstIP: string, lastIP: string) => bigInt(dottedDecimalNotationToBinaryString(firstIP))\n            .greaterOrEquals(dottedDecimalNotationToBinaryString(lastIP));\n\n        return this.isValidRange(ipv4RangeString, Validator.isValidIPv4String, firstLastValidator);\n    }\n\n    static isValidIPv6RangeString(ipv6RangeString: string): [boolean, string[]] {\n        let firstLastValidator = (firstIP: string, lastIP: string) => bigInt(hexadectetNotationToBinaryString(firstIP))\n            .greaterOrEquals(hexadectetNotationToBinaryString(lastIP));\n        return this.isValidRange(ipv6RangeString, Validator.isValidIPv6String, firstLastValidator);\n    }\n\n    private static isValidRange(rangeString: string,\n                                validator: (x:string) => [boolean, string[]],\n                                firstLastValidator: (first:string, last:string) => boolean):[boolean, string[]] {\n        let rangeComponents = rangeString.split(\"-\").map(component => component.trim());\n        if(rangeComponents.length !== 2 || (rangeComponents[0].length === 0 || rangeComponents[1].length === 0)) {\n            return [false, [Validator.invalidRangeNotationMessage]];\n        }\n        let firstIP = rangeComponents[0];\n        let lastIP = rangeComponents[1];\n\n        let [validFirstIP, invalidFirstIPMessage] = validator(firstIP);\n        let [validLastIP, invalidLastIPMessage] = validator(lastIP);\n\n        let isValid = validFirstIP && validLastIP;\n\n        if (isValid && firstLastValidator(firstIP, lastIP)) {\n            return [false, [Validator.invalidRangeFirstNotGreaterThanLastMessage]]\n        }\n\n        let invalidMessage = invalidFirstIPMessage.concat(invalidLastIPMessage);\n\n        return isValid ? [isValid, []]: [isValid, invalidMessage];\n    }\n\n    /**\n     * Checks if the given string is a valid IPv6 range in Cidr notation\n     *\n     * @param {string} ipv6RangeAsCidrString the IPv6 range in Cidr notation\n     *\n     * @returns {[boolean , string]} first value is true if valid IPv6 range in Cidr notation, false otherwise.\n     * Second value contains \"valid\" or an error message when value is invalid\n     */\n    // TODO change to be like isValidIPv4CidrNotation where validation is done on the component of the cidr notation\n    // instead of a single regex check\n    static isValidIPv6CidrNotation(ipv6RangeAsCidrString: string): [boolean, string[]] {\n        let isValid = Validator.IPV6_RANGE_PATTERN.test(ipv6RangeAsCidrString);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv6CidrNotationString]];\n    }\n\n    /**\n     * Checks if the given string is a binary string. That is contains only contiguous 1s and 0s\n     *\n     * @param {string} binaryString the binary string\n     * @returns {(boolean|string)[]} a tuple representing if valid or not and corresponding message\n     */\n    static isValidBinaryString(binaryString: string): [boolean, string[]] {\n        if (/^([10])+$/.test(binaryString)) {\n            return [true, []]\n        } else {\n            return [false, [Validator.invalidBinaryStringErrorMessage]]\n        }\n    }\n\n    private static isNumeric(value: string): boolean {\n        return /^(\\d+)$/.test(value)\n    }\n\n    private static isHexadecatet(value: string): boolean {\n        return /^[0-9A-Fa-f]{4}$/.test(value)\n    }\n\n}\n\n","import {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {hexadecimalStringToBinaryString} from \"./HexadecimalUtils\";\n\n/**\n * Expands an IPv6 number in abbreviated format into its full form\n *\n * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more on the representation of IPv6 addresses\n *\n * @param {string} ipv6String the abbreviated IPv6 address to expand\n * @returns {string} the expanded IPv6 address\n */\nexport let expandIPv6Number = (ipv6String:string):string => {\n    let expandWithZero = (hexadecimalArray: string[]): string => {\n        let paddedArray = hexadecimalArray.map((hexadecimal) => {\n            return leftPadWithZeroBit(hexadecimal, 4);\n        });\n\n        return paddedArray.join(\":\")\n    };\n\n    let expandDoubleColon = (gapCount: number): string => {\n        let pads = [];\n        for (let count=0; count<gapCount; count++) {\n            pads.push(\"0000\");\n        }\n        return pads.join(\":\");\n    };\n\n    if (/(:){3,}/.test(ipv6String)) throw \"given IPv6 contains consecutive : more than two\";\n\n    if (ipv6String.includes(\"::\")) {\n        let split = ipv6String.split(\"::\");\n        let leftPortion = split[0];\n        let rightPortion = split[1];\n\n        let leftPortionSplit = leftPortion.split(\":\").filter(hexadecimal => {return hexadecimal !== \"\"});\n        let rightPortionSplit = rightPortion.split(\":\").filter(hexadecimal => {return hexadecimal !== \"\"});\n        let doublePortion = expandDoubleColon(8 - (leftPortionSplit.length + rightPortionSplit.length));\n\n\n        let leftString = expandWithZero(leftPortionSplit);\n        if (leftString !== \"\") {\n            leftString += \":\";\n        }\n\n\n        let rightString = expandWithZero(rightPortionSplit);\n        if (rightString !== \"\") {\n            rightString = \":\"+rightString;\n        }\n\n        return `${leftString}${doublePortion}${rightString}`;\n\n    } else {\n        return expandWithZero(ipv6String.split(\":\"));\n    }\n};\n\n\n/**\n * Collapses an IPv6 number in full format into its abbreviated form\n *\n * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more on the representation of IPv6 addresses\n *\n * @param {string} ipv6String the full form IPv6 number to collapse\n * @returns {string} the collapsed IPv6 number\n */\nexport let collapseIPv6Number = (ipv6String:string):string => {\n    let hexadecimals: string[] = ipv6String.split(\":\");\n    let hexadecimalsWithoutLeadingZeros = hexadecimals.map((hexidecimal) => {\n       let withoutLeadingZero = hexidecimal.replace(/^0+/, '');\n       if (withoutLeadingZero !== '') {\n           return withoutLeadingZero;\n       } else {\n           return \"0\";\n       }\n\n    });\n    let contracted = hexadecimalsWithoutLeadingZeros.join(\":\").replace(/(^0)?(:0){2,}/, ':');\n    if (contracted.slice(-1) === \":\") {\n        return `${contracted}:`;\n    }\n    return contracted;\n};\n\n\n/**\n * Converts a given IPv6 number expressed in the hexadecimal string notation into a 16 bit binary number in string\n * @param {string} hexadectetString the IPv6 number\n * @returns {string} the IPv6 number converted to binary string\n */\nexport let hexadectetNotationToBinaryString = (hexadectetString: string): string => {\n    let expand = expandIPv6Number(hexadectetString);\n    let hexadecimals = expand.split(\":\");\n    return hexadecimals.reduce((hexadecimalAsString, hexavalue) => {\n        return hexadecimalAsString.concat(leftPadWithZeroBit(hexadecimalStringToBinaryString(hexavalue),16));\n    }, '');\n};","export enum IPNumType {\n    ASN,\n    IPv4,\n    IPv6\n}","import {Validator} from \"./Validator\";\nimport {IPv4SubnetMask} from \"./SubnetMask\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {IPNumType} from \"./IPNumType\";\nimport {IPv6SubnetMask} from \"./SubnetMask\";\nimport {binaryStringToHexadecimalString} from \"./HexadecimalUtils\";\nimport {Hexadecatet} from \"./Hexadecatet\";\n\n\ninterface Prefix {\n    value: number;\n    getValue(): number;\n}\n\n/**\n * Represents the prefix portion in the CIDR notation for representing IP ranges\n *\n * The IPv4 prefix portion represents the subnet mask. It is the number of continuous bits turned on (with value 1)\n * counting from the left side of an 8 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing} for more information on CIDR\n */\nclass IPv4Prefix implements Prefix {\n    /**\n     * The decimal value of the 8bit number representing the prefix\n     */\n    value: number;\n\n    /**\n     * Convenience method for constructing an instance of IPv4 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv4 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv4 prefix\n     */\n    static fromNumber(rawValue:number):IPv4Prefix {\n        return new IPv4Prefix(rawValue);\n    };\n\n    /**\n     * Constructor for an instance of IPv4 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv4 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv4 prefix\n     */\n    constructor(rawValue: number) {\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidPrefixValue(rawValue, IPNumType.IPv4);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = rawValue;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix\n     *\n     * @returns {number} the decimal value of the IPv4 prefix\n     */\n    public getValue(): number {\n        return this.value;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix as string\n     * @returns {string} he decimal value of the IPv4 prefix as string\n     */\n    public toString(): string {\n        return this.value.toString();\n    }\n\n    /**\n     * Converts the IPv4 prefix to a {@link IPv4SubnetMask}\n     *\n     * The IPv4 Subnet mask is the representation of the prefix in the dot-decimal notation\n     *\n     * @returns {IPv4SubnetMask} the subnet mask representation of the prefix\n     */\n    public toSubnetMask(): IPv4SubnetMask {\n        let onBits = '1'.repeat(this.value);\n        let offBits = '0'.repeat(32 - this.value);\n        return IPv4SubnetMask.fromDecimalDottedString(this.toDecimalNotation(`${onBits}${offBits}`));\n    }\n\n    private toDecimalNotation(bits:string): string {\n        return `${parseBinaryStringToBigInteger(bits.substr(0,8))}.${parseBinaryStringToBigInteger(bits.substr(8,8))}.${parseBinaryStringToBigInteger(bits.substr(16,8))}.${parseBinaryStringToBigInteger(bits.substr(24,8))}`\n    }\n}\n\n/**\n * Represents the prefix portion in the CIDR notation for representing IP ranges\n *\n * The IPv6 prefix portion represents the subnet mask. It is the number of continuous bits turned on (with value 1)\n * counting from the left side of an 128 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing} for more information on CIDR\n */\nclass IPv6Prefix implements Prefix {\n    /**\n     * The decimal value of the 16bit number representing the prefix\n     */\n    value: number;\n\n    /**\n     * Convenience method for constructing an instance of IPv46 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv6 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv6 prefix\n     */\n    static fromNumber(rawValue:number):IPv6Prefix {\n        return new IPv6Prefix(rawValue);\n    };\n\n    /**\n     * Constructor for an instance of IPv6 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv6 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv6 prefix\n     */\n    constructor(rawValue: number) {\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidPrefixValue(rawValue, IPNumType.IPv6);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = rawValue;\n    }\n\n    /**\n     * Gets the decimal value of the IPv6 prefix\n     *\n     * @returns {number} the decimal value of the IPv6 prefix\n     */\n    public getValue(): number {\n        return this.value;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix as string\n     * @returns {string} he decimal value of the IPv4 prefix as string\n     */\n    public toString(): string {\n        return this.value.toString();\n    }\n\n    /**\n     * Converts the IPv6 prefix to a {@link IPv6SubnetMask}\n     *\n     * The IPv6 Subnet mask is the representation of the prefix in 8 groups of 16 bit values represented in hexadecimal\n     *\n     * @returns {IPv6SubnetMask} the subnet mask representation of the prefix\n     */\n    public toSubnetMask(): IPv6SubnetMask {\n        let onBits = '1'.repeat(this.value);\n        let offBits = '0'.repeat(128 - this.value);\n        return IPv6SubnetMask.fromHexadecimalString(this.toHexadecatetNotation(`${onBits}${offBits}`));\n    }\n\n    private toHexadecatetNotation(bits:string): string {\n        let binaryStrings: string[] = bits.match(/.{1,16}/g)!;\n        let hexadecimalStrings: Hexadecatet[] = binaryStrings.map((binaryString) => {\n            return Hexadecatet.fromString(binaryStringToHexadecimalString(binaryString));\n        });\n        return hexadecimalStrings.map((value) => { return value.toString()}).join(\":\");\n    }\n}\n\nexport {Prefix, IPv4Prefix, IPv6Prefix}","import * as bigInt from \"big-integer/BigInteger\";\nimport {expandIPv6Number} from \"./IPv6Utils\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\n\n/**\n * Converts a given BigInteger number to a hexadecimal string\n * @param num the BigInteger number\n * @returns {string} the hexadeciaml string\n */\nexport let bigIntegerNumberToHexadecimalString = (num: bigInt.BigInteger): string => {\n    return num.toString(16);\n};\n\n/**\n * Converts a number in hexadecimal (base 16) to binary string\n * @param {string} hexadecimalString the number in base 16\n * @returns {string} the number converted to base 2\n */\nexport let hexadecimalStringToBinaryString = (hexadecimalString: string) : string => {\n    let inDecimal = bigInt(hexadecimalString, 16);\n    return inDecimal.toString(2);\n};\n\n/**\n * Converts a number in hexadecimal (base 16) to binary hexadecatet string.\n * This means the bits in the output cannot be more than 16\n *\n * @param hexadecimalString {string} the number converted to binary hexadecatet string\n */\nexport let hexadecimalStringToHexadecatetString = (hexadecimalString: string): string => {\n  let binaryString = hexadecimalStringToBinaryString(hexadecimalString);\n\n  let length = binaryString.length;\n  if (length > 16) {\n    throw new Error(\"Given decimal in binary contains digits greater than an Hexadecatet\")\n  }\n  return leftPadWithZeroBit(binaryString, 16);\n};\n\n/**\n * Given an IPv6 number in hexadecimal notated string, e.g 2001:0db8:0000:0000:0000:0000:0000:0000 converts it to\n * binary string\n *\n * @param hexadecimalString IPv6 string\n * @returns {string} the binary value of the given ipv6 number in string\n */\nexport let colonHexadecimalNotationToBinaryString = (hexadecimalString: string): string => {\n  let expandedIPv6 = expandIPv6Number(hexadecimalString);\n  let stringHexadecimal = expandedIPv6.split(\":\");\n\n  return stringHexadecimal.reduce((binaryAsString, hexidecimal) => {\n    return binaryAsString.concat(hexadecimalStringToHexadecatetString(hexidecimal))\n  }, '');\n};\n\n\n/**\n * Converts number in binary string to hexadecimal string\n * @param {string} num in binary string\n * @returns {string} num in hexadecimal string\n */\nexport let binaryStringToHexadecimalString = (num: string): string => {\n    // first convert to binary string to decimal (big Integer)\n    let inDecimal = bigInt(num, 2);\n    return inDecimal.toString(16);\n};","import {IPNumber} from \"./interface/IPNumber\";\nimport {Hexadecatet} from \"./Hexadecatet\";\nimport {Validator} from \"./Validator\";\nimport {bigIntegerNumberToBinaryString} from \"./BinaryUtils\";\nimport {binaryStringToHexadecimalString} from \"./HexadecimalUtils\";\nimport {expandIPv6Number} from \"./IPv6Utils\";\nimport {hexadectetNotationToBinaryString} from \"./IPv6Utils\";\nimport * as bigInt from \"big-integer/BigInteger\";\nimport {AbstractIPNum} from \"./AbstractIPNum\";\nimport {IPNumType} from \"./IPNumType\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {IPv4} from \"./IPv4\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\n\n\n/**\n * Represents an IPv6 number. A 128 bit number that is used to uniquely identify a device that is part of a computer\n * network that uses the internet protocol for communication.\n *\n * @see https://en.wikipedia.org/wiki/IPv6\n * @see https://www.rfc-editor.org/info/rfc8200\n */\nexport class IPv6 extends AbstractIPNum implements IPNumber {\n    /**\n     * The decimal value represented by the IPv6 number in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the IPv6 number\n     */\n    readonly bitSize: number = 128;\n    /**\n     * The maximum bit size (i.e. binary value) of the IPv6 number in BigInteger\n     */\n    readonly maximumBitSize: bigInt.BigInteger = Validator.ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE;\n    /**\n     * The type of IP number. Value is one of the values of the {@link IPNumType} enum\n     * @type {IPNumType} the type of IP number\n     */\n    readonly type: IPNumType = IPNumType.IPv6;\n    /**\n     * An array of {@link Hexadecatet}'s\n     *\n     * @type {Array} the hexadecatet that makes up the IPv6 number\n     */\n    readonly hexadecatet: Array<Hexadecatet> = [];\n\n    /**\n     * The string character used to separate the individual hexadecatet when the IPv6 is rendered as strings\n     *\n     * @type {string} The string character used to separate the individual hexadecatet when rendered as strings\n     */\n    readonly separator: string = \":\";\n\n    /**\n     * A convenience method for creating an {@link IPv6} by providing the decimal value of the IP number in BigInteger\n     *\n     * @param {bigInt.BigInteger} bigIntValue the decimal value of the IP number in BigInteger\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromBigInteger(bigIntValue: bigInt.BigInteger): IPv6 {\n        return new IPv6(bigIntValue);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv6} by providing the IP number in hexadecatet notation. E.g\n     * \"2001:800:0:0:0:0:0:2002\"\n     *\n     * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more information on hexadecatet notation.\n     *\n     * @param {string} ipString the IP number in hexadecatet\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromHexadecimalString(ipString: string) : IPv6 {\n        return new IPv6(ipString);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv6} from binary string\n     *\n     * @param {string} ipBinaryString the binary string representing the IPv6 number to be created\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromBinaryString(ipBinaryString: string) : IPv6 {\n        let validationResult = Validator.isValidBinaryString(ipBinaryString);\n        if (validationResult[0]) {\n            let paddedBinaryString = leftPadWithZeroBit(ipBinaryString, 128);\n            return new IPv6(parseBinaryStringToBigInteger(paddedBinaryString));\n        } else {\n            throw Error(validationResult[1].join(','))\n        }\n    }\n\n    /**\n     * A convenience method for creating an IPv4-Compatible {@link IPv6} Address from an instance of {@link IPv4}\n     *\n     * @param {IPv4} ipv4 to create an IPv4-Compatible {@link IPv6} Address\n     * @returns {IPv6} the IPv4-Compatible {@link IPv6} Address\n     */\n    static fromIPv4(ipv4: IPv4): IPv6 {\n        return ipv4.toIPv4MappedIPv6();\n    }\n\n    /**\n     * A convenience method for creating an IPv4-Compatible {@link IPv6} Address from a IPv4 represented in\n     * dot-decimal notation i.e. 127.0.0.1\n     *\n     * @param {IPv4} ip4DotDecimalString string represented in a dot decimal string\n     * @returns {IPv6} the IPv4-Compatible {@link IPv6} Address\n     */\n    static fromIPv4DotDecimalString(ip4DotDecimalString: string): IPv6 {\n        return new IPv4(ip4DotDecimalString).toIPv4MappedIPv6();\n    }\n\n    /**\n     * Constructor for an IPv6 number.\n     *\n     * @param {string | bigInt.BigInteger} ipValue value to construct an IPv6 from. The given value can either be\n     * numeric or string. If a string is given then it needs to be in hexadecatet string notation\n     */\n    constructor(ipValue: string | bigInt.BigInteger) {\n        super();\n        if (typeof ipValue === \"string\" ) {\n            let expandedIPv6 = expandIPv6Number(ipValue);\n            let [value, hexadecatet] = this.constructFromHexadecimalDottedString(expandedIPv6);\n            this.value = value;\n            this.hexadecatet = hexadecatet;\n\n        } else {\n            let [value, hexadecatet] = this.constructFromBigIntegerValue(ipValue);\n            this.value = value;\n            this.hexadecatet = hexadecatet;\n        }\n    }\n\n    /**\n     * A string representation of the IPv6 number.\n     *\n     * @returns {string} The string representation of IPv6\n     */\n    public toString(): string {\n        let ipv6String = this.hexadecatet.map((value) => { return value.toString()}).join(\":\");\n        if (this.hexadecatet.length < 8) {\n            return \"::\" + ipv6String;\n        } else {\n            return ipv6String\n        }\n    }\n\n    /**\n     * Gets the individual {@link Hexadecatet} that makes up the IPv6 number\n     *\n     * @returns {Array<Hexadecatet>} The individual {@link Hexadecatet} that makes up the IPv6 number\n     */\n    //TODO maybe rename to something like getSegments? so it can be same with getOctet\n    public getHexadecatet():Array<Hexadecatet> {\n        return this.hexadecatet;\n    }\n\n    /**\n     * Returns the next IPv6 number\n     *\n     * @returns {IPv6} the next IPv6 number\n     */\n    public nextIPNumber(): IPv6 {\n        return IPv6.fromBigInteger(this.getValue().add(1))\n    }\n\n    /**\n     * Returns the previous IPv6 number\n     *\n     * @returns {IPv6} the previous IPv6 number\n     */\n    public previousIPNumber(): IPv6 {\n        return IPv6.fromBigInteger(this.getValue().minus(1))\n    }\n\n    private constructFromBigIntegerValue(ipv6Number: bigInt.BigInteger): [bigInt.BigInteger, Array<Hexadecatet>]  {\n        let [isValid, message] = Validator.isValidIPv6Number(ipv6Number);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let binaryString = bigIntegerNumberToBinaryString(ipv6Number);\n        return [ipv6Number, this.binaryStringToHexadecatets(binaryString)]\n    }\n\n    private constructFromHexadecimalDottedString(expandedIPv6: string): [bigInt.BigInteger, Array<Hexadecatet>] {\n        let [isValid, message] = Validator.isValidIPv6String(expandedIPv6);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringHexadecimals: string[] = expandedIPv6.split(\":\");\n        let hexadecatet: Hexadecatet[]  = stringHexadecimals.map((stringHexadecatet) => {\n            return Hexadecatet.fromString(stringHexadecatet);\n        });\n        let value = bigInt(hexadectetNotationToBinaryString(expandedIPv6), 2);\n        return [value, hexadecatet];\n    }\n\n    private binaryStringToHexadecatets(binaryString: string): Hexadecatet[] {\n        let hexadecimalString = binaryStringToHexadecimalString(binaryString);\n        let hexadecimalStrings: string[] = hexadecimalString.match(/.{1,4}/g)!;\n        return hexadecimalStrings.map((stringHexadecatet)=> {\n            return Hexadecatet.fromString(stringHexadecatet);\n        });\n    }\n}","import {Octet} from \"./Octet\";\nimport {Validator} from \"./Validator\";\nimport {IPNumber} from \"./interface/IPNumber\";\nimport * as bigInt from \"big-integer\"\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport {bigIntegerNumberToBinaryString} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {AbstractIPNum} from \"./AbstractIPNum\";\nimport {IPNumType} from \"./IPNumType\";\nimport {IPv6} from \"./IPv6\";\n\n/**\n * Represents an IPv4 number. A 32 bit number that is used to uniquely identify a device that is part of a computer\n * network that uses the internet protocol for communication.\n *\n * @see https://en.wikipedia.org/wiki/IPv4\n * @see https://www.rfc-editor.org/info/rfc791\n */\nexport class IPv4 extends AbstractIPNum implements IPNumber {\n    /**\n     * The decimal value represented by the IPv4 number in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the IPv4 number\n     */\n    readonly bitSize: number = 32;\n    /**\n     * The maximum bit size (i.e. binary value) of the IPv4 number in BigInteger\n     */\n    readonly maximumBitSize: bigInt.BigInteger = Validator.THIRTY_TWO_BIT_SIZE;\n    /**\n     * The type of IP number. Value is one of the values of the {@link IPNumType} enum\n     * @type {IPNumType} the type of IP number\n     */\n    readonly type: IPNumType = IPNumType.IPv4;\n    /**\n     * An array of {@link Octet}'s\n     *\n     * @type {Array} the octets that makes up the IPv4 number\n     */\n    readonly octets: Array<Octet> = [];\n\n    /**\n     * The string character used to separate the individual octets when the IPv4 is rendered as strings\n     *\n     * @type {string} The string character used to separate the individual octets when rendered as strings\n     */\n    readonly separator: string = \".\";\n\n    /**\n     * A convenience method for creating an {@link IPv4} by providing the decimal value of the IP number in BigInteger\n     *\n     * @param {bigInt.BigInteger} bigIntValue the decimal value of the IP number in BigInteger\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromBigInteger(bigIntValue: bigInt.BigInteger): IPv4 {\n        return new IPv4(bigIntValue);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv4} by providing the IP number in dot-decimal notation. E.g\n     * \"10.1.1.10\"\n     *\n     * {@see https://en.wikipedia.org/wiki/Dot-decimal_notation} for more information on dot-decimal notation.\n     *\n     * @param {string} ipString the IP number in dot-decimal notation\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromDecimalDottedString(ipString: string) : IPv4 {\n        return new IPv4(ipString);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv4} from binary string\n     *\n     * @param {string} ipBinaryString the binary string representing the IPv4 number to be created\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromBinaryString(ipBinaryString: string) : IPv4 {\n        let validationResult = Validator.isValidBinaryString(ipBinaryString);\n        if (validationResult[0]) {\n            return new IPv4(parseBinaryStringToBigInteger(ipBinaryString));\n        } else {\n            throw Error(validationResult[1].join(','))\n        }\n    }\n\n    /**\n     * Constructor for an IPv4 number.\n     *\n     * @param {string | bigInt.BigInteger} ipValue value to construct an IPv4 from. The given value can either be\n     * numeric or string. If a string is given then it needs to be in dot-decimal notation\n     */\n    constructor(ipValue: string | bigInt.BigInteger) {\n        super();\n        if (typeof ipValue === \"string\" ) {\n            let [value, octets] = this.constructFromDecimalDottedString(ipValue);\n            this.value = value;\n            this.octets = octets\n        } else {\n            let [value, octets] = this.constructFromBigIntegerValue(ipValue);\n            this.value = value;\n            this.octets = octets;\n        }\n    }\n\n    /**\n     * A string representation of the IPv4 number. The string representation is in dot-decimal notation\n     *\n     * @returns {string} The string representation in dot-decimal notation\n     */\n    public toString(): string {\n        return this.octets.map((value) => { return value.toString()}).join(this.separator);\n    }\n\n    /**\n     * Gets the individual {@link Octet} that makes up the IPv4 number\n     *\n     * @returns {Array<Octet>} The individual {@link Octet} that makes up the IPv4 number\n     */\n    public getOctets(): Array<Octet> {\n        return this.octets;\n    }\n\n    /**\n     * Returns the next IPv4 number\n     *\n     * @returns {IPv4} the next IPv4 number\n     */\n    public nextIPNumber(): IPv4 {\n        return IPv4.fromBigInteger(this.getValue().add(1))\n    }\n\n    /**\n     * Returns the previous IPv4 number\n     *\n     * @returns {IPv4} the previous IPv4 number\n     */\n    public previousIPNumber(): IPv4 {\n        return IPv4.fromBigInteger(this.getValue().minus(1))\n    }\n\n    /**\n     * Returns this IPv4 number as a IPv4-Mapped IPv6 Address\n     *\n     * The IPv4-Mapped IPv6 Address allows an IPv4 number to be embedded within an IPv6 number\n     *\n     * {@see https://tools.ietf.org/html/rfc4291#section-2.5.5} for more information on the IPv4-Mapped IPv6 Address\n     *\n     * @returns {IPv6} an IPv6 number with the IPv4 embedded within it\n     */\n    public toIPv4MappedIPv6(): IPv6 {\n        let binary = '1'.repeat(16) + this.toBinaryString();\n        return IPv6.fromBinaryString(binary);\n    }\n\n\n    private constructFromDecimalDottedString(ipString: string): [bigInt.BigInteger, Array<Octet>] {\n        let octets;\n        let value;\n        let [isValid, message] = Validator.isValidIPv4String(ipString);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let stringOctets = ipString.split(\".\");\n        octets = stringOctets.map((rawOctet) => {\n            return Octet.fromString(rawOctet)\n        });\n        value = bigInt(dottedDecimalNotationToBinaryString(ipString), 2);\n        return [value, octets]\n    }\n\n    private constructFromBigIntegerValue(ipv4Number: bigInt.BigInteger): [bigInt.BigInteger, Array<Octet>]  {\n        let [isValid, message] = Validator.isValidIPv4Number(ipv4Number);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let binaryString = bigIntegerNumberToBinaryString(ipv4Number);\n        return [ipv4Number, this.binaryStringToDecimalOctets(binaryString)]\n    }\n\n    private binaryStringToDecimalOctets(ipv4BinaryString: string): Array<Octet> {\n        if (ipv4BinaryString.length < 32) {\n            ipv4BinaryString = leftPadWithZeroBit(ipv4BinaryString, 32);\n        }\n        let octets: string[] = ipv4BinaryString.match(/.{1,8}/g)!;\n        return octets.map((octet) => {\n            return Octet.fromString(parseBinaryStringToBigInteger(octet).toString())\n        });\n    }\n}","import {Validator} from \"./Validator\";\nimport * as bigInt from \"big-integer\"\n\n/**\n * A base 16 (hexadecimal) representation of a 16 bit value.\n *\n * It consists of four (base 16) number.\n *\n * It is used to represents the components of an IPv6 address\n */\nexport class Hexadecatet {\n    private readonly value: number;\n\n    /**\n     * A convenience method for constructing an instance of {@link Hexadecatet} from a four (base 16) number\n     * representation of a 16bit value.\n     *\n     * @param {string} rawValue the four (base 16) number\n     * @returns {Hexadecatet} an instance of {@link Hexadecatet}\n     */\n    static fromString(rawValue:string):Hexadecatet {\n        return new Hexadecatet(rawValue);\n    };\n\n    /**\n     * A convenience method for constructing an instance of {@link Hexadecatet} from a decimal number representation\n     * of a 16 bit value\n     *\n     * @param {number} rawValue decimal number representation of a 16 bit value\n     * @returns {Hexadecatet} an instance of {@link Hexadecatet}\n     */\n    static fromNumber(rawValue:number):Hexadecatet {\n        return new Hexadecatet(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of {@link Hexadecatet}\n     *\n     * @param {string | number} givenValue a string or numeric value. If given value is a string then it should be a\n     * four (base 16) number representation of a 16bit value. If it is a number, then it should be a decimal number\n     * representation of a 16 bit value\n     */\n    constructor(givenValue: string | number) {\n        let hexadecatetValue: number;\n        if (typeof givenValue === 'string') {\n            hexadecatetValue = parseInt(givenValue, 16);\n        } else {\n            hexadecatetValue = parseInt(String(givenValue), 16);\n        }\n\n        let [isValid, message] = Validator.isValidIPv6Hexadecatet(bigInt(hexadecatetValue));\n\n        if (!isValid) {\n            throw Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = hexadecatetValue;\n    }\n\n    /**\n     * Returns the numeric value in base 10 (ie decimal)\n     *\n     * @returns {number} the numeric value in base 10 (ie decimal)\n     */\n    public getValue():number {\n        return this.value;\n    }\n\n    /**\n     * Returns the string representation of the base 16 representation of the value\n     * @returns {string} the string representation of the base 16 representation of the value\n     */\n    // TODO pad with a zero if digit is less than 4\n    public toString(): string {\n        return this.value.toString(16);\n    }\n}","import * as bigInt from \"big-integer\"\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\n\n/**\n * Provides the implementation of functionality that are common to {@link IPNumber}'s\n */\nexport abstract class AbstractIPNum {\n    /**\n     * The decimal value represented by the IP number in BigInteger\n     */\n    abstract readonly value: bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the IP number\n     */\n    abstract readonly bitSize: number;\n    /**\n     * The maximum bit size (i.e. binary value) of the IP number in BigInteger\n     */\n    abstract readonly maximumBitSize: bigInt.BigInteger;\n\n    /**\n     * Gets the numeric value of an IP number as {@link BigInteger}\n     *\n     * @returns {bigInt.BigInteger} the numeric value of an IP number.\n     */\n    public getValue():bigInt.BigInteger {\n        return this.value;\n    }\n\n    /**\n     * Gets the binary string representation of an IP number.\n     *\n     * @returns {string} the string binary representation.\n     */\n    public toBinaryString(): string {\n        return leftPadWithZeroBit(this.value.toString(2), this.bitSize);\n    }\n\n    /**\n     * Checks if an IP number has a value greater than the present value\n     * @returns {boolean} true, if there is a value greater than the present value. Returns false otherwise.\n     */\n    hasNext():boolean {\n        return this.value.lesser(this.maximumBitSize);\n    }\n\n    /**\n     * Checks if an IP number has a value lesser than the present value\n     * @returns {boolean} true, if there is a value lesser than the present value. Returns false otherwise.\n     */\n    hasPrevious():boolean {\n        return this.value.greater(bigInt.zero);\n    }\n\n    /**\n     * Checks if the given IP number, is equals to the current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is equals\n     */\n    public isEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.equals(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is lesser than this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is less than this current one. False otherwise.\n     */\n    public isLessThan(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.lt(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is greater than this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is greater than this current one. False otherwise.\n     */\n    public isGreaterThan(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.gt(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is less than or equals to this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is less than or equals to this current one. False otherwise.\n     */\n    public isLessThanOrEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.lesserOrEquals(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is greater than or equals to this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} {boolean} true if the given IP number is greater than or equals to this current one. False\n     * otherwise.\n     */\n    public isGreaterThanOrEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.greaterOrEquals(anotherIPNum.value);\n    }\n}","import {Validator} from \"./Validator\"\nimport bigInt = require(\"big-integer\");\n\n/**\n * A binary representation of a 8 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Octet_(computing)} for more information on Octets\n *\n * An octet is used in the textual representation of an {@link IPv4} number, where the IP number value is divided\n * into 4 octets\n */\nexport class Octet {\n    private readonly value: number;\n\n    /**\n     * Convenience method for creating an Octet out of a string value representing the value of the octet\n     *\n     * @param {string} rawValue the octet value in string\n     * @returns {Octet} the Octet instance\n     */\n    static fromString(rawValue:string):Octet {\n        return new Octet(rawValue);\n    };\n\n    /**\n     * Convenience method for creating an Octet out of a numeric value representing the value of the octet\n     *\n     * @param {number} rawValue the octet value in number\n     * @returns {Octet} the Octet instance\n     */\n    static fromNumber(rawValue:number):Octet {\n        return new Octet(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of an Octet.\n     *\n     * The constructor parameter given could either be a string or number.\n     *\n     * If a string, it is the string representation of the numeric value of the octet\n     * If a number, it is the numeric representation of the value of the octet\n     *\n     * @param {string | number} givenValue value of the octet to be created.\n     */\n    constructor(givenValue: string | number) {\n        let octetValue: number;\n        if (typeof givenValue === 'string') {\n            octetValue = parseInt(givenValue);\n        } else {\n            octetValue = givenValue;\n        }\n        let [isValid, message] = Validator.isValidIPv4Octet(bigInt(octetValue));\n        if (!isValid) {\n            throw Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = octetValue;\n    }\n\n    /**\n     * Method to get the numeric value of the octet\n     *\n     * @returns {number} the numeric value of the octet\n     */\n    public getValue():number {\n        return this.value;\n    }\n\n    /**\n     * Returns a decimal representation of the value of the octet in string\n     *\n     * @returns {string} a decimal representation of the value of the octet in string\n     */\n    public toString(): string {\n        return this.value.toString(10);\n    }\n}","import {Octet} from \"./Octet\";\nimport {Validator} from \"./Validator\";\nimport * as bigInt from \"big-integer\"\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport {Hexadecatet} from \"./Hexadecatet\";\nimport {hexadectetNotationToBinaryString} from \"./IPv6Utils\";\nimport {IPv4} from \"./IPv4\";\nimport {IPv6} from \"./IPv6\";\n\n/**\n * The IPv4SubnetMask can be seen as a specialized IPv4 number where, in a 32 bit number, starting from the left, you\n * have continuous bits turned on (with 1 value) followed by bits turned off (with 0 value). In networking, it is used\n * to demarcate which bits are used to identify a network, and the ones that are used to identify hosts on the network\n */\nexport class IPv4SubnetMask extends IPv4 {\n    /**\n     * An array of {@link Octet}'s\n     *\n     * @type {Array} the octets that makes up the IPv4SubnetMask\n     */\n    readonly octets: Array<Octet> = [];\n\n    /**\n     * The decimal value represented by the IPv4 subnet mask in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n\n    /**\n     * A convenience method for creating an instance of IPv4SubnetMask. The passed strings need to be a valid IPv4\n     * number in dot-decimal notation.\n     *\n     * @param {string} rawValue The passed string in dot-decimal notation\n     * @returns {IPv4SubnetMask} the instance of IPv4SubnetMask\n     */\n    static fromDecimalDottedString(rawValue:string):IPv4SubnetMask {\n        return new IPv4SubnetMask(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of IPv4SubnetMask.\n     * The passed strings need to be a valid IPv4 subnet mask number in dot-decimal notation.\n     *\n     * @param {string} ipString The passed string in dot-decimal notation\n     */\n    constructor(ipString: string) {\n        super(ipString);\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidIPv4SubnetMask(ipString);\n\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringOctets = ipString.split(\".\");\n        this.octets = stringOctets.map((rawOctet) => {\n            return Octet.fromString(rawOctet)\n        });\n        this.value = bigInt(dottedDecimalNotationToBinaryString(ipString), 2);\n    }\n}\n\n/**\n * The IPv6SubnetMask can be seen as a specialized IPv4 number where, in a 128 bit number, starting from the left,\n * you have continuous bits turned on (with 1 value) followed by bits turned off (with 0 value). In networking, it\n * is used to to demarcate which bits are used to identify a network, and the ones that are used to identify hosts\n * on the network\n */\nexport class IPv6SubnetMask extends IPv6 {\n    /**\n     * An array of {@link Hexadecatet}'s\n     *\n     * @type {Array} the hexadecatet that makes up the IPv6 number\n     */\n    readonly hexadecatet: Array<Hexadecatet> = [];\n\n    /**\n     * The decimal value represented by the IPv6 number in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n\n\n    /**\n     * A convenience method for creating an instance of IPv6SubnetMask.\n     * The passed strings need to be a valid IPv4 subnet mask number in dot-decimal notation.\n     *\n     * @param {string} rawValue The passed string in textual notation\n     * @returns {IPv6SubnetMask} the instance of IPv6SubnetMask\n     */\n    static fromHexadecimalString(rawValue:string):IPv6SubnetMask {\n        return new IPv6SubnetMask(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of IPv6SubnetMask.\n     * The passed strings need to be a valid IPv6 subnet mask number in dot-decimal notation\n     *\n     * @param {string} ipString The passed IPv6 string\n     */\n    constructor(ipString: string) {\n        super(ipString);\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidIPv6SubnetMask(ipString);\n\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringHexadecimals = ipString.split(\":\");\n        this.hexadecatet = stringHexadecimals.map((stringHexadecatet) => {\n            return Hexadecatet.fromString(stringHexadecatet)\n        });\n        this.value = bigInt(hexadectetNotationToBinaryString(ipString), 2);\n    }\n}","import * as bigInt from \"big-integer\";\nimport {Prefix} from \"./Prefix\";\nimport {IPv6} from \"./IPv6\";\nimport {IPv6CidrRange} from \"./IPv6CidrRange\";\nimport {IPv4CidrRange} from \"./IPv4CidrRange\";\nimport {IPv4} from \"./IPv4\";\n\n/**\n * Provides the implementation of functionality that are common to {@link IPRange}s\n */\n\nexport abstract class AbstractIpRange {\n\n    abstract readonly bitValue: bigInt.BigInteger;\n    abstract readonly cidrPrefix: Prefix;\n    abstract getFirst(): IPv6 | IPv4\n    abstract getLast(): IPv6 | IPv4\n\n    public getSize(): bigInt.BigInteger {\n        /**\n         * Using bitwise shit operation this will be\n         * 1 << (this.bitValue - this.prefix.getValue())\n         * Since left shift a number by x is equivalent to multiplying the number by the power x raised to 2\n         * 2 << 4 = 2 * (2 raised to 4)\n         */\n        return bigInt(2).pow(this.bitValue.minus(bigInt(this.cidrPrefix.getValue())));\n    }\n\n    public inside(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        let thisFirst: IPv6 | IPv4 = this.getFirst();\n        let thisLast: IPv6 | IPv4 = this.getLast();\n        let otherFirst: IPv6 | IPv4 = otherRange.getFirst();\n        let otherLast: IPv6 | IPv4 = otherRange.getLast();\n\n        return (otherFirst.isLessThanOrEquals(thisFirst) && otherLast.isGreaterThanOrEquals(thisLast));\n    }\n\n    public contains(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        let thisFirst: IPv6 | IPv4 = this.getFirst();\n        let thisLast: IPv6 | IPv4 = this.getLast();\n        let otherFirst: IPv6 | IPv4 = otherRange.getFirst();\n        let otherLast: IPv6 | IPv4 = otherRange.getLast();\n\n        return (thisFirst.isLessThanOrEquals(otherFirst) && thisLast.isGreaterThanOrEquals(otherLast));\n    }\n\n    public isOverlapping(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        let thisFirst: IPv6 | IPv4 = this.getFirst();\n        let thisLast: IPv6 | IPv4 = this.getLast();\n        let otherFirst: IPv6 | IPv4 = otherRange.getFirst();\n        let otherLast: IPv6 | IPv4 = otherRange.getLast();\n\n        return (\n            thisLast.isGreaterThan(otherFirst) && thisLast.isLessThanOrEquals(otherLast) && thisFirst.isLessThan(otherFirst)\n            ||\n            otherLast.isGreaterThan(thisFirst) && otherLast.isLessThanOrEquals(thisLast) && otherFirst.isLessThan(otherFirst)\n        );\n    }\n\n    public isConsecutive(otherRange: IPv6CidrRange | IPv4CidrRange): boolean {\n        let thisFirst: IPv6 | IPv4 = this.getFirst();\n        let thisLast: IPv6 | IPv4 = this.getLast();\n        let otherFirst: IPv6 | IPv4 = otherRange.getFirst();\n        let otherLast: IPv6 | IPv4 = otherRange.getLast();\n\n        return (\n            thisLast.hasNext() && thisLast.nextIPNumber().isEquals(otherFirst)\n            ||\n            otherLast.hasNext() && otherLast.nextIPNumber().isEquals(thisFirst)\n        )\n    }\n\n    public hasNextRange(): boolean {\n        let sizeOfCurrentRange = this.getSize();\n        return bigInt(2).pow(this.bitValue)\n            .minus(sizeOfCurrentRange)\n            .greaterOrEquals(this.getFirst().getValue().plus(sizeOfCurrentRange));\n    }\n\n    public hasPreviousRange(): boolean {\n        return this.getSize()\n            .lesserOrEquals(this.getFirst().getValue())\n    }\n\n}","import {IPv6Prefix} from \"./Prefix\";\nimport {IPv6} from \"./IPv6\";\nimport * as bigInt from \"big-integer\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {Validator} from \"./Validator\";\nimport {IPRange} from \"./interface/IPRange\";\nimport {AbstractIpRange} from \"./AbstractIpRange\";\n\n/**\n * Represents a continuous segment of IPv6 number following the\n * classless inter-domain routing scheme for allocating IP addresses.\n *\n * @see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n */\nexport class IPv6CidrRange extends AbstractIpRange implements IPRange, IterableIterator<IPv6> {\n    readonly bitValue: bigInt.BigInteger = bigInt(128);\n    private internalCounterValue: IPv6;\n\n    /**\n     * Convenience method for constructing an instance of an IPV6Range from an IP range represented in CIDR notation\n     *\n     * @param {string} rangeIncidrNotation the range of the IPv6 number in CIDR notation\n     * @returns {IPV6Range} the IPV6Range\n     */\n    static fromCidr(rangeIncidrNotation:string):IPv6CidrRange {\n        let [isValid, message] = Validator.isValidIPv6CidrNotation(rangeIncidrNotation);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let cidrComponents: Array<string> = rangeIncidrNotation.split(\"/\");\n        let ipString = cidrComponents[0];\n        let prefix = parseInt(cidrComponents[1]);\n\n        return new IPv6CidrRange(IPv6.fromHexadecimalString(ipString), IPv6Prefix.fromNumber(prefix));\n    };\n\n    /**\n     * Constructor for creating an instance of an IPv6 range.\n     *\n     * The arguments taken by the constructor is inspired by the CIDR notation which basically consists of the IP\n     * number and the prefix.\n     *\n     * @param {IPv6} ipv6 the IP number used to construct the range. By convention this is the first IP number in\n     * the range, but it could also be any IP number within the range\n     * @param {IPv6Prefix} cidrPrefix the prefix which is a representation of the number of bits used to mask the\n     * given IPv6 number in other to create the range\n     */\n    constructor(private readonly ipv6: IPv6, readonly cidrPrefix: IPv6Prefix) {\n        super();\n        this.internalCounterValue = this.getFirst();\n    }\n\n    /**\n     * Gets the size of IPv6 numbers contained within the IPv6 range\n     *\n     * @returns {bigInt.BigInteger} the amount of IPv6 numbers in the range\n     */\n    public getSize(): bigInt.BigInteger {\n        return super.getSize();\n    }\n\n    /**\n     * Method that returns the IPv6 range in CIDR (Classless Inter-Domain Routing) notation.\n     *\n     * See {@link https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation} for more information\n     * on the Classless Inter-Domain Routing notation\n     *\n     * @returns {string} the IPv6 range in CIDR (Classless Inter-Domain Routing) notation\n     */\n    public toCidrString(): string {\n        return `${this.ipv6.toString()}/${this.cidrPrefix.toString()}`\n    }\n\n    /**\n     * Method that returns the IPv6 range in string notation where the first IPv6 number and last IPv6 number are\n     * separated by an hyphen. eg. \"2001:db8:0:0:0:0:0:0-2001:db8:0:ffff:ffff:ffff:ffff:ffff\"\n     *\n     * @returns {string} the range in [first IPv6 number] - [last IPv6 number] format\n     */\n    public toRangeString(): string {\n        return `${this.getFirst()}-${this.getLast()}`\n    }\n\n    /**\n     * Method that returns the first IPv6 number in the IPv6 range\n     *\n     * @returns {IPv6} the first IPv6 number in the IPv6 range\n     */\n    public getFirst(): IPv6 {\n        return IPv6.fromBigInteger(this.ipv6.getValue().and(this.cidrPrefix.toSubnetMask().getValue()));\n    }\n\n    /**\n     * Method that returns the last IPv6 number in the IPv6 range\n     *\n     * @returns {IPv6} the last IPv6 number in the IPv6 range\n     */\n    public getLast(): IPv6 {\n        let onMask = bigInt(\"1\".repeat(128), 2);\n        let subnetMaskAsBigInteger = this.cidrPrefix.toSubnetMask().getValue();\n        let invertedSubnetMask = leftPadWithZeroBit(subnetMaskAsBigInteger.xor(onMask).toString(2), 128);\n        return IPv6.fromBigInteger(this.ipv6.getValue().or(parseBinaryStringToBigInteger(invertedSubnetMask)));\n    }\n\n    /**\n     * Indicates whether the given IPv6 range is an adjacent range.\n     *\n     * An adjacent range being one where the end of the given range, when incremented by one marks the start of the\n     * other range. Or where the start of the given range, when decreased by one, marks the end of the other range\n     *\n     * @param {IPv6CidrRange} otherRange the other IPv6 range to compare with\n     * @returns {boolean} true if the two IPv6 ranges are consecutive, false otherwise\n     */\n    public isConsecutive(otherRange: IPv6CidrRange): boolean {\n        return super.isConsecutive(otherRange);\n    }\n\n    /**\n     * Indicates if the given IPv6 range is a subset.\n     *\n     * By a subset range, it means all the values of the given range are contained by this IPv6 range\n     *\n     * @param {IPv6CidrRange} otherRange the other IPv6 range\n     * @returns {boolean} true if the other Ipv6 range is a subset. False otherwise.\n     */\n    public contains(otherRange: IPv6CidrRange): boolean {\n        return super.contains(otherRange);\n    }\n\n    /**\n     * Indicate if the given range is a container range.\n     *\n     * By container range, it means all the IP number in this current range can be found within the given range.\n     *\n     * @param {IPv6CidrRange} otherRange he other IPv6 range\n     * @returns {boolean} true if the other Ipv6 range is a container range. False otherwise.\n     */\n    public inside(otherRange: IPv6CidrRange): boolean {\n        return super.inside(otherRange);\n    }\n\n    /**\n     * Checks if two IPv6 ranges overlap\n     * @param {IPv6CidrRange} otherRange the other IPv6 range\n     * @returns {boolean} true if the ranges overlap, false otherwise\n     */\n    public isOverlapping(otherRange: IPv6CidrRange): boolean {\n        return super.isOverlapping(otherRange);\n    }\n\n    /**\n     * Method that takes IPv6 number from within an IPv6 range, starting from the first IPv6 number\n     *\n     * @param {number} count the amount of IPv6 number to take from the IPv6 range\n     * @returns {Array<IPv6>} an array of IPv6 number, taken from the IPv6 range\n     */\n    public take(count: number): Array<IPv6> {\n        let iPv6s: Array<IPv6>  = [this.getFirst()];\n        let iteratingIPv6 = this.getFirst();\n\n        if (bigInt(count).greater(this.getSize())) {\n            throw new Error(`${count.toString()} is greater than ${this.getSize().toString()}, the size of the range`);\n        }\n\n        for (var counter = 0; counter < count - 1; counter++) {\n            iPv6s.push(iteratingIPv6.nextIPNumber());\n            iteratingIPv6 = iteratingIPv6.nextIPNumber();\n        }\n        return iPv6s;\n    }\n\n    /**\n     * Method that splits an IPv6 range into two halves\n     *\n     * @returns {Array<IPv6CidrRange>} An array of two {@link IPv6CidrRange}\n     */\n    public split() : Array<IPv6CidrRange> {\n        let prefixToSplit = this.cidrPrefix.getValue();\n        if (prefixToSplit === 128) {\n            throw new Error(\"Cannot split an IP range with a single IP number\");\n        }\n        let splitCidr = IPv6Prefix.fromNumber(prefixToSplit + 1);\n        let firstIPOfFirstRange = this.getFirst();\n        let firstRange = new IPv6CidrRange(firstIPOfFirstRange, splitCidr);\n        let firstIPOfSecondRange = firstRange.getLast().nextIPNumber();\n        let secondRange = new IPv6CidrRange(firstIPOfSecondRange, splitCidr);\n        return [firstRange, secondRange];\n    }\n\n    public hasNextRange(): boolean {\n        return super.hasNextRange();\n    }\n\n    public hasPreviousRange(): boolean {\n        return super.hasPreviousRange();\n    }\n\n    public nextRange(): IPv6CidrRange | undefined {\n        if (this.hasNextRange()) {\n            let sizeOfCurrentRange = this.getSize();\n            let startOfNextRange = this.getFirst().getValue().plus(sizeOfCurrentRange);\n            return new IPv6CidrRange(new IPv6(startOfNextRange), this.cidrPrefix)\n        }\n        return;\n    }\n\n    public previousRange(): IPv6CidrRange | undefined {\n        if (this.hasPreviousRange()) {\n            let sizeOfCurrentRange = this.getSize();\n            let startOfPreviousRange = this.getFirst().getValue().minus(sizeOfCurrentRange);\n            return new IPv6CidrRange(new IPv6(startOfPreviousRange), this.cidrPrefix)\n        }\n        return;\n    }\n\n    next(value?: any): IteratorResult<IPv6>;\n    next(value?: any): IteratorResult<IPv6>;\n    next(value?: any) {\n        let returnValue = this.internalCounterValue;\n        this.internalCounterValue = this.internalCounterValue.nextIPNumber();\n\n        if (returnValue.isLessThanOrEquals(this.getLast())) {\n            return {\n                done:false,\n                value: returnValue\n            }\n        } else {\n            return {\n                done:true\n            }\n        }\n    }\n\n    [Symbol.iterator](): IterableIterator<IPv6> {\n        return this;\n    }\n}","import {IPv4} from \"./IPv4\";\nimport {IPv4Prefix} from \"./Prefix\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {Validator} from \"./Validator\";\nimport * as bigInt from \"big-integer\";\nimport {IPRange} from \"./interface/IPRange\";\nimport {AbstractIpRange} from \"./AbstractIpRange\";\n\n/**\n * Represents a continuous segment of IPv4 numbers following the\n * classless inter-domain routing scheme for allocating IP addresses.\n *\n * @see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n */\nexport class IPv4CidrRange extends AbstractIpRange implements IPRange, IterableIterator<IPv4> {\n    readonly bitValue: bigInt.BigInteger = bigInt(32);\n    private internalCounterValue: IPv4;\n\n    /**\n     * Convenience method for constructing an instance of an IPv4CidrRange from an IP range represented in CIDR notation\n     *\n     * @param {string} rangeIncidrNotation the range of the IPv4 number in CIDR notation\n     * @returns {IPv4CidrRange} the IPv4CidrRange\n     */\n    static fromCidr(rangeIncidrNotation:string):IPv4CidrRange {\n        let [isValid, errorMessages] = Validator.isValidIPv4CidrNotation(rangeIncidrNotation);\n        if (!isValid) {\n            let messages = errorMessages.filter(message => {return message !== ''});\n            throw new Error(messages.join(' and '));\n        }\n        let cidrComponents: Array<string> = rangeIncidrNotation.split(\"/\");\n        let ipString = cidrComponents[0];\n        let prefix = parseInt(cidrComponents[1]);\n        return new IPv4CidrRange(IPv4.fromDecimalDottedString(ipString), IPv4Prefix.fromNumber(prefix));\n    };\n\n    /**\n     * Constructor for creating an instance of an IPv4 range.\n     *\n     * The arguments taken by the constructor is inspired by the CIDR notation which basically consists of the IP\n     * number and the prefix.\n     *\n     * @param {IPv4} ipv4 the IP number used to construct the range. By convention this is the first IP number in\n     * the range, but it could also be any IP number within the range\n     * @param {IPv4Prefix} cidrPrefix the prefix which is a representation of the number of bits used to mask the\n     * given IP number in other to create the range\n     */\n    constructor(private readonly ipv4: IPv4, readonly cidrPrefix: IPv4Prefix) {\n        super();\n        this.internalCounterValue = this.getFirst();\n    }\n\n    /**\n     * Gets the size of IPv4 numbers contained within the IPv4 range\n     *\n     * @returns {bigInt.BigInteger} the amount of IPv4 numbers in the range\n     */\n    public getSize(): bigInt.BigInteger {\n        return super.getSize();\n    }\n\n    /**\n     * Method that returns the IPv4 range in CIDR (Classless Inter-Domain Routing) notation.\n     *\n     * See {@link https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation} for more information\n     * on the Classless Inter-Domain Routing notation\n     *\n     * @returns {string} the IPv4 range in CIDR (Classless Inter-Domain Routing) notation\n     */\n    public toCidrString(): string {\n        return `${this.ipv4.toString()}/${this.cidrPrefix.toString()}`\n    }\n\n    /**\n     * Method that returns the IPv4 range in string notation where the first IPv4 number and last IPv4 number are\n     * separated by an hyphen. eg. 192.198.0.0-192.198.0.255\n     *\n     * @returns {string} the range in [first IPv4 number] - [last IPv4 number] format\n     */\n    public toRangeString(): string {\n        return `${this.getFirst()}-${this.getLast()}`\n    }\n\n\n    /**\n     * Method that returns the first IPv4 number in the IPv4 range\n     *\n     * @returns {IPv4} the first IPv4 number in the IPv4 range\n     */\n    public getFirst(): IPv4 {\n        return IPv4.fromBigInteger(this.ipv4.getValue().and(this.cidrPrefix.toSubnetMask().getValue()));\n    }\n\n    /**\n     * Method that returns the last IPv4 number in the IPv4 range\n     *\n     * @returns {IPv4} the last IPv4 number in the IPv4 range\n     */\n    public getLast(): IPv4 {\n        let onMask = bigInt(\"1\".repeat(32), 2);\n        let subnetAsBigInteger = this.cidrPrefix.toSubnetMask().getValue();\n        let invertedSubnet = leftPadWithZeroBit(subnetAsBigInteger.xor(onMask).toString(2), 32);\n        return IPv4.fromBigInteger(this.ipv4.getValue().or(parseBinaryStringToBigInteger(invertedSubnet)));\n    }\n\n    /**\n     * Indicates whether the given IPv4 range is an adjacent range.\n     *\n     * An adjacent range being one where the end of the given range, when incremented by one marks the start of the\n     * other range. Or where the start of the given range, when decreased by one, marks the end of the other range\n     *\n     * @param {IPv4CidrRange} otherRange the other IPv4 range to compare with\n     * @returns {boolean} true if the two IPv4 ranges are consecutive, false otherwise\n     */\n    public isConsecutive(otherRange: IPv4CidrRange): boolean {\n        return super.isConsecutive(otherRange);\n    }\n\n    /**\n     * Indicates if the given IPv4 range is a subset.\n     *\n     * By a subset range, it means all the values of the given range are contained by this IPv4 range\n     *\n     * @param {IPv4CidrRange} otherRange the other IPv4 range\n     * @returns {boolean} true if the other Ipv4 range is a subset. False otherwise.\n     */\n    public contains(otherRange: IPv4CidrRange): boolean {\n        return super.contains(otherRange);\n    }\n\n    /**\n     * Indicate if the given range is a container range.\n     *\n     * By container range, it means all the IP number in this current range can be found within the given range.\n     *\n     * @param {IPv4CidrRange} otherRange he other IPv4 range\n     * @returns {boolean} true if the other Ipv4 range is a container range. False otherwise.\n     */\n    public inside(otherRange: IPv4CidrRange): boolean {\n        return super.inside(otherRange);\n    }\n\n    /**\n     * Checks if two IPv4 ranges overlap\n     * @param {IPv4CidrRange} otherRange the other IPv4 range\n     * @returns {boolean} true if the ranges overlap, false otherwise\n     */\n    public isOverlapping(otherRange: IPv4CidrRange): boolean {\n        return super.isOverlapping(otherRange);\n    }\n\n    /**\n     * Method that takes IPv4 number from within an IPv4 range, starting from the first IPv4 number\n     *\n     * @param {number} count the amount of IPv4 number to take from the IPv4 range\n     * @returns {Array<IPv4>} an array of IPv4 number, taken from the IPv4 range\n     */\n    public take(count: number): Array<IPv4> {\n        let ipv4s: Array<IPv4>  = [this.getFirst()];\n        let iteratingIPv4 = this.getFirst();\n\n        if (bigInt(count).greater(this.getSize())) {\n            let errMessage = Validator.takeOutOfRangeSizeMessage\n                .replace(\"$count\", count.toString())\n                .replace(\"$size\", this.getSize().toString());\n            throw new Error(errMessage);\n        }\n\n        for (var counter = 0; counter < count - 1; counter++) {\n            ipv4s.push(iteratingIPv4.nextIPNumber());\n            iteratingIPv4 = iteratingIPv4.nextIPNumber();\n        }\n        return ipv4s;\n    }\n\n    /**\n     * Method that splits an IPv4 range into two halves\n     *\n     * @returns {Array<IPv4CidrRange>} An array of two {@link IPv4CidrRange}\n     */\n    public split() : Array<IPv4CidrRange> {\n        let prefixToSplit = this.cidrPrefix.getValue();\n        if (prefixToSplit === 32) {\n            throw new Error(\"Cannot split an IP range with a single IP number\");\n        }\n        let splitCidr = IPv4Prefix.fromNumber(prefixToSplit + 1);\n        let firstIPOfFirstRange = this.getFirst();\n        let firstRange = new IPv4CidrRange(firstIPOfFirstRange, splitCidr);\n        let firstIPOfSecondRange = firstRange.getLast().nextIPNumber();\n        let secondRange = new IPv4CidrRange(firstIPOfSecondRange, splitCidr);\n        return [firstRange, secondRange];\n    }\n\n    public hasNextRange(): boolean {\n        return super.hasNextRange();\n    }\n\n    public hasPreviousRange(): boolean {\n        return super.hasPreviousRange();\n    }\n\n    public nextRange(): IPv4CidrRange | undefined {\n        if (this.hasNextRange()) {\n            let sizeOfCurrentRange = this.getSize();\n            let startOfNextRange = this.getFirst().getValue().plus(sizeOfCurrentRange);\n            return new IPv4CidrRange(new IPv4(startOfNextRange), this.cidrPrefix)\n        }\n\n        return;\n    }\n\n    public previousRange(): IPv4CidrRange | undefined {\n        if (this.hasPreviousRange()) {\n            let sizeOfCurrentRange = this.getSize();\n            let startOfPreviousRange = this.getFirst().getValue().minus(sizeOfCurrentRange);\n            return new IPv4CidrRange(new IPv4(startOfPreviousRange), this.cidrPrefix)\n        }\n\n        return;\n    }\n\n    next(value?: any): IteratorResult<IPv4>;\n    next(value?: any): IteratorResult<IPv4>;\n    next(value?: any) {\n        let returnValue = this.internalCounterValue;\n        this.internalCounterValue = this.internalCounterValue.nextIPNumber();\n\n        if (returnValue.isLessThanOrEquals(this.getLast())) {\n            return {\n                done:false,\n                value: returnValue\n            }\n        } else {\n            return {\n                done:true\n            }\n        }\n    }\n\n    [Symbol.iterator](): IterableIterator<IPv4> {\n        return this;\n    }\n}","import {Validator} from \"./Validator\"\nimport {IPNumber} from \"./interface/IPNumber\"\nimport {decimalNumberToBinaryString} from \"./BinaryUtils\";\nimport * as bigInt from \"big-integer\"\nimport {IPNumType} from \"./IPNumType\";\nimport {AbstractIPNum} from \"./AbstractIPNum\";\n\n/**\n * Represents an Autonomous System Number. Which is a number that is used to identify\n * a group of IP addresses with a common, clearly defined routing policy.\n *\n * @see https://en.wikipedia.org/wiki/Autonomous_system_(Internet)\n * @see https://www.rfc-editor.org/info/rfc4271\n */\nexport class Asn extends AbstractIPNum implements IPNumber {\n    /**\n     * The decimal value represented by the ASN number in BigInteger\n     */\n    readonly value:bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the ASN number\n     */\n    bitSize: number = 32;\n    /**\n     * The maximum bit size (i.e. binary value) of the ASN number in BigInteger\n     */\n    maximumBitSize: bigInt.BigInteger = Validator.THIRTY_TWO_BIT_SIZE;\n\n    type: IPNumType = IPNumType.ASN;\n    private static AS_PREFIX = \"AS\";\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a string\n     *\n     * The given string can be in asplain, asdot or asdot+ representation format.\n     * {@see https://tools.ietf.org/html/rfc5396} for more information on\n     * the different ASN string representation\n     *\n     * @param {string} rawValue the asn string. In either asplain, asdot or asdot+ format\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromString(rawValue:string):Asn {\n        return new Asn(rawValue);\n    };\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a numeric value\n     *\n     * @param {number} rawValue the asn numeric value\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromNumber(rawValue:number):Asn {\n        return new Asn(rawValue);\n    };\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a binary string\n     *\n     * @param {string} binaryString to create an ASN instance from\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromBinaryString(binaryString: string): Asn {\n        let validationResult = Validator.isValidBinaryString(binaryString);\n        if (validationResult[0]) {\n            return new Asn(parseInt(binaryString, 2))\n        } else {\n            throw Error(validationResult[1].join(','))\n        }\n    }\n\n    /**\n     * Constructor for an instance of {@link ASN}\n     *\n     * @param {string | number} rawValue value to construct an ASN from. The given value can either be numeric or\n     * string. If in string then it can be in asplain, asdot or asdot+ string representation format\n     */\n    constructor(rawValue:string | number) {\n        super();\n        if (typeof rawValue === 'string') {\n            if (Asn.startWithASprefix(rawValue)) {\n                this.value = bigInt(parseInt(rawValue.substring(2)));\n            } else if(rawValue.indexOf(\".\") != -1) {\n                this.value = bigInt(this.parseFromDotNotation(rawValue));\n            } else {\n                this.value = bigInt(parseInt(rawValue));\n            }\n        } else {\n            let valueAsBigInt = bigInt(rawValue);\n            let [isValid, message] = Validator.isValidAsnNumber(valueAsBigInt);\n            if (!isValid) {\n                throw Error(message.filter(msg => {return msg !== '';}).toString());\n            }\n            this.value = valueAsBigInt;\n        }\n    }\n\n    /**\n     * A string representation where the asn value is prefixed by \"ASN\". For example \"AS65526\"\n     *\n     * @returns {string} A string representation where the asn value is prefixed by \"ASN\"\n     */\n    toString():string {\n        let stringValue = this.value.toString();\n        return `${Asn.AS_PREFIX}${stringValue}`;\n    }\n\n    /**\n     * A string representation where the ASN numeric value of is represented as a string. For example \"65526\"\n     *\n     * @returns {string} A string representation where the ASN numeric value of is represented as a string\n     */\n    toASPlain():string {\n        return this.value.toString();\n    }\n\n    /**\n     * A string representation where the ASN value is represented using the asplain notation if the ASN value is\n     * less than 65536 and uses asdot+ notation when the value is greater than 65536.\n     *\n     * For example 65526 will be represented as \"65526\" while 65546 will be represented as \"1.10\"\n     *\n     *\n     * @returns {string} A string representation of the ASN in either asplain or asdot+ notation depending on\n     * whether the numeric value of the ASN number is greater than 65526 or not.\n     */\n    toASDot():string {\n        if (this.value.valueOf() >= 65536) {\n            return this.toASDotPlus();\n        }\n        return this.toASPlain();\n    }\n\n    /**\n     * A string representation where the ASN value is represented using the asdot+ notation\n     *\n     * @returns {string} A string representation where the ASN value is represented using the asdot+ notation\n     *\n     */\n    toASDotPlus():string {\n        let high = Math.floor(this.value.valueOf() / 65535);\n        let low = (this.value.valueOf() % 65535) - high;\n        return `${high}.${low}`;\n    }\n\n    /**\n     * Converts the ASN value to binary numbers represented with strings\n     *\n     * @returns {string} a binary string representation of the value of the ASN number\n     */\n    toBinaryString():string {\n        return decimalNumberToBinaryString(this.value.valueOf());\n    }\n\n    /**\n     * Checks if the ASN value is 16bit\n     *\n     * @returns {boolean} true if the ASN is a 16bit value. False otherwise.\n     */\n    is16Bit():boolean {\n        let [valid16BitAsnNumber,] = Validator.isValid16BitAsnNumber(this.value);\n        return valid16BitAsnNumber;\n    }\n\n    /**\n     * Checks if the ASN value is 32bit\n     *\n     * @returns {boolean} true if the ASN is a 32bit value. False otherwise.\n     */\n    is32Bit():boolean {\n        return !this.is16Bit();\n    }\n\n    /**\n     * Returns the next ASN number\n     *\n     * @returns {IPNumber} the next ASN number\n     */\n    nextIPNumber(): IPNumber {\n        return new Asn(this.value.valueOf() + 1);\n    }\n\n    /**\n     * Returns the previous ASN number\n     *\n     * @returns {IPNumber} the previous ASN number\n     */\n    previousIPNumber(): IPNumber {\n        return new Asn(this.value.valueOf() - 1)\n    }\n\n    private static startWithASprefix(word:string):boolean {\n        return word.indexOf(Asn.AS_PREFIX) === 0;\n    }\n\n    private parseFromDotNotation(rawValue: string): number {\n        let values: string[] = rawValue.split(\".\");\n        let high = parseInt(values[0]);\n        let low = parseInt(values[1]);\n        return (high * 65535) + (low + high);\n    }\n}","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/**\n * Exposes all the library's modules making them available from the \"ip-num\" module.\n * Making it possible to get access to all any of the modules by doing require(\"ip-num\")\n *\n * @example\n * let ipNum = require(\"ip-num\")\n * ipNum.IPv4CidrRange // gets access to IPv4CidrRange\n * ipNum.Asn // gets access to Asn\n */\nexport * from './interface/IPNumber'\nexport * from './interface/IPRange'\nexport * from './AbstractIPNum'\nexport * from './Asn'\nexport * from './BinaryUtils'\nexport * from './Hexadecatet'\nexport * from './HexadecimalUtils'\nexport * from './IPNumType'\nexport * from './IPv4'\nexport * from './IPv4CidrRange'\nexport * from './IPv6'\nexport * from './IPv6CidrRange'\nexport * from './IPv6Utils'\nexport * from './Octet'\nexport * from './Prefix'\nexport * from './SubnetMask'\nexport * from './Validator'"],"sourceRoot":""}