{"version":3,"sources":["webpack:///webpack/bootstrap 624b4aec3a0cb4117eb5","webpack:////Users/daderemi/Documents/play/ip-num/src/BinaryUtils.ts","webpack:////Users/daderemi/Documents/play/ip-num/node_modules/big-integer/BigInteger.js","webpack:////Users/daderemi/Documents/play/ip-num/src/Validator.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/IPNumType.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/IPv6Utils.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/AbstractIPNum.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/HexadecimalUtils.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/Hexadecatet.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/Octet.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/Prefix.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/Subnet.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/IPv4.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/IPv6.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/index.ts","webpack:///(webpack)/buildin/module.js","webpack:////Users/daderemi/Documents/play/ip-num/src/Asn.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/IPv4Range.ts","webpack:////Users/daderemi/Documents/play/ip-num/src/IPv6Range.ts"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7DA,sCAAiD;AAEjD;;;;;GAKG;AAEQ,mCAA2B,GAAG,CAAC,GAAU;IAChD,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC;AAEF;;;;GAIG;AACQ,sCAA8B,GAAG,CAAC,GAAsB;IAC/D,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;AAC3B,CAAC,CAAC;AAGF;;;;;;GAMG;AACQ,kCAA0B,GAAG,CAAC,GAAU;IAC/C,IAAI,YAAY,GAAG,mCAA2B,CAAC,GAAG,CAAC,CAAC;IACpD,IAAI,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC;IACjC,EAAE,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QACb,MAAM,IAAI,KAAK,CAAC,+DAA+D,CAAC;IACpF,CAAC;IACD,MAAM,CAAC,0BAAkB,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;AAC/C,CAAC,CAAC;AAEF;;;;;GAKG;AACQ,qCAA6B,GAAG,CAAC,GAAU;IAClD,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;AAC1B,CAAC,CAAC;AAEF;;;;;;GAMG;AACQ,2CAAmC,GAAG,CAAC,aAAqB;IACnE,IAAI,YAAY,GAAG,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAC5C,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,cAAc,EAAE,KAAK;QAC7C,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,kCAA0B,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC9E,CAAC,EAAE,EAAE,CAAC,CAAC;AACX,CAAC,CAAC;AAEF;;;;;GAKG;AACQ,0BAAkB,GAAG,CAAC,YAAoB,EAAE,iBAAyB;IAC5E,EAAE,CAAC,CAAC,YAAY,CAAC,MAAM,GAAG,iBAAiB,CAAC,CAAC,CAAC;QAC1C,MAAM,IAAI,KAAK,CAAC,uCAAuC,iBAAiB,EAAE,CAAC,CAAC;IAChF,CAAC;IACD,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,iBAAiB,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;AACpF,CAAC,CAAC;;;;;;;8CC1EF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA,8DAA8D;AAC9D;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,cAAc,EAAE;AACjE;AACA;;AAEA;AACA,iDAAiD,cAAc,EAAE;AACjE;AACA;;AAEA;AACA,iDAAiD,cAAc,EAAE;AACjE;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAK,EAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6DAA6D;AACpG;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AAAA;AACH;;;;;;;;;ACjtCa;;AACb,6CAAkE;AAClE,sCAAsC;AACtC,2CAAsC;AACtC,2CAA6D;AAE7D;IAyBI;;;;;;;OAOG;IACK,MAAM,CAAC,aAAa,CAAC,QAA2B,EAAE,UAA6B,EAAE,UAA6B;QAClH,MAAM,CAAC,QAAQ,CAAC,eAAe,CAAC,UAAU,CAAC,IAAI,QAAQ,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;IACvF,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,gBAAgB,CAAC,SAA4B;QAChD,IAAI,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC;QACnF,MAAM,CAAC,CAAC,OAAO,EAAE,OAAO,GAAG,EAAE,GAAE,CAAC,SAAS,CAAC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","file":"../../ip-num.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 624b4aec3a0cb4117eb5","import * as bigInt from \"big-integer/BigInteger\";\n\n/**\n * Converts a decimal number to binary string\n *\n * @param num number to parse\n * @returns {string} the binary string representation of number\n */\n\nexport let decimalNumberToBinaryString = (num:number):string => {\n    return Number(num).toString(2);\n};\n\n/**\n * Converts a given BigInteger number to a binary string\n * @param num the BigInteger number\n * @returns {string} the binary string\n */\nexport let bigIntegerNumberToBinaryString = (num: bigInt.BigInteger): string => {\n    return num.toString(2);\n};\n\n\n/**\n * Converts a decimal number to binary octet (8 bit) string. If needed the octet will be padded with zeros\n * to make it up to 8 bits\n *\n * @param {number} num to convert to octet string\n * @returns {string} the octet string representation of given number\n */\nexport let decimalNumberToOctetString = (num:number): string => {\n    let binaryString = decimalNumberToBinaryString(num);\n    let length = binaryString.length;\n    if (length > 8) {\n        throw new Error(\"Given decimal in binary contains digits greater than an octet\")\n    }\n    return leftPadWithZeroBit(binaryString, 8);\n};\n\n/**\n * Parses number in binary to number in BigInteger\n *\n * @param num binary number in string to parse\n * @returns {number} binary number in BigInteger\n */\nexport let parseBinaryStringToBigInteger = (num:string): bigInt.BigInteger => {\n    return bigInt(num, 2);\n};\n\n/**\n * Given an IPv4 number in dot-decimal notated string, e.g 192.168.0.1 converts it to\n * binary string, e.g. '11000000101010000000000000000001'\n *\n * @param dottedDecimal IPv4 string in dot-decimal notation\n * @returns {string} the binary value of the given ipv4 number in string\n */\nexport let dottedDecimalNotationToBinaryString = (dottedDecimal: string): string => {\n    let stringOctets = dottedDecimal.split(\".\");\n    return stringOctets.reduce((binaryAsString, octet) => {\n        return binaryAsString.concat(decimalNumberToOctetString(parseInt(octet)));\n    }, '');\n};\n\n/**\n * Given a binary string, adds a number of zero to the left until string is as long as the given string length\n * @param {string} binaryString the string to pad\n * @param {number} finalStringLength the final length of string after padding\n * @returns {string}\n */\nexport let leftPadWithZeroBit = (binaryString: string, finalStringLength: number): string => {\n    if (binaryString.length > finalStringLength) {\n        throw new Error(`Given string is already longer than ${finalStringLength}`);\n    }\n    return \"0\".repeat(finalStringLength - binaryString.length).concat(binaryString);\n};\n\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/BinaryUtils.ts","var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        LOG_MAX_INT = Math.log(MAX_INT);\r\n\r\n    function Integer(v, radix) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 ? parseValue(v) : parseBase(v, radix);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a,b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n            if (isPrecise(a.value * this.value)) {\r\n                return new SmallInteger(a.value * this.value);\r\n            }\r\n            return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n            if (a.value === 0) return Integer[0];\r\n            if (a.value === 1) return this;\r\n            if (a.value === -1) return this.negate();\r\n            return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    function square(a) {\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < l; j++) {\r\n                a_j = a[j];\r\n                product = a_i * a_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        var value = n.value;\r\n        if (value === 0) return false;\r\n        if (value === 1) return true;\r\n        if (value === 2) return this.isEven();\r\n        return this.mod(n).equals(Integer[0]);\r\n    };\r\n    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(25)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    BigInteger.prototype.isPrime = function () {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs(),\r\n            nPrev = n.prev();\r\n        var a = [2, 3, 5, 7, 11, 13, 17, 19],\r\n            b = nPrev,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2);\r\n        for (i = 0; i < a.length; i++) {\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;\r\n            for (t = true, d = b; t && d.lesser(nPrev) ; d = d.multiply(2)) {\r\n                x = x.square().mod(n);\r\n                if (x.equals(nPrev)) t = false;\r\n            }\r\n            if (t) return false;\r\n        }\r\n        return true;\r\n    };\r\n    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        // use the Fermat primality test\r\n        for (var i = 0; i < t; i++) {\r\n            var a = bigInt.randBetween(2, n.minus(2));\r\n            if (!a.modPow(n.prev(), n).isUnit()) return false; // definitely composite\r\n        }\r\n        return true; // large chance of being prime\r\n    };\r\n    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.equals(bigInt.zero)) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.equals(1)) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n\r\n    var powersOfTwo = [1];\r\n    while (powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return ((typeof n === \"number\" || typeof n === \"string\") && +Math.abs(n) <= BASE) ||\r\n            (n instanceof BigInteger && n.value.length <= 1);\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (n) {\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (n) {\r\n        var remQuo;\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        n = +n;\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero()) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xBits = [], yBits = [];\r\n        var xStop = false, yStop = false;\r\n        while (!xStop || !yStop) {\r\n            if (xRem.isZero()) { // virtual sign extension for simulating two's complement\r\n                xStop = true;\r\n                xBits.push(xSign ? 1 : 0);\r\n            }\r\n            else if (xSign) xBits.push(xRem.isEven() ? 1 : 0); // two's complement for negative numbers\r\n            else xBits.push(xRem.isEven() ? 0 : 1);\r\n\r\n            if (yRem.isZero()) {\r\n                yStop = true;\r\n                yBits.push(ySign ? 1 : 0);\r\n            }\r\n            else if (ySign) yBits.push(yRem.isEven() ? 1 : 0);\r\n            else yBits.push(yRem.isEven() ? 0 : 1);\r\n\r\n            xRem = xRem.over(2);\r\n            yRem = yRem.over(2);\r\n        }\r\n        var result = [];\r\n        for (var i = 0; i < xBits.length; i++) result.push(fn(xBits[i], yBits[i]));\r\n        var sum = bigInt(result.pop()).negate().times(bigInt(2).pow(result.length));\r\n        while (result.length) {\r\n            sum = sum.add(bigInt(result.pop()).times(bigInt(2).pow(result.length)));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value, x = typeof v === \"number\" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = Math.min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low);\r\n        if (range.isSmall) return low.add(Math.round(Math.random() * range));\r\n        var length = range.value.length - 1;\r\n        var result = [], restricted = true;\r\n        for (var i = length; i >= 0; i--) {\r\n            var top = restricted ? range.value[i] : BASE;\r\n            var digit = truncate(Math.random() * top);\r\n            result.unshift(digit);\r\n            if (digit < top) restricted = false;\r\n        }\r\n        result = arrayToSmall(result);\r\n        return low.add(typeof result === \"number\" ? new SmallInteger(result) : new BigInteger(result, false));\r\n    }\r\n    var parseBase = function (text, base) {\r\n        var length = text.length;\r\n        if (2 <= base && base <= 36) {\r\n            if (length <= LOG_MAX_INT / Math.log(base)) {\r\n                return new SmallInteger(parseInt(text, base));\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var i;\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i].toLowerCase(),\r\n                charCode = c.charCodeAt(0);\r\n            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));\r\n            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\");\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit) {\r\n        var v = digit.value;\r\n        if (typeof v === \"number\") v = [v];\r\n        if (v.length === 1 && v[0] <= 35) {\r\n            return \"0123456789abcdefghijklmnopqrstuvwxyz\".charAt(v[0]);\r\n        }\r\n        return \"<\" + v + \">\";\r\n    }\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return \"0\";\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return \"0\";\r\n            if (n.isNegative()) return new Array(1 - n).join(\"10\");\r\n            return \"1\" + new Array(+n).join(\"01\");\r\n        }\r\n        var minusSign = \"\";\r\n        if (n.isNegative() && base.isPositive()) {\r\n            minusSign = \"-\";\r\n            n = n.abs();\r\n        }\r\n        if (base.equals(1)) {\r\n            if (n.isZero()) return \"0\";\r\n            return minusSign + new Array(+n + 1).join(1);\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(stringify(digit));\r\n        }\r\n        out.push(stringify(left));\r\n        return minusSign + out.reverse().join(\"\");\r\n    }\r\n\r\n    BigInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBase(this, radix);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n    SmallInteger.prototype.toString = function (radix) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBase(this, radix);\r\n        return String(this.value);\r\n    };\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return +this.toString();\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n\r\n    function parseStringValue(v) {\r\n            if (isPrecise(+v)) {\r\n                var x = +v;\r\n                if (x === truncate(x))\r\n                    return new SmallInteger(x);\r\n                throw \"Invalid integer: \" + v;\r\n            }\r\n            var sign = v[0] === \"-\";\r\n            if (sign) v = v.slice(1);\r\n            var split = v.split(/e/i);\r\n            if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n            if (split.length === 2) {\r\n                var exp = split[1];\r\n                if (exp[0] === \"+\") exp = exp.slice(1);\r\n                exp = +exp;\r\n                if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n                var text = split[0];\r\n                var decimalPlace = text.indexOf(\".\");\r\n                if (decimalPlace >= 0) {\r\n                    exp -= text.length - decimalPlace - 1;\r\n                    text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n                }\r\n                if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n                text += (new Array(exp + 1)).join(\"0\");\r\n                v = text;\r\n            }\r\n            var isValid = /^([0-9][0-9]*)$/.test(v);\r\n            if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n            var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n            while (max > 0) {\r\n                r.push(+v.slice(min, max));\r\n                min -= l;\r\n                if (min < 0) min = 0;\r\n                max -= l;\r\n            }\r\n            trim(r);\r\n            return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = new SmallInteger(i);\r\n        if (i > 0) Integer[-i] = new SmallInteger(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif ( typeof define === \"function\" && define.amd ) {\r\n  define( \"big-integer\", [], function() {\r\n    return bigInt;\r\n  });\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/daderemi/Documents/play/ip-num/node_modules/big-integer/BigInteger.js\n// module id = 1\n// module chunks = 0","'use strict';\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport * as bigInt from \"big-integer\";\nimport {IPNumType} from \"./IPNumType\";\nimport {hexadectetNotationToBinaryString} from \"./IPv6Utils\";\n\nexport class Validator {\n    static IPV4_PATTERN: RegExp = new RegExp(/^(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/);\n    static IPV4_RANGE_PATTERN: RegExp = new RegExp(/^(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.(0?[0-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\/)([1-9]|[1-2][0-9]|3[0-2])$/);\n    static IPV6_RANGE_PATTERN: RegExp = new RegExp(/^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8]))?$/);\n    static IPV4_SUBNET_BIT_PATTERN: RegExp = new RegExp(/^(1){0,32}(0){0,32}$/);\n    static IPV6_SUBNET_BIT_PATTERN: RegExp = new RegExp(/^(1){0,128}(0){0,128}$/);\n\n    static EIGHT_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(8), 2);\n    static SIXTEEN_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(16), 2);\n    static THIRTY_TWO_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(32), 2);\n    static ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE: bigInt.BigInteger = bigInt(\"1\".repeat(128), 2);\n\n    static invalidAsnRangeMessage = \"ASN number given less than zero or is greater than 32bit\";\n    static invalid16BitAsnRangeMessage = \"ASN number given less than zero or is greater than 16bit\";\n    static invalidIPv4NumberMessage = \"IPv4 number given less than zero or is greater than 32bit\";\n    static invalidIPv6NumberMessage = \"IPv6 number given less than zero or is greater than 128bit\";\n    static invalidOctetRangeMessage = \"Value given contains an invalid Octet; Value is less than zero or is greater than 8bit\";\n    static invalidHexadecatetMessage = \"The value given is less than zero or is greater than 16bit\";\n    static invalidOctetCountMessage = \"An IP4 number cannot have less or greater than 4 octets\";\n    static invalidHexadecatetCountMessage = \"An IP6 number cannot have less or greater than 8 octets\";\n    static invalidSubnetMessage = \"The Subnet is invalid\";\n    static invalidPrefixValueMessage = \"A Prefix value cannot be less than 0 or greater than 32\";\n    static invalidIPv4CidrNotationMessage = \"Cidr notation should be in the form [ip number]/[range]\";\n    static invalidIPv6CidrNotationString = \"A Cidr notation string should contain an IPv6 number and prefix\";\n\n    /**\n     * Checks if given ipNumber is in between the given lower and upper bound\n     *\n     * @param ipNumber ipNumber to check\n     * @param lowerBound lower bound\n     * @param upperBound upper bound\n     * @returns {boolean} true if ipNumber is between lower and upper bound\n     */\n    private static isWithinRange(ipNumber: bigInt.BigInteger, lowerBound: bigInt.BigInteger, upperBound: bigInt.BigInteger) : boolean {\n        return ipNumber.greaterOrEquals(lowerBound) && ipNumber.lesserOrEquals(upperBound);\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an ASN number\n     *\n     * @param asnNumber the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid ASN, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidAsnNumber(asnNumber: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = this.isWithinRange(asnNumber, bigInt.zero, this.THIRTY_TWO_BIT_SIZE);\n        return [isValid, isValid ? []: [Validator.invalidAsnRangeMessage]];\n    }\n\n    /**\n     * Checks if the given ASN number is a 16bit ASN number\n     *\n     * @param {bigInt.BigInteger} asnNumber to check if 16bit or not\n     * @returns {[boolean , string]} first value is true if valid 16bit ASN, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValid16BitAsnNumber(asnNumber: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = Validator.isWithinRange(asnNumber, bigInt.zero, Validator.SIXTEEN_BIT_SIZE);\n        return [isValid, isValid ? []: [Validator.invalid16BitAsnRangeMessage]];\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an IPv4 number\n     *\n     * @param ipv4Number the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid IPv4 number, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4Number(ipv4Number: bigInt.BigInteger): [boolean, string[]]  {\n        let isValid = this.isWithinRange(ipv4Number, bigInt.zero, this.THIRTY_TWO_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv4NumberMessage]];\n    }\n\n    /**\n     * Checks if the number given is within the value considered valid for an IPv6 number\n     *\n     * @param ipv6Number the asn number to validate\n     * @returns {[boolean , string]} first value is true if valid IPv6 number, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6Number(ipv6Number: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = this.isWithinRange(ipv6Number, bigInt.zero, this.ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv6NumberMessage]];\n    }\n\n    /**\n     * Checks if the number given is valid for an IPv4 octet\n     *\n     * @param octetNumber the octet value\n     * @returns {boolean} true if valid octet, false otherwise\n     */\n    static isValidIPv4Octet(octetNumber: bigInt.BigInteger): [boolean, string[]] {\n        let withinRange = this.isWithinRange(octetNumber, bigInt.zero, this.EIGHT_BIT_SIZE);\n        return [withinRange, withinRange ? []: [Validator.invalidOctetRangeMessage]];\n    }\n\n    /**\n     * Checks if the number given is valid for an IPv6 hexadecatet\n     *\n     * @param {bigInt.BigInteger} hexadecatetNum the hexadecatet value\n     * @returns {[boolean , string]} first value is true if valid hexadecatet, false otherwise. Second value contains\n     * \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6Hexadecatet(hexadecatetNum: bigInt.BigInteger): [boolean, string[]] {\n        let isValid = this.isWithinRange(hexadecatetNum, bigInt.zero, this.SIXTEEN_BIT_SIZE);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidHexadecatetMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv4 value.\n     *\n     * @param {string} ipv4String the IPv4 string to validate\n     * @returns {[boolean , string]} result of validation, first value represents if is valid IPv4, second value\n     * contains error message if invalid IPv4\n     */\n    static isValidIPv4String(ipv4String: string): [boolean, string[]] {\n        let rawOctets = ipv4String.split(\".\");\n\n        if (rawOctets.length != 4) {\n            return [false, [Validator.invalidOctetCountMessage]];\n        }\n\n        let isValid = rawOctets.every(octet => {\n            let [valid,] = Validator.isValidIPv4Octet(bigInt(parseInt(octet)));\n            return valid;\n        });\n\n        return [isValid, isValid ? []: [Validator.invalidOctetRangeMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv6 value.\n     *\n     * @param {string} ipv6String the IPv6 string to validate\n     * @returns {[boolean , string]} result of validation, first value represents if is valid IPv6, second value\n     * contains error message if invalid IPv6\n     */\n    static isValidIPv6String(ipv6String: string): [boolean, string[]] {\n        let hexadecimals = ipv6String.split(\":\");\n        if (hexadecimals.length != 8) {\n            return [false, [Validator.invalidHexadecatetCountMessage]]\n        }\n\n        let isValid = hexadecimals.every(hexadecimal => {\n            let numberValue = parseInt(hexadecimal, 16);\n            return Validator.isValidIPv6Hexadecatet(bigInt(numberValue))[0];\n        });\n\n        return [isValid, isValid? []: [Validator.invalidHexadecatetMessage]];\n    }\n\n    /**\n     * Checks if given value is a valid prefix value\n     *\n     * @param prefixValue value to check\n     * @param ipNumType The type of IP number\n     * @returns {(boolean|string)[]} a tuple representing if valid or not and corresponding message\n     */\n    static isValidPrefixValue(prefixValue: number, ipNumType: IPNumType): [boolean, string[]] {\n        if (IPNumType.IPv4 === ipNumType) {\n            let withinRange = Validator.isWithinRange(bigInt(prefixValue), bigInt.zero, bigInt(32));\n            return [withinRange, withinRange ? []: [Validator.invalidPrefixValueMessage]];\n        }\n        if (IPNumType.IPv6 === ipNumType) {\n            let withinRange = Validator.isWithinRange(bigInt(prefixValue), bigInt.zero, bigInt(128));\n            return [withinRange, withinRange ? []: [Validator.invalidPrefixValueMessage]];\n        }\n        return [false, [\"Given ipNumType must be either InetNumType.IPv4 or InetNumType.IPv6\"]]\n    }\n\n    /**\n     * Checks if given string is a valid IPv4 subnet\n     *\n     * @param {string} ipv4SubnetString the given IPv4 subnet string\n     * @returns {[boolean , string]} first value is true if valid IPv4 subnet string, false otherwise. Second value\n     * contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4Subnet(ipv4SubnetString: string) : [boolean, string[]] {\n        let ipv4InBinary = dottedDecimalNotationToBinaryString(ipv4SubnetString);\n        let isValid = Validator.IPV4_SUBNET_BIT_PATTERN.test(ipv4InBinary);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidSubnetMessage]];\n    }\n\n    /**\n     * Checks if given string is a valid IPv6 subnet\n     *\n     * @param {string} ipv6SubnetString the given IPv6 subnet string\n     * @returns {[boolean , string]} first value is true if valid IPv6 subnet string, false otherwise. Second value\n     * contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6Subnet(ipv6SubnetString: string) : [boolean, string[]] {\n        let ipv6InBinary = hexadectetNotationToBinaryString(ipv6SubnetString);\n        let isValid = Validator.IPV6_SUBNET_BIT_PATTERN.test(ipv6InBinary);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidSubnetMessage]];\n    }\n\n    /**\n     * Checks if the given string is a valid IPv4 range in Cidr notation\n     *\n     * @param {string} ipv4RangeAsCidrString the IPv4 range in Cidr notation\n     *\n     * @returns {[boolean , string[]]} first value is true if valid IPv4 range in Cidr notation, false otherwise. Second\n     * value contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv4CidrNotation(ipv4RangeAsCidrString: string): [boolean, string[]] {\n        let cidrComponents = ipv4RangeAsCidrString.split(\"/\");\n        if(cidrComponents.length !== 2 || (cidrComponents[0].length === 0 || cidrComponents[1].length === 0)) {\n            return [false, [Validator.invalidIPv4CidrNotationMessage]];\n        }\n\n        let ip = cidrComponents[0];\n        let range = cidrComponents[1];\n\n        let [validIpv4, invalidIpv4Message] = Validator.isValidIPv4String(ip);\n        let [validPrefix, invalidPrefixMessage] = Validator.isValidPrefixValue(parseInt(range), IPNumType.IPv4);\n\n        let isValid = validIpv4 && validPrefix;\n        let invalidMessage = invalidIpv4Message.concat(invalidPrefixMessage);\n\n        return isValid ? [isValid, []]: [isValid, invalidMessage];\n    }\n\n    /**\n     * Checks if the given string is a valid IPv6 range in Cidr notation\n     *\n     * @param {string} ipv6RangeAsCidrString the IPv6 range in Cidr notation\n     *\n     * @returns {[boolean , string]} first value is true if valid IPv6 range in Cidr notation, false otherwise.\n     * Second value contains \"valid\" or an error message when value is invalid\n     */\n    static isValidIPv6CidrNotation(ipv6RangeAsCidrString: string): [boolean, string[]] {\n        let isValid = Validator.IPV6_RANGE_PATTERN.test(ipv6RangeAsCidrString);\n        return isValid ? [isValid, []]: [isValid, [Validator.invalidIPv6CidrNotationString]];\n    }\n\n}\n\n\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/Validator.ts","export enum IPNumType {\n    ASN,\n    IPv4,\n    IPv6\n}\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/IPNumType.ts","import {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {hexadecimalStringToBinaryString} from \"./HexadecimalUtils\";\n\n/**\n * Expands an IPv6 number in abbreviated format into its full form\n *\n * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more on the representation of IPv6 addresses\n *\n * @param {string} ipv6String the abbreviated IPv6 address to expand\n * @returns {string} the expanded IPv6 address\n */\nexport let expandIPv6Number = (ipv6String:string):string => {\n    let expandWithZero = (hexadecimalArray: string[]): string => {\n        let paddedArray = hexadecimalArray.map((hexadecimal) => {\n            if (hexadecimal === \"\") {\n                return hexadecimal;\n            }\n            return leftPadWithZeroBit(hexadecimal,4);\n        });\n\n        return paddedArray.join(\":\")\n    };\n\n    let expandDoubleColon = (gapCount: number): string => {\n        let pads = [];\n        for (let count=0; count<gapCount; count++) {\n            pads.push(\"0000\");\n        }\n        return pads.join(\":\");\n    };\n\n    if (ipv6String.includes(\"::\")) {\n        let split = ipv6String.split(\"::\");\n        let leftPortion = split[0];\n        let rightPortion = split[1];\n\n        let leftPortionSplit = leftPortion.split(\":\").filter(hexadecimal => {return hexadecimal !== \"\"});\n        let rightPortionSplit = rightPortion.split(\":\").filter(hexadecimal => {return hexadecimal !== \"\"});\n        let doublePortion = expandDoubleColon(8 - (leftPortionSplit.length + rightPortionSplit.length));\n\n\n        let leftString = expandWithZero(leftPortionSplit);\n        if (leftString !== \"\") {\n            leftString += \":\";\n        }\n\n\n        let rightString = expandWithZero(rightPortionSplit);\n        if (rightString !== \"\") {\n            rightString = \":\"+rightString;\n        }\n\n        return `${leftString}${doublePortion}${rightString}`;\n\n    } else {\n        return expandWithZero(ipv6String.split(\":\"));\n    }\n};\n\n\n/**\n * Collapses an IPv6 number in full format into its abbreviated form\n *\n * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more on the representation of IPv6 addresses\n *\n * @param {string} ipv6String the full form IPv6 number to collapse\n * @returns {string} the collapsed IPv6 number\n */\nexport let collapseIPv6Number = (ipv6String:string):string => {\n    let hexadecimals: string[] = ipv6String.split(\":\");\n    let hexadecimalsWithoutLeadingZeros = hexadecimals.map((hexidecimal) => {\n       let withoutLeadingZero = hexidecimal.replace(/^0+/, '');\n       if (withoutLeadingZero !== '') {\n           return withoutLeadingZero;\n       } else {\n           return \"0\";\n       }\n\n    });\n    let contracted = hexadecimalsWithoutLeadingZeros.join(\":\").replace(/(^0)?(:0){2,}/, ':');\n    if (contracted.slice(-1) === \":\") {\n        return `${contracted}:`;\n    }\n    return contracted;\n};\n\n\n/**\n * Converts a given IPv6 number expressed in the hexadecimal string notation into a 16 bit binary number in string\n * @param {string} hexadectetString the IPv6 number\n * @returns {string} the IPv6 number converted to binary string\n */\nexport let hexadectetNotationToBinaryString = (hexadectetString: string): string => {\n    let expand = expandIPv6Number(hexadectetString);\n    let hexadecimals = expand.split(\":\");\n    return hexadecimals.reduce((hexadecimalAsString, hexavalue) => {\n        return hexadecimalAsString.concat(leftPadWithZeroBit(hexadecimalStringToBinaryString(hexavalue),16));\n    }, '');\n};\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/IPv6Utils.ts","import * as bigInt from \"big-integer\"\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\n\n/**\n * Provides the implementation of functionality that are common to {@link IPNumber}'s\n */\nexport abstract class AbstractIPNum {\n    /**\n     * The decimal value represented by the IP number in BigInteger\n     */\n    abstract readonly value: bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the IP number\n     */\n    abstract readonly bitSize: number;\n    /**\n     * The maximum bit size (i.e. binary value) of the IP number in BigInteger\n     */\n    abstract readonly maximumBitSize: bigInt.BigInteger;\n\n    /**\n     * Gets the numeric value of an IP number as {@link BigInteger}\n     *\n     * @returns {bigInt.BigInteger} the numeric value of an IP number.\n     */\n    public getValue():bigInt.BigInteger {\n        return this.value;\n    }\n\n    /**\n     * Gets the binary string representation of an IP number.\n     *\n     * @returns {string} the string binary representation.\n     */\n    public toBinaryString(): string {\n        return leftPadWithZeroBit(this.value.toString(2), this.bitSize);\n    }\n\n    /**\n     * Checks if an IP number has a value greater than the present value\n     * @returns {boolean} true, if there is a value greater than the present value. Returns false otherwise.\n     */\n    hasNext():boolean {\n        return this.value.lesser(this.maximumBitSize);\n    }\n\n    /**\n     * Checks if an IP number has a value lesser than the present value\n     * @returns {boolean} true, if there is a value lesser than the present value. Returns false otherwise.\n     */\n    hasPrevious():boolean {\n        return this.value.greater(bigInt.zero);\n    }\n\n    /**\n     * Checks if the given IP number, is equals to the current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is equals\n     */\n    public isEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.equals(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is lesser than this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is less than this current one. False otherwise.\n     */\n    public isLessThan(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.lt(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is greater than this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is greater than this current one. False otherwise.\n     */\n    public isGreaterThan(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.gt(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is less than or equals to this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} true if the given IP number is less than or equals to this current one. False otherwise.\n     */\n    public isLessThanOrEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.lesserOrEquals(anotherIPNum.value);\n    }\n\n    /**\n     * Checks if the given IP number is greater than or equals to this current IP number\n     *\n     * @param {AbstractIPNum} anotherIPNum the other IP number to compare with\n     * @returns {boolean} {boolean} true if the given IP number is greater than or equals to this current one. False\n     * otherwise.\n     */\n    public isGreaterThanOrEquals(anotherIPNum: AbstractIPNum): boolean {\n        return this.value.greaterOrEquals(anotherIPNum.value);\n    }\n}\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/AbstractIPNum.ts","import * as bigInt from \"big-integer/BigInteger\";\n\n/**\n * Converts a given BigInteger number to a hexadecimal string\n * @param num the BigInteger number\n * @returns {string} the hexadeciaml string\n */\nexport let bigIntegerNumberToHexadecimalString = (num: bigInt.BigInteger): string => {\n    return num.toString(16);\n};\n\n/**\n * Converts a number in hexadecimal (base 16) to binary string\n * @param {string} hexadecimalString the number in base 16\n * @returns {string} the number converted to base 2\n */\nexport let hexadecimalStringToBinaryString = (hexadecimalString: string) : string => {\n    let inDecimal = bigInt(hexadecimalString, 16);\n    return inDecimal.toString(2);\n};\n\n/**\n * Converts number in binary string to hexadecimal string\n * @param {string} num in binary string\n * @returns {string} num in hexadecimal string\n */\nexport let binaryStringToHexadecimalString = (num: string): string => {\n    // first convert to binary string to decimal (big Integer)\n    let inDecimal = bigInt(num, 2);\n    return inDecimal.toString(16);\n};\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/HexadecimalUtils.ts","import {Validator} from \"./Validator\";\nimport * as bigInt from \"big-integer\"\n\n/**\n * A base 16 (hexadecimal) representation of a 16 bit value.\n *\n * It consists of four (base 16) number.\n *\n * It is used to represents the components of an IPv6 address\n */\nexport class Hexadecatet {\n    private readonly value: number;\n\n    /**\n     * A convenience method for constructing an instance of {@link Hexadecatet} from a four (base 16) number\n     * representation of a 16bit value.\n     *\n     * @param {string} rawValue the four (base 16) number\n     * @returns {Hexadecatet} an instance of {@link Hexadecatet}\n     */\n    static fromString(rawValue:string):Hexadecatet {\n        return new Hexadecatet(rawValue);\n    };\n\n    /**\n     * A convenience method for constructing an instance of {@link Hexadecatet} from a decimal number representation\n     * of a 16 bit value\n     *\n     * @param {number} rawValue decimal number representation of a 16 bit value\n     * @returns {Hexadecatet} an instance of {@link Hexadecatet}\n     */\n    static fromNumber(rawValue:number):Hexadecatet {\n        return new Hexadecatet(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of {@link Hexadecatet}\n     *\n     * @param {string | number} givenValue a string or numeric value. If given value is a string then it should be a\n     * four (base 16) number representation of a 16bit value. If it is a number, then it should be a decimal number\n     * representation of a 16 bit value\n     */\n    constructor(givenValue: string | number) {\n        let hexadecatetValue: number;\n        if (typeof givenValue === 'string') {\n            hexadecatetValue = parseInt(givenValue, 16);\n        } else {\n            hexadecatetValue = parseInt(String(givenValue), 16);\n        }\n\n        let [isValid, message] = Validator.isValidIPv6Hexadecatet(bigInt(hexadecatetValue));\n\n        if (!isValid) {\n            throw Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = hexadecatetValue;\n    }\n\n    /**\n     * Returns the numeric value in base 10 (ie decimal)\n     *\n     * @returns {number} the numeric value in base 10 (ie decimal)\n     */\n    public getValue():number {\n        return this.value;\n    }\n\n    /**\n     * Returns the string representation of the base 16 representation of the value\n     * @returns {string} the string representation of the base 16 representation of the value\n     */\n    // TODO pad with a zero if digit is less than 4\n    public toString(): string {\n        return this.value.toString(16);\n    }\n}\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/Hexadecatet.ts","import {Validator} from \"./Validator\"\nimport bigInt = require(\"big-integer\");\n\n/**\n * A binary representation of a 8 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Octet_(computing)} for more information on Octets\n *\n * An octet is used in the textual representation of an {@link IPv4} number, where the IP number value is divided\n * into 4 octets\n */\nexport class Octet {\n    private readonly value: number;\n\n    /**\n     * Convenience method for creating an Octet out of a string value representing the value of the octet\n     *\n     * @param {string} rawValue the octet value in string\n     * @returns {Octet} the Octet instance\n     */\n    static fromString(rawValue:string):Octet {\n        return new Octet(rawValue);\n    };\n\n    /**\n     * Convenience method for creating an Octet out of a numeric value representing the value of the octet\n     *\n     * @param {number} rawValue the octet value in number\n     * @returns {Octet} the Octet instance\n     */\n    static fromNumber(rawValue:number):Octet {\n        return new Octet(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of an Octet.\n     *\n     * The constructor parameter given could either be a string or number.\n     *\n     * If a string, it is the string representation of the numeric value of the octet\n     * If a number, it is the numeric representation of the value of the octet\n     *\n     * @param {string | number} givenValue value of the octet to be created.\n     */\n    constructor(givenValue: string | number) {\n        let octetValue: number;\n        if (typeof givenValue === 'string') {\n            octetValue = parseInt(givenValue);\n        } else {\n            octetValue = givenValue;\n        }\n        let [isValid, message] = Validator.isValidIPv4Octet(bigInt(octetValue));\n        if (!isValid) {\n            throw Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = octetValue;\n    }\n\n    /**\n     * Method to get the numeric value of the octet\n     *\n     * @returns {number} the numeric value of the octet\n     */\n    public getValue():number {\n        return this.value;\n    }\n\n    /**\n     * Returns a decimal representation of the value of the octet in string\n     *\n     * @returns {string} a decimal representation of the value of the octet in string\n     */\n    public toString(): string {\n        return this.value.toString(10);\n    }\n}\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/Octet.ts","import {Validator} from \"./Validator\";\nimport {IPv4Subnet} from \"./Subnet\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {IPNumType} from \"./IPNumType\";\nimport {IPv6Subnet} from \"./Subnet\";\nimport {binaryStringToHexadecimalString} from \"./HexadecimalUtils\";\nimport {Hexadecatet} from \"./Hexadecatet\";\n\n/**\n * Represents the prefix portion in the CIDR notation for representing IP ranges\n *\n * The IPv4 prefix portion represents the subnet mask. It is the number of continuous bits turned on (with value 1)\n * counting from the left side of an 8 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing} for more information on CIDR\n */\nclass IPv4Prefix {\n    /**\n     * The decimal value of the 8bit number representing the prefix\n     */\n    value: number;\n\n    /**\n     * Convenience method for constructing an instance of IPv4 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv4 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv4 prefix\n     */\n    static fromNumber(rawValue:number):IPv4Prefix {\n        return new IPv4Prefix(rawValue);\n    };\n\n    /**\n     * Constructor for an instance of IPv4 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv4 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv4 prefix\n     */\n    constructor(rawValue: number) {\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidPrefixValue(rawValue, IPNumType.IPv4);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = rawValue;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix\n     *\n     * @returns {number} the decimal value of the IPv4 prefix\n     */\n    public getValue(): number {\n        return this.value;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix as string\n     * @returns {string} he decimal value of the IPv4 prefix as string\n     */\n    public toString(): string {\n        return this.value.toString();\n    }\n\n    /**\n     * Converts the IPv4 prefix to a {@link IPv4Subnet}\n     *\n     * The IPv4 Subnet is the representation of the prefix in the dot-decimal notation\n     *\n     * @returns {IPv4Subnet} the subnet representation of the IPv4 number\n     */\n    public toSubnet(): IPv4Subnet {\n        let onBits = '1'.repeat(this.value);\n        let offBits = '0'.repeat(32 - this.value);\n        return IPv4Subnet.fromString(this.toDecimalNotation(`${onBits}${offBits}`));\n    }\n\n    private toDecimalNotation(bits:string): string {\n        return `${parseBinaryStringToBigInteger(bits.substr(0,8))}.${parseBinaryStringToBigInteger(bits.substr(8,8))}.${parseBinaryStringToBigInteger(bits.substr(16,8))}.${parseBinaryStringToBigInteger(bits.substr(24,8))}`\n    }\n}\n\n/**\n * Represents the prefix portion in the CIDR notation for representing IP ranges\n *\n * The IPv6 prefix portion represents the subnet mask. It is the number of continuous bits turned on (with value 1)\n * counting from the left side of an 128 bit value.\n *\n * {@see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing} for more information on CIDR\n */\nclass IPv6Prefix {\n    /**\n     * The decimal value of the 16bit number representing the prefix\n     */\n    value: number;\n\n    /**\n     * Convenience method for constructing an instance of IPv46 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv6 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv6 prefix\n     */\n    static fromNumber(rawValue:number):IPv6Prefix {\n        return new IPv6Prefix(rawValue);\n    };\n\n    /**\n     * Constructor for an instance of IPv6 prefix from a decimal number\n     *\n     * @param {number} rawValue the decimal value to construct the IPv6 prefix from.\n     * @returns {IPv4Prefix} the instance of an IPv6 prefix\n     */\n    constructor(rawValue: number) {\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidPrefixValue(rawValue, IPNumType.IPv6);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        this.value = rawValue;\n    }\n\n    /**\n     * Gets the decimal value of the IPv6 prefix\n     *\n     * @returns {number} the decimal value of the IPv6 prefix\n     */\n    public getValue(): number {\n        return this.value;\n    }\n\n    /**\n     * Gets the decimal value of the IPv4 prefix as string\n     * @returns {string} he decimal value of the IPv4 prefix as string\n     */\n    public toString(): string {\n        return this.value.toString();\n    }\n\n    /**\n     * Converts the IPv6 prefix to a {@link IPv6Subnet}\n     *\n     * The IPv6 Subnet is the representation of the prefix in 8 groups of 16 bit values represented in hexadecimal\n     *\n     * @returns {IPv4Subnet} the subnet representation of the IPv4 number\n     */\n    public toSubnet(): IPv6Subnet {\n        let onBits = '1'.repeat(this.value);\n        let offBits = '0'.repeat(128 - this.value);\n        return IPv6Subnet.fromString(this.toHexadecatetNotation(`${onBits}${offBits}`));\n    }\n\n    private toHexadecatetNotation(bits:string): string {\n        let binaryStrings: string[] = bits.match(/.{1,16}/g)!;\n        let hexadecimalStrings: Hexadecatet[] = binaryStrings.map((binaryString) => {\n            return Hexadecatet.fromString(binaryStringToHexadecimalString(binaryString));\n        });\n        return hexadecimalStrings.map((value) => { return value.toString()}).join(\":\");\n    }\n}\n\nexport {IPv4Prefix, IPv6Prefix}\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/Prefix.ts","import {Octet} from \"./Octet\";\nimport {Validator} from \"./Validator\";\nimport * as bigInt from \"big-integer\"\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport {Hexadecatet} from \"./Hexadecatet\";\nimport {hexadectetNotationToBinaryString} from \"./IPv6Utils\";\n\n/**\n * The IPv4Subnet can be seen as a specialized IPv4 number where, in a 32 bit number, starting from the left, you have\n * continuous bits turned on (with 1 value) followed by bits turned off (with 0 value)\n */\nexport class IPv4Subnet {\n    /**\n     * An array of {@link Octet}'s\n     *\n     * @type {Array} the octets that makes up the IPv4Subnet\n     */\n    readonly octets: Array<Octet> = [];\n\n    /**\n     * The decimal value represented by the IPv4 subnet in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n\n    /**\n     * A convenience method for creating an instance of IPv4Subnet. The passed strings need to be a valid IPv4\n     * number in dot-decimal notation.\n     *\n     * @param {string} rawValue The passed string in dot-decimal notation\n     * @returns {IPv4Subnet} the instance of IPv4Subnet\n     */\n    static fromString(rawValue:string):IPv4Subnet {\n        return new IPv4Subnet(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of IPv4Subnet. The passed strings need to be a valid IPv4\n     * number in dot-decimal notation.\n     *\n     * @param {string} ipString The passed string in dot-decimal notation\n     */\n    // TODO similar code as in constructor of IPv4, reuse?\n    constructor(ipString: string) {\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidIPv4Subnet(ipString);\n\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringOctets = ipString.split(\".\");\n\n        this.octets = stringOctets.map((rawOctet) => {\n            return Octet.fromString(rawOctet)\n        });\n\n        this.value = bigInt(dottedDecimalNotationToBinaryString(ipString), 2);\n    }\n\n    /**\n     * Method to get the decimal numeric value of the IPv4Subnet as BigInteger\n     *\n     * @returns {bigInt.BigInteger} the decimal numeric value of the IPv4Subnet as BigInteger\n     */\n    public getValue():bigInt.BigInteger {\n        return this.value;\n    }\n\n    /**\n     * Method that converts the IPv4Subnet to a string representation.\n     *\n     * The string representation is in dot-decimal notation\n     *\n     * @returns {string} The string representation of the IPv4Subnet in dot-decimal notation\n     */\n    public toString(): string {\n        return this.octets.map(function(value){ return value.toString()}).join(\".\");\n    }\n\n    /**\n     * Gets the individual {@link Octet} that makes up the IPv4 subnet\n     *\n     * @returns {Array<Octet>} The individual {@link Octet} that makes up the IPv4 subnet\n     */\n    public getOctets(): Array<Octet> {\n        return this.octets;\n    }\n}\n\n/**\n * The IPv6Subnet can be seen as a specialized IPv4 number where, in a 128 bit number, starting from the left, you have\n * continuous bits turned on (with 1 value) followed by bits turned off (with 0 value)\n */\nexport class IPv6Subnet {\n    /**\n     * An array of {@link Hexadecatet}'s\n     *\n     * @type {Array} the hexadecatet that makes up the IPv6 number\n     */\n    readonly hexadecatet: Array<Hexadecatet> = [];\n\n    /**\n     * The decimal value represented by the IPv6 number in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n\n\n    /**\n     * A convenience method for creating an instance of IPv6Subnet. The passed strings need to be a valid IPv6\n     * number in textual representation.\n     *\n     * @param {string} rawValue The passed string in textual notation\n     * @returns {IPv6Subnet} the instance of IPv6Subnet\n     */\n    static fromString(rawValue:string):IPv6Subnet {\n        return new IPv6Subnet(rawValue);\n    };\n\n    /**\n     * Constructor for creating an instance of IPv6Subnet. The passed strings need to be a valid IPv6\n     * number in textual representation\n     *\n     * @param {string} ipString The passed IPv6 string\n     */\n    // TODO similar code as in constructor of IPv4, reuse?\n    constructor(ipString: string) {\n        let isValid: boolean;\n        let message: string[];\n        [isValid, message] = Validator.isValidIPv6Subnet(ipString);\n\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringHexadecimals = ipString.split(\":\");\n\n        this.hexadecatet = stringHexadecimals.map((stringHexadecatet) => {\n            return Hexadecatet.fromString(stringHexadecatet)\n        });\n\n        this.value = bigInt(hexadectetNotationToBinaryString(ipString), 2);\n    }\n\n    /**\n     * Method to get the decimal numeric value of the IPv6Subnet as BigInteger\n     *\n     * @returns {bigInt.BigInteger} the decimal numeric value of the IPv6Subnet as BigInteger\n     */\n    public getValue():bigInt.BigInteger {\n        return this.value;\n    }\n\n    /**\n     * Method that converts the IPv6Subnet to a string representation.\n     *\n     *\n     * @returns {string} The string representation of the IPv6Subnet\n     */\n    public toString(): string {\n        return this.hexadecatet.map(function(value){ return value.toString()}).join(\":\");\n    }\n\n    /**\n     * Gets the individual {@link Hexadecatet} that makes up the IPv6 subnet\n     *\n     * @returns {Array<Hexadecatet>} The individual {@link Hexadecatet} that makes up the IPv6 subnet\n     */\n    public getHexadecatet(): Array<Hexadecatet> {\n        return this.hexadecatet;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/Subnet.ts","import {Octet} from \"./Octet\";\nimport {Validator} from \"./Validator\";\nimport {IPNumber} from \"./interface/IPNumber\";\nimport * as bigInt from \"big-integer\"\nimport {dottedDecimalNotationToBinaryString} from \"./BinaryUtils\";\nimport {bigIntegerNumberToBinaryString} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {AbstractIPNum} from \"./AbstractIPNum\";\nimport {IPNumType} from \"./IPNumType\";\n\n/**\n * Represents an IPv4 number. A 32 bit number that is used to uniquely identify a device that is part of a computer\n * network that uses the internet protocol for communication.\n *\n * @see https://en.wikipedia.org/wiki/IPv4\n * @see https://www.rfc-editor.org/info/rfc791\n */\nexport class IPv4 extends AbstractIPNum implements IPNumber {\n    /**\n     * The decimal value represented by the IPv4 number in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the IPv4 number\n     */\n    readonly bitSize: number = 32;\n    /**\n     * The maximum bit size (i.e. binary value) of the IPv4 number in BigInteger\n     */\n    readonly maximumBitSize: bigInt.BigInteger = Validator.THIRTY_TWO_BIT_SIZE;\n    /**\n     * The type of IP number. Value is one of the values of the {@link IPNumType} enum\n     * @type {IPNumType} the type of IP number\n     */\n    readonly type: IPNumType = IPNumType.IPv4;\n    /**\n     * An array of {@link Octet}'s\n     *\n     * @type {Array} the octets that makes up the IPv4 number\n     */\n    readonly octets: Array<Octet> = [];\n\n    /**\n     * The string character used to separate the individual octets when the IPv4 is rendered as strings\n     *\n     * @type {string} The string character used to separate the individual octets when rendered as strings\n     */\n    readonly separator: string = \".\";\n\n    /**\n     * A convenience method for creating an {@link IPv4} by providing the decimal value of the IP number in BigInteger\n     *\n     * @param {bigInt.BigInteger} bigIntValue the decimal value of the IP number in BigInteger\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromBigInteger(bigIntValue: bigInt.BigInteger): IPv4 {\n        return new IPv4(bigIntValue);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv4} by providing the IP number in dot-decimal notation. E.g\n     * \"10.1.1.10\"\n     *\n     * {@see https://en.wikipedia.org/wiki/Dot-decimal_notation} for more information on dot-decimal notation.\n     *\n     * @param {string} ipString the IP number in dot-decimal notation\n     * @returns {IPv4} the IPv4 instance\n     */\n    static fromDecimalDottedString(ipString: string) : IPv4 {\n        return new IPv4(ipString);\n    }\n\n    /**\n     * Constructor for an IPv4 number.\n     *\n     * @param {string | bigInt.BigInteger} ipValue value to construct an IPv4 from. The given value can either be\n     * numeric or string. If a string is given then it needs to be in dot-decimal notation\n     */\n    constructor(ipValue: string | bigInt.BigInteger) {\n        super();\n        if (typeof ipValue === \"string\" ) {\n            let [value, octets] = this.constructFromDecimalDottedString(ipValue);\n            this.value = value;\n            this.octets = octets\n        } else {\n            let [value, octets] = this.constructFromBigIntegerValue(ipValue);\n            this.value = value;\n            this.octets = octets;\n        }\n    }\n\n    /**\n     * A string representation of the IPv4 number. The string representation is in dot-decimal notation\n     *\n     * @returns {string} The string representation in dot-decimal notation\n     */\n    public toString(): string {\n        return this.octets.map((value) => { return value.toString()}).join(this.separator);\n    }\n\n    /**\n     * Gets the individual {@link Octet} that makes up the IPv4 number\n     *\n     * @returns {Array<Octet>} The individual {@link Octet} that makes up the IPv4 number\n     */\n    public getOctets(): Array<Octet> {\n        return this.octets;\n    }\n\n    /**\n     * Returns the next IPv4 number\n     *\n     * @returns {IPv4} the next IPv4 number\n     */\n    public nextIPNumber(): IPv4 {\n        return IPv4.fromBigInteger(this.getValue().add(1))\n    }\n\n    /**\n     * Returns the previous IPv4 number\n     *\n     * @returns {IPv4} the previous IPv4 number\n     */\n    public previousIPNumber(): IPv4 {\n        return IPv4.fromBigInteger(this.getValue().minus(1))\n    }\n\n    private constructFromDecimalDottedString(ipString: string): [bigInt.BigInteger, Array<Octet>] {\n        let octets;\n        let value;\n        let [isValid, message] = Validator.isValidIPv4String(ipString);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let stringOctets = ipString.split(\".\");\n        octets = stringOctets.map((rawOctet) => {\n            return Octet.fromString(rawOctet)\n        });\n        value = bigInt(dottedDecimalNotationToBinaryString(ipString), 2);\n        return [value, octets]\n    }\n\n    private constructFromBigIntegerValue(ipv4Number: bigInt.BigInteger): [bigInt.BigInteger, Array<Octet>]  {\n        let [isValid, message] = Validator.isValidIPv4Number(ipv4Number);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let binaryString = bigIntegerNumberToBinaryString(ipv4Number);\n        return [ipv4Number, this.binaryStringToDecimalOctets(binaryString)]\n    }\n\n    private binaryStringToDecimalOctets(ipv4BinaryString: string): Array<Octet> {\n        if (ipv4BinaryString.length < 32) {\n            ipv4BinaryString = leftPadWithZeroBit(ipv4BinaryString, 32);\n        }\n        let octets: string[] = ipv4BinaryString.match(/.{1,8}/g)!;\n        return octets.map((octet) => {\n            return Octet.fromString(parseBinaryStringToBigInteger(octet).toString())\n        });\n    }\n}\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/IPv4.ts","import {IPNumber} from \"./interface/IPNumber\";\nimport {Hexadecatet} from \"./Hexadecatet\";\nimport {Validator} from \"./Validator\";\nimport {bigIntegerNumberToBinaryString} from \"./BinaryUtils\";\nimport {binaryStringToHexadecimalString} from \"./HexadecimalUtils\";\nimport {expandIPv6Number} from \"./IPv6Utils\";\nimport {hexadectetNotationToBinaryString} from \"./IPv6Utils\";\nimport * as bigInt from \"big-integer/BigInteger\";\nimport {AbstractIPNum} from \"./AbstractIPNum\";\nimport {IPNumType} from \"./IPNumType\";\n\n\n/**\n * Represents an IPv6 number. A 128 bit number that is used to uniquely identify a device that is part of a computer\n * network that uses the internet protocol for communication.\n *\n * @see https://en.wikipedia.org/wiki/IPv6\n * @see https://www.rfc-editor.org/info/rfc8200\n */\nexport class IPv6 extends AbstractIPNum implements IPNumber {\n    /**\n     * The decimal value represented by the IPv6 number in BigInteger\n     */\n    readonly value: bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the IPv6 number\n     */\n    readonly bitSize: number = 128;\n    /**\n     * The maximum bit size (i.e. binary value) of the IPv6 number in BigInteger\n     */\n    readonly maximumBitSize: bigInt.BigInteger = Validator.ONE_HUNDRED_AND_TWENTY_EIGHT_BIT_SIZE;\n    /**\n     * The type of IP number. Value is one of the values of the {@link IPNumType} enum\n     * @type {IPNumType} the type of IP number\n     */\n    readonly type: IPNumType = IPNumType.IPv6;\n    /**\n     * An array of {@link Hexadecatet}'s\n     *\n     * @type {Array} the hexadecatet that makes up the IPv6 number\n     */\n    readonly hexadecatet: Array<Hexadecatet> = [];\n\n    /**\n     * The string character used to separate the individual hexadecatet when the IPv6 is rendered as strings\n     *\n     * @type {string} The string character used to separate the individual hexadecatet when rendered as strings\n     */\n    readonly separator: string = \":\";\n\n    /**\n     * A convenience method for creating an {@link IPv6} by providing the decimal value of the IP number in BigInteger\n     *\n     * @param {bigInt.BigInteger} bigIntValue the decimal value of the IP number in BigInteger\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromBigInteger(bigIntValue: bigInt.BigInteger): IPv6 {\n        return new IPv6(bigIntValue);\n    }\n\n    /**\n     * A convenience method for creating an {@link IPv6} by providing the IP number in hexadecatet notation. E.g\n     * \"2001:800:0:0:0:0:0:2002\"\n     *\n     * {@see https://en.wikipedia.org/wiki/IPv6_address#Representation} for more information on hexadecatet notation.\n     *\n     * @param {string} ipString the IP number in hexadecatet\n     * @returns {IPv6} the IPv6 instance\n     */\n    static fromHexadecimalString(ipString: string) : IPv6 {\n        return new IPv6(ipString);\n    }\n\n    /**\n     * Constructor for an IPv6 number.\n     *\n     * @param {string | bigInt.BigInteger} ipValue value to construct an IPv6 from. The given value can either be\n     * numeric or string. If a string is given then it needs to be in hexadecatet string notation\n     */\n    constructor(ipValue: string | bigInt.BigInteger) {\n        super();\n        if (typeof ipValue === \"string\" ) {\n            let expandedIPv6 = expandIPv6Number(ipValue);\n            let [value, hexadecatet] = this.constructFromHexadecimalDottedString(expandedIPv6);\n            this.value = value;\n            this.hexadecatet = hexadecatet;\n\n        } else {\n            let [value, hexadecatet] = this.constructFromBigIntegerValue(ipValue);\n            this.value = value;\n            this.hexadecatet = hexadecatet;\n        }\n    }\n\n    /**\n     * A string representation of the IPv6 number.\n     *\n     * @returns {string} The string representation of IPv6\n     */\n    public toString(): string {\n        return this.hexadecatet.map((value) => { return value.toString()}).join(\":\");\n    }\n\n    /**\n     * Gets the individual {@link Hexadecatet} that makes up the IPv6 number\n     *\n     * @returns {Array<Hexadecatet>} The individual {@link Hexadecatet} that makes up the IPv6 number\n     */\n    //TODO maybe rename to something like getSegments? so it can be same with getOctet\n    public getHexadecatet():Array<Hexadecatet> {\n        return this.hexadecatet;\n    }\n\n    /**\n     * Returns the next IPv6 number\n     *\n     * @returns {IPv6} the next IPv6 number\n     */\n    public nextIPNumber(): IPv6 {\n        return IPv6.fromBigInteger(this.getValue().add(1))\n    }\n\n    /**\n     * Returns the previous IPv6 number\n     *\n     * @returns {IPv6} the previous IPv6 number\n     */\n    public previousIPNumber(): IPv6 {\n        return IPv6.fromBigInteger(this.getValue().minus(1))\n    }\n\n    private constructFromBigIntegerValue(ipv6Number: bigInt.BigInteger): [bigInt.BigInteger, Array<Hexadecatet>]  {\n        let [isValid, message] = Validator.isValidIPv6Number(ipv6Number);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let binaryString = bigIntegerNumberToBinaryString(ipv6Number);\n        return [ipv6Number, this.binaryStringToHexadecatets(binaryString)]\n    }\n\n    private constructFromHexadecimalDottedString(expandedIPv6: string): [bigInt.BigInteger, Array<Hexadecatet>] {\n        let [isValid, message] = Validator.isValidIPv6String(expandedIPv6);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n\n        let stringHexadecimals: string[] = expandedIPv6.split(\":\");\n        let hexadecatet: Hexadecatet[]  = stringHexadecimals.map((stringHexadecatet) => {\n            return Hexadecatet.fromString(stringHexadecatet);\n        });\n        let value = bigInt(hexadectetNotationToBinaryString(expandedIPv6), 2);\n        return [value, hexadecatet];\n    }\n\n    private binaryStringToHexadecatets(binaryString: string): Hexadecatet[] {\n        let hexadecimalString = binaryStringToHexadecimalString(binaryString);\n        let hexadecimalStrings: string[] = hexadecimalString.match(/.{1,4}/g)!;\n        return hexadecimalStrings.map((stringHexadecatet)=> {\n            return Hexadecatet.fromString(stringHexadecatet);\n        });\n    }\n}\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/IPv6.ts","/**\n * Exposes all the library's modules making them available from the \"ip-num\" module.\n * Making it possible to get access to all any of the modules by doing require(\"ip-num\")\n *\n * @example\n * let ipNum = require(\"ip-num\")\n * ipNum.IPv4Range // gets access to IPv4Range\n * ipNum.Asn // gets access to Asn\n */\nexport * from './interface/IPNumber'\nexport * from './interface/IPRange'\nexport * from './AbstractIPNum'\nexport * from './Asn'\nexport * from './BinaryUtils'\nexport * from './Hexadecatet'\nexport * from './HexadecimalUtils'\nexport * from './IPNumType'\nexport * from './IPv4'\nexport * from './IPv4Range'\nexport * from './IPv6'\nexport * from './IPv6Range'\nexport * from './IPv6Utils'\nexport * from './Octet'\nexport * from './Prefix'\nexport * from './Subnet'\nexport * from './Validator'\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/index.ts","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 14\n// module chunks = 0","import {Validator} from \"./Validator\"\nimport {IPNumber} from \"./interface/IPNumber\"\nimport {decimalNumberToBinaryString} from \"./BinaryUtils\";\nimport * as bigInt from \"big-integer\"\nimport {IPNumType} from \"./IPNumType\";\nimport {AbstractIPNum} from \"./AbstractIPNum\";\n\n/**\n * Represents an Autonomous System Number. Which is a number that is used to identify\n * a group of IP addresses with a common, clearly defined routing policy.\n *\n * @see https://en.wikipedia.org/wiki/Autonomous_system_(Internet)\n * @see https://www.rfc-editor.org/info/rfc4271\n */\nexport class Asn extends AbstractIPNum implements IPNumber {\n    /**\n     * The decimal value represented by the ASN number in BigInteger\n     */\n    readonly value:bigInt.BigInteger;\n    /**\n     * The number of bits needed to represents the value of the ASN number\n     */\n    bitSize: number = 32;\n    /**\n     * The maximum bit size (i.e. binary value) of the ASN number in BigInteger\n     */\n    maximumBitSize: bigInt.BigInteger = Validator.THIRTY_TWO_BIT_SIZE;\n\n    type: IPNumType = IPNumType.ASN;\n    private static AS_PREFIX = \"AS\";\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a string\n     *\n     * The given string can be in asplain, asdot or asdot+ representation format.\n     * {@see https://tools.ietf.org/html/rfc5396} for more information on\n     * the different ASN string representation\n     *\n     * @param {string} rawValue the asn string. In either asplain, asdot or asdot+ format\n     * @returns {Asn} the constructed ASN instance\n     */\n    static fromString(rawValue:string):Asn {\n        return new Asn(rawValue);\n    };\n\n    /**\n     * A convenience method for creating an instance of {@link Asn} from a numeric value\n     *\n     * @param {number} rawValue the asn numeric value\n     * @returns {Asn} he constructed ASN instance\n     */\n    static fromNumber(rawValue:number):Asn {\n        return new Asn(rawValue);\n    };\n\n    /**\n     * Constructor for an instance of {@link ASN}\n     *\n     * @param {string | number} rawValue value to construct an ASN from. The given value can either be numeric or\n     * string. If in string then it can be in asplain, asdot or asdot+ string representation format\n     */\n    constructor(rawValue:string | number) {\n        super();\n        if (typeof rawValue === 'string') {\n            if (Asn.startWithASprefix(rawValue)) {\n                this.value = bigInt(parseInt(rawValue.substring(2)));\n            } else if(rawValue.indexOf(\".\") != -1) {\n                this.value = bigInt(this.parseFromDotNotation(rawValue));\n            } else {\n                this.value = bigInt(parseInt(rawValue));\n            }\n        }\n        if (typeof rawValue === 'number') {\n            let valueAsBigInt = bigInt(rawValue);\n            let [isValid, message] = Validator.isValidAsnNumber(valueAsBigInt);\n            if (!isValid) {\n                throw Error(message.filter(msg => {return msg !== '';}).toString());\n            }\n            this.value = valueAsBigInt;\n        }\n    }\n\n    /**\n     * A string representation where the asn value is prefixed by \"ASN\". For example \"AS65526\"\n     *\n     * @returns {string} A string representation where the asn value is prefixed by \"ASN\"\n     */\n    toString():string {\n        let stringValue = this.value.toString();\n        return `${Asn.AS_PREFIX}${stringValue}`;\n    }\n\n    /**\n     * A string representation where the ASN numeric value of is represented as a string. For example \"65526\"\n     *\n     * @returns {string} A string representation where the ASN numeric value of is represented as a string\n     */\n    toASPlain():string {\n        return this.value.toString();\n    }\n\n    /**\n     * A string representation where the ASN value is represented using the asplain notation if the ASN value is\n     * less than 65536 and uses asdot+ notation when the value is greater than 65536.\n     *\n     * For example 65526 will be represented as \"65526\" while 65546 will be represented as \"1.10\"\n     *\n     *\n     * @returns {string} A string representation of the ASN in either asplain or asdot+ notation depending on\n     * whether the numeric value of the ASN number is greater than 65526 or not.\n     */\n    toASDot():string {\n        if (this.value.valueOf() >= 65536) {\n            return this.toASDotPlus();\n        }\n        return this.toASPlain();\n    }\n\n    /**\n     * A string representation where the ASN value is represented using the asdot+ notation\n     *\n     * @returns {string} A string representation where the ASN value is represented using the asdot+ notation\n     *\n     */\n    toASDotPlus():string {\n        let high = Math.floor(this.value.valueOf() / 65535);\n        let low = (this.value.valueOf() % 65535) - high;\n        return `${high}.${low}`;\n    }\n\n    /**\n     * Converts the ASN value to binary numbers represented with strings\n     *\n     * @returns {string} a binary string representation of the value of the ASN number\n     */\n    toBinaryString():string {\n        return decimalNumberToBinaryString(this.value.valueOf());\n    }\n\n    /**\n     * Checks if the ASN value is 16bit\n     *\n     * @returns {boolean} true if the ASN is a 16bit value. False otherwise.\n     */\n    is16Bit():boolean {\n        let [valid16BitAsnNumber,] = Validator.isValid16BitAsnNumber(this.value);\n        return valid16BitAsnNumber;\n    }\n\n    /**\n     * Checks if the ASN value is 32bit\n     *\n     * @returns {boolean} true if the ASN is a 32bit value. False otherwise.\n     */\n    is32Bit():boolean {\n        return !this.is16Bit();\n    }\n\n    /**\n     * Returns the next ASN number\n     *\n     * @returns {IPNumber} the next ASN number\n     */\n    nextIPNumber(): IPNumber {\n        return new Asn(this.value.valueOf() + 1);\n    }\n\n    /**\n     * Returns the previous ASN number\n     *\n     * @returns {IPNumber} the previous ASN number\n     */\n    previousIPNumber(): IPNumber {\n        return new Asn(this.value.valueOf() - 1)\n    }\n\n    private static startWithASprefix(word:string):boolean {\n        return word.indexOf(Asn.AS_PREFIX) === 0;\n    }\n\n    private parseFromDotNotation(rawValue: string): number {\n        let values: string[] = rawValue.split(\".\");\n        let high = parseInt(values[0]);\n        let low = parseInt(values[1]);\n        return (high * 65535) + (low + high);\n    }\n}\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/Asn.ts","import {IPv4} from \"./IPv4\";\nimport {IPv4Prefix} from \"./Prefix\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {Validator} from \"./Validator\";\nimport * as bigInt from \"big-integer\";\nimport {IPRange} from \"./interface/IPRange\";\n\n/**\n * Represents a continuous segment of IPv4 numbers following the\n * classless inter-domain routing scheme for allocating IP addresses.\n *\n * @see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n */\nexport class IPv4Range implements IPRange, IterableIterator<IPv4> {\n    private readonly bitValue: bigInt.BigInteger = bigInt(32);\n    private internalCounterValue: IPv4;\n\n    /**\n     * Convenience method for constructing an instance of an IPV4Range from an IP range represented in CIDR notation\n     *\n     * @param {string} rangeIncidrNotation the range of the IPv4 number in CIDR notation\n     * @returns {IPv4Range} the IPv4Range\n     */\n    // TODO introduce an abstract class to share some of the logic between IPv4Range and IPv6Range\n    static fromCidr(rangeIncidrNotation:string):IPv4Range {\n        let [isValid, errorMessages] = Validator.isValidIPv4CidrNotation(rangeIncidrNotation);\n        if (!isValid) {\n            let messages = errorMessages.filter(message => {return message !== ''});\n            throw new Error(messages.join(' and '));\n        }\n        let cidrComponents: Array<string> = rangeIncidrNotation.split(\"/\");\n        let ipString = cidrComponents[0];\n        let prefix = parseInt(cidrComponents[1]);\n        return new IPv4Range(IPv4.fromDecimalDottedString(ipString), IPv4Prefix.fromNumber(prefix));\n    };\n\n    /**\n     * Constructor for creating an instance of an IPv4 range.\n     *\n     * The arguments taken by the constructor is inspired by the CIDR notation which basically consists of the IP\n     * number and the prefix.\n     *\n     * @param {IPv4} ipv4 the IP number used to construct the range. By convention this is the first IP number in\n     * the range, but it could also be any IP number within the range\n     * @param {IPv4Prefix} cidrPrefix the prefix which is a representation of the number of bits used to mask the\n     * given IP number in other to create the range\n     */\n    constructor(private readonly ipv4: IPv4, private readonly cidrPrefix: IPv4Prefix) {\n        this.internalCounterValue = this.getFirst();\n    }\n\n    /**\n     * Gets the size of IPv4 numbers contained within the IPv4 range\n     *\n     * @returns {bigInt.BigInteger} the amount of IPv4 numbers in the range\n     */\n    public getSize(): bigInt.BigInteger {\n        /**\n         * Using bitwise shit operation this will be\n         * 1 << (this.bitValue - this.prefix.getValue())\n         * Since left shift a number by x is equivalent to multiplying the number by the power x raised to 2\n         * 2 << 4 = 2 * (2 raised to 4)\n          */\n        return bigInt(2).pow(this.bitValue.minus(bigInt(this.cidrPrefix.getValue())));\n    }\n\n    /**\n     * Method that returns the IPv4 range in CIDR (Classless Inter-Domain Routing) notation.\n     *\n     * See {@link https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation} for more information\n     * on the Classless Inter-Domain Routing notation\n     *\n     * @returns {string} the IPv4 range in CIDR (Classless Inter-Domain Routing) notation\n     */\n    public toCidrString(): string {\n        return `${this.ipv4.toString()}/${this.cidrPrefix.toString()}`\n    }\n\n    /**\n     * Method that returns the IPv4 range in string notation where the first IPv4 number and last IPv4 number are\n     * separated by an hyphen. eg. 192.198.0.0-192.198.0.255\n     *\n     * @returns {string} the range in [first IPv4 number] - [last IPv4 number] format\n     */\n    public toRangeString(): string {\n        return `${this.getFirst()}-${this.getLast()}`\n    }\n\n\n    /**\n     * Method that returns the first IPv4 number in the IPv4 range\n     *\n     * @returns {IPv4} the first IPv4 number in the IPv4 range\n     */\n    public getFirst(): IPv4 {\n        return IPv4.fromBigInteger(this.ipv4.getValue().and(this.cidrPrefix.toSubnet().getValue()));\n    }\n\n    /**\n     * Method that returns the last IPv4 number in the IPv4 range\n     *\n     * @returns {IPv4} the last IPv4 number in the IPv4 range\n     */\n    public getLast(): IPv4 {\n        let onMask = bigInt(\"1\".repeat(32), 2);\n        let subnetAsBigInteger = this.cidrPrefix.toSubnet().getValue();\n        let invertedSubnet = leftPadWithZeroBit(subnetAsBigInteger.xor(onMask).toString(2), 32);\n        return IPv4.fromBigInteger(this.ipv4.getValue().or(parseBinaryStringToBigInteger(invertedSubnet)));\n    }\n\n    /**\n     * Indicates whether the given IPv4 range is an adjacent range.\n     *\n     * An adjacent range being one where the end of the given range, when incremented by one marks the start of the\n     * other range. Or where the start of the given range, when decreased by one, marks the end of the other range\n     *\n     * @param {IPv4Range} otherRange the other IPv4 range to compare with\n     * @returns {boolean} true if the two IPv4 ranges are consecutive, false otherwise\n     */\n    // TODO move this to the IPRange interface?\n    public isConsecutive(otherRange: IPv4Range): boolean {\n        let thisFirst: IPv4 = this.getFirst();\n        let thisLast: IPv4 = this.getLast();\n        let otherFirst: IPv4 = otherRange.getFirst();\n        let otherLast: IPv4 = otherRange.getLast();\n\n        return (\n            thisLast.hasNext() && thisLast.nextIPNumber().isEquals(otherFirst)\n            ||\n            otherLast.hasNext() && otherLast.nextIPNumber().isEquals(thisFirst)\n        )\n    }\n\n    /**\n     * Indicates if the given IPv4 range is a subset.\n     *\n     * By a subset range, it means all the values of the given range are contained by this IPv4 range\n     *\n     * @param {IPv4Range} otherRange the other IPv4 range\n     * @returns {boolean} true if the other Ipv4 range is a subset. False otherwise.\n     */\n    // TODO move this to the IPRange interface?\n    public contains(otherRange: IPv4Range): boolean {\n        let thisFirst: IPv4 = this.getFirst();\n        let thisLast: IPv4 = this.getLast();\n        let otherFirst: IPv4 = otherRange.getFirst();\n        let otherLast: IPv4 = otherRange.getLast();\n\n        return (thisFirst.isLessThanOrEquals(otherFirst) && thisLast.isGreaterThanOrEquals(otherLast));\n    }\n\n    /**\n     * Indicate if the given range is a container range.\n     *\n     * By container range, it means all the IP number in this current range can be found within the given range.\n     *\n     * @param {IPv4Range} otherRange he other IPv4 range\n     * @returns {boolean} true if the other Ipv4 range is a container range. False otherwise.\n     */\n    public inside(otherRange: IPv4Range): boolean {\n        let thisFirst: IPv4 = this.getFirst();\n        let thisLast: IPv4 = this.getLast();\n        let otherFirst: IPv4 = otherRange.getFirst();\n        let otherLast: IPv4 = otherRange.getLast();\n\n        return (otherFirst.isLessThanOrEquals(thisFirst) && otherLast.isGreaterThanOrEquals(thisLast));\n    }\n\n    /**\n     * Checks if two IPv4 ranges overlap\n     * @param {IPv4Range} otherRange the other IPv4 range\n     * @returns {boolean} true if the ranges overlap, false otherwise\n     */\n    // TODO or confirm than normal ranges cannot overlap\n    public isOverlapping(otherRange: IPv4Range): boolean {\n        let thisFirst: IPv4 = this.getFirst();\n        let thisLast: IPv4 = this.getLast();\n        let otherFirst: IPv4 = otherRange.getFirst();\n        let otherLast: IPv4 = otherRange.getLast();\n\n        return (\n            thisLast.isGreaterThan(otherFirst) && thisLast.isLessThanOrEquals(otherLast) && thisFirst.isLessThan(otherFirst)\n            ||\n            otherLast.isGreaterThan(thisFirst) && otherLast.isLessThanOrEquals(thisLast) && otherFirst.isLessThan(otherFirst)\n        );\n    }\n\n    /**\n     * Method that takes IPv4 number from within an IPv4 range, starting from the first IPv4 number\n     *\n     * @param {number} count the amount of IPv4 number to take from the IPv4 range\n     * @returns {Array<IPv4>} an array of IPv4 number, taken from the IPv4 range\n     */\n    public take(count: number): Array<IPv4> {\n        let ipv4s: Array<IPv4>  = [this.getFirst()];\n        let iteratingIPv4 = this.getFirst();\n\n        if (bigInt(count).greater(this.getSize())) {\n            throw new Error(`${count} is greater than ${this.getSize()}, the size of the range`);\n        }\n\n        for (var counter = 0; counter < count - 1; counter++) {\n            ipv4s.push(iteratingIPv4.nextIPNumber());\n            iteratingIPv4 = iteratingIPv4.nextIPNumber();\n        }\n        return ipv4s;\n    }\n\n    /**\n     * Method that splits an IPv4 range into two halves\n     *\n     * @returns {Array<IPv4Range>} An array of two {@link IPv4Range}\n     */\n    public split() : Array<IPv4Range> {\n        let prefixToSplit = this.cidrPrefix.getValue();\n        if (prefixToSplit === 32) {\n            throw new Error(\"Cannot split an IP range with a single IP number\");\n        }\n        let splitCidr = IPv4Prefix.fromNumber(prefixToSplit + 1);\n        let firstIPOfFirstRange = this.getFirst();\n        let firstRange = new IPv4Range(firstIPOfFirstRange, splitCidr);\n        let firstIPOfSecondRange = firstRange.getLast().nextIPNumber();\n        let secondRange = new IPv4Range(firstIPOfSecondRange, splitCidr);\n        return [firstRange, secondRange];\n    }\n\n    next(value?: any): IteratorResult<IPv4>;\n    next(value?: any): IteratorResult<IPv4>;\n    next(value?: any) {\n        let returnValue = this.internalCounterValue;\n        this.internalCounterValue = this.internalCounterValue.nextIPNumber();\n\n        if (returnValue.isLessThanOrEquals(this.getLast())) {\n            return {\n                done:false,\n                value: returnValue\n            }\n        } else {\n            return {\n                done:true\n            }\n        }\n    }\n\n    return?(value?: any): IteratorResult<IPv4> {\n        return {\n            done:true,\n            value: this.internalCounterValue\n        }\n    }\n\n    // TODO read up on what this method does and decide to implement or remove\n    throw?(e?: any): IteratorResult<IPv4> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    [Symbol.iterator](): IterableIterator<IPv4> {\n        return this;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/IPv4Range.ts","import {IPv6Prefix} from \"./Prefix\";\nimport {IPv6} from \"./IPv6\";\nimport * as bigInt from \"big-integer\";\nimport {leftPadWithZeroBit} from \"./BinaryUtils\";\nimport {parseBinaryStringToBigInteger} from \"./BinaryUtils\";\nimport {Validator} from \"./Validator\";\nimport {IPRange} from \"./interface/IPRange\";\n\n/**\n * Represents a continuous segment of IPv6 number following the\n * classless inter-domain routing scheme for allocating IP addresses.\n *\n * @see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n */\n// TODO introduce an abstract class to share some of the logic between IPv4Range and IPv6Range\nexport class IPv6Range implements IPRange, IterableIterator<IPv6> {\n    private readonly bitValue: bigInt.BigInteger = bigInt(128);\n    private internalCounterValue: IPv6;\n\n    /**\n     * Convenience method for constructing an instance of an IPV6Range from an IP range represented in CIDR notation\n     *\n     * @param {string} rangeIncidrNotation the range of the IPv6 number in CIDR notation\n     * @returns {IPV6Range} the IPV6Range\n     */\n    static fromCidr(rangeIncidrNotation:string):IPv6Range {\n        let [isValid, message] = Validator.isValidIPv6CidrNotation(rangeIncidrNotation);\n        if (!isValid) {\n            throw new Error(message.filter(msg => {return msg !== '';}).toString());\n        }\n        let cidrComponents: Array<string> = rangeIncidrNotation.split(\"/\");\n        let ipString = cidrComponents[0];\n        let prefix = parseInt(cidrComponents[1]);\n\n        return new IPv6Range(IPv6.fromHexadecimalString(ipString), IPv6Prefix.fromNumber(prefix));\n    };\n\n    /**\n     * Constructor for creating an instance of an IPv6 range.\n     *\n     * The arguments taken by the constructor is inspired by the CIDR notation which basically consists of the IP\n     * number and the prefix.\n     *\n     * @param {IPv6} IPv6 the IP number used to construct the range. By convention this is the first IP number in\n     * the range, but it could also be any IP number within the range\n     * @param {IPv6Prefix} cidrPrefix the prefix which is a representation of the number of bits used to mask the\n     * given IPv6 number in other to create the range\n     */\n    constructor(private readonly ipv6: IPv6, private readonly cidrPrefix: IPv6Prefix) {\n        this.internalCounterValue = this.getFirst();\n    }\n\n    /**\n     * Gets the size of IPv6 numbers contained within the IPv6 range\n     *\n     * @returns {bigInt.BigInteger} the amount of IPv6 numbers in the range\n     */\n    public getSize(): bigInt.BigInteger {\n        /**\n         * Using bitwise shit operation this will be\n         * 1 << (this.bitValue - this.prefix.getValue())\n         * Since left shift a number by x is equivalent to multiplying the number by the power x raised to 2\n         * 2 << 4 = 2 * (2 raised to 4)\n         */\n        return bigInt(2).pow(this.bitValue.minus(bigInt(this.cidrPrefix.getValue())));\n    }\n\n    /**\n     * Method that returns the IPv6 range in CIDR (Classless Inter-Domain Routing) notation.\n     *\n     * See {@link https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation} for more information\n     * on the Classless Inter-Domain Routing notation\n     *\n     * @returns {string} the IPv6 range in CIDR (Classless Inter-Domain Routing) notation\n     */\n    public toCidrString(): string {\n        return `${this.ipv6.toString()}/${this.cidrPrefix.toString()}`\n    }\n\n    /**\n     * Method that returns the IPv6 range in string notation where the first IPv6 number and last IPv6 number are\n     * separated by an hyphen. eg. \"2001:db8:0:0:0:0:0:0-2001:db8:0:ffff:ffff:ffff:ffff:ffff\"\n     *\n     * @returns {string} the range in [first IPv6 number] - [last IPv6 number] format\n     */\n    public toRangeString(): string {\n        return `${this.getFirst()}-${this.getLast()}`\n    }\n\n    /**\n     * Method that returns the first IPv6 number in the IPv6 range\n     *\n     * @returns {IPv6} the first IPv6 number in the IPv6 range\n     */\n    public getFirst(): IPv6 {\n        return IPv6.fromBigInteger(this.ipv6.getValue().and(this.cidrPrefix.toSubnet().getValue()));\n    }\n\n    /**\n     * Method that returns the last IPv6 number in the IPv6 range\n     *\n     * @returns {IPv6} the last IPv6 number in the IPv6 range\n     */\n    public getLast(): IPv6 {\n        let onMask = bigInt(\"1\".repeat(128), 2);\n        let subnetAsBigInteger = this.cidrPrefix.toSubnet().getValue();\n        let invertedSubnet = leftPadWithZeroBit(subnetAsBigInteger.xor(onMask).toString(2), 128);\n        return IPv6.fromBigInteger(this.ipv6.getValue().or(parseBinaryStringToBigInteger(invertedSubnet)));\n    }\n\n    /**\n     * Indicates whether the given IPv6 range is an adjacent range.\n     *\n     * An adjacent range being one where the end of the given range, when incremented by one marks the start of the\n     * other range. Or where the start of the given range, when decreased by one, marks the end of the other range\n     *\n     * @param {IPv6Range} otherRange the other IPv6 range to compare with\n     * @returns {boolean} true if the two IPv6 ranges are consecutive, false otherwise\n     */\n    // TODO move this to the IPRange interface?\n    public isConsecutive(otherRange: IPv6Range): boolean {\n        let thisFirst: IPv6 = this.getFirst();\n        let thisLast: IPv6 = this.getLast();\n        let otherFirst: IPv6 = otherRange.getFirst();\n        let otherLast: IPv6 = otherRange.getLast();\n\n        return (\n            thisLast.hasNext() && thisLast.nextIPNumber().isEquals(otherFirst)\n            ||\n            otherLast.hasNext() && otherLast.nextIPNumber().isEquals(thisFirst)\n        )\n    }\n\n    /**\n     * Indicates if the given IPv6 range is a subset.\n     *\n     * By a subset range, it means all the values of the given range are contained by this IPv6 range\n     *\n     * @param {IPv6Range} otherRange the other IPv6 range\n     * @returns {boolean} true if the other Ipv6 range is a subset. False otherwise.\n     */\n    // TODO move this to the IPRange interface?\n    public contains(otherRange: IPv6Range): boolean {\n        let thisFirst: IPv6 = this.getFirst();\n        let thisLast: IPv6 = this.getLast();\n        let otherFirst: IPv6 = otherRange.getFirst();\n        let otherLast: IPv6 = otherRange.getLast();\n\n        return (thisFirst.isLessThanOrEquals(otherFirst) && thisLast.isGreaterThanOrEquals(otherLast));\n    }\n\n    /**\n     * Indicate if the given range is a container range.\n     *\n     * By container range, it means all the IP number in this current range can be found within the given range.\n     *\n     * @param {IPv6Range} otherRange he other IPv6 range\n     * @returns {boolean} true if the other Ipv6 range is a container range. False otherwise.\n     */\n    // TODO move this to the IPRange interface?\n    public inside(otherRange: IPv6Range): boolean {\n        let thisFirst: IPv6 = this.getFirst();\n        let thisLast: IPv6 = this.getLast();\n        let otherFirst: IPv6 = otherRange.getFirst();\n        let otherLast: IPv6 = otherRange.getLast();\n\n        return (otherFirst.isLessThanOrEquals(thisFirst) && otherLast.isGreaterThanOrEquals(thisLast));\n    }\n\n    /**\n     * Checks if two IPv6 ranges overlap\n     * @param {IPv6Range} otherRange the other IPv6 range\n     * @returns {boolean} true if the ranges overlap, false otherwise\n     */\n    // TODO or confirm than normal ranges cannot overlap\n    public isOverlapping(otherRange: IPv6Range): boolean {\n        let thisFirst: IPv6 = this.getFirst();\n        let thisLast: IPv6 = this.getLast();\n        let otherFirst: IPv6 = otherRange.getFirst();\n        let otherLast: IPv6 = otherRange.getLast();\n\n        return (\n            thisLast.isGreaterThan(otherFirst) && thisLast.isLessThanOrEquals(otherLast) && thisFirst.isLessThan(otherFirst)\n            ||\n            otherLast.isGreaterThan(thisFirst) && otherLast.isLessThanOrEquals(thisLast) && otherFirst.isLessThan(otherFirst)\n        );\n    }\n\n    /**\n     * Method that takes IPv6 number from within an IPv6 range, starting from the first IPv6 number\n     *\n     * @param {number} count the amount of IPv6 number to take from the IPv6 range\n     * @returns {Array<IPv6>} an array of IPv6 number, taken from the IPv6 range\n     */\n    public take(count: number): Array<IPv6> {\n        let iPv6s: Array<IPv6>  = [this.getFirst()];\n        let iteratingIPv6 = this.getFirst();\n\n        if (bigInt(count).greater(this.getSize())) {\n            throw new Error(`${count} is greater than ${this.getSize()}, the size of the range`);\n        }\n\n        for (var counter = 0; counter < count - 1; counter++) {\n            iPv6s.push(iteratingIPv6.nextIPNumber());\n            iteratingIPv6 = iteratingIPv6.nextIPNumber();\n        }\n        return iPv6s;\n    }\n\n    /**\n     * Method that splits an IPv6 range into two halves\n     *\n     * @returns {Array<IPv6Range>} An array of two {@link IPv6Range}\n     */\n    public split() : Array<IPv6Range> {\n        let prefixToSplit = this.cidrPrefix.getValue();\n        if (prefixToSplit === 128) {\n            throw new Error(\"Cannot split an IP range with a single IP number\");\n        }\n        let splitCidr = IPv6Prefix.fromNumber(prefixToSplit + 1);\n        let firstIPOfFirstRange = this.getFirst();\n        let firstRange = new IPv6Range(firstIPOfFirstRange, splitCidr);\n        let firstIPOfSecondRange = firstRange.getLast().nextIPNumber();\n        let secondRange = new IPv6Range(firstIPOfSecondRange, splitCidr);\n        return [firstRange, secondRange];\n    }\n\n\n    next(value?: any): IteratorResult<IPv6>;\n    next(value?: any): IteratorResult<IPv6>;\n    next(value?: any) {\n        let returnValue = this.internalCounterValue;\n        this.internalCounterValue = this.internalCounterValue.nextIPNumber();\n\n        if (returnValue.isLessThanOrEquals(this.getLast())) {\n            return {\n                done:false,\n                value: returnValue\n            }\n        } else {\n            return {\n                done:true\n            }\n        }\n    }\n\n    return?(value?: any): IteratorResult<IPv6> {\n        return {\n            done:true,\n            value: this.internalCounterValue\n        }\n    }\n\n    // TODO read up on what this method does and decide to implement or remove\n    throw?(e?: any): IteratorResult<IPv6> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    [Symbol.iterator](): IterableIterator<IPv6> {\n        return this;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// /Users/daderemi/Documents/play/ip-num/src/IPv6Range.ts"],"sourceRoot":""}